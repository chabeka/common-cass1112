/**
 * 
 */
package fr.urssaf.image.sae.trace.dao.support;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;

import me.prettyprint.cassandra.service.template.ColumnFamilyResult;
import me.prettyprint.cassandra.service.template.ColumnFamilyTemplate;
import me.prettyprint.cassandra.service.template.ColumnFamilyUpdater;
import me.prettyprint.cassandra.utils.TimeUUIDUtils;
import me.prettyprint.hector.api.mutation.Mutator;
import me.prettyprint.hector.api.query.SliceQuery;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import fr.urssaf.image.sae.trace.dao.TraceRegExploitationDao;
import fr.urssaf.image.sae.trace.dao.TraceRegExploitationIndexDao;
import fr.urssaf.image.sae.trace.dao.iterator.TraceRegExploitationIndexIterator;
import fr.urssaf.image.sae.trace.dao.model.TraceRegExploitation;
import fr.urssaf.image.sae.trace.dao.model.TraceRegExploitationIndex;
import fr.urssaf.image.sae.trace.dao.serializer.ListSerializer;
import fr.urssaf.image.sae.trace.dao.serializer.MapSerializer;

/**
 * Support de la classe DAO {@link TraceRegExploitationDao}
 * 
 */
@Component
public class TraceRegExploitationSupport {

   @Autowired
   private TraceRegExploitationDao dao;

   @Autowired
   private TraceRegExploitationIndexDao indexDao;

   /**
    * Création d'une trace dans le registre d'exploitation
    * 
    * @param exploitation
    *           trace d'exploitation à créer
    * @param clock
    *           horloge de la création
    */
   public final void create(TraceRegExploitation exploitation, long clock) {
      // création de la ligne
      ColumnFamilyTemplate<UUID, String> tmpl = dao.getExploitTmpl();
      ColumnFamilyUpdater<UUID, String> updater = tmpl
            .createUpdater(exploitation.getIdentifiant());

      dao.writeColumnAction(updater, exploitation.getAction(), clock);
      dao.writeColumnCodeEvt(updater, exploitation.getCodeEvt(), clock);
      dao.writeColumnTimestamp(updater, exploitation.getTimestamp(), clock);

      if (StringUtils.isNotBlank(exploitation.getContrat())) {
         dao.writeColumnContratService(updater, exploitation.getContrat(),
               clock);
      }

      if (CollectionUtils.isNotEmpty(exploitation.getPagms())) {
         dao.writeColumnPagms(updater, exploitation.getPagms(), clock);
      }

      if (StringUtils.isNotBlank(exploitation.getLogin())) {
         dao.writeColumnLogin(updater, exploitation.getLogin(), clock);
      }

      if (MapUtils.isNotEmpty(exploitation.getInfos())) {
         dao.writeColumnInfos(updater, exploitation.getInfos(), clock);
      }

      tmpl.update(updater);

      // création de l'index
      TraceRegExploitationIndex index = new TraceRegExploitationIndex(
            exploitation);
      String journee = indexDao.getJournee(index.getTimestamp());
      ColumnFamilyUpdater<String, UUID> indexUpdater = indexDao
            .createUpdater(journee);
      indexDao.writeColumn(indexUpdater, index.getIdentifiant(), index, clock);
      indexDao.update(indexUpdater);

   }

   /**
    * Suppression de toutes les traces et index
    * 
    * @param date
    *           date pour laquelle supprimer les traces
    * @param clock
    *           horloge de la suppression
    */
   public final void delete(Date date, long clock) {

      SliceQuery<String, UUID, TraceRegExploitationIndex> sliceQuery;
      sliceQuery = indexDao.createSliceQuery();
      String journee = indexDao.getJournee(date);
      sliceQuery.setKey(journee);

      TraceRegExploitationIndexIterator iterator = new TraceRegExploitationIndexIterator(
            sliceQuery);

      deleteRecords(iterator, clock);

      // suppression de l'index
      Mutator<String> indexMutator = indexDao.createMutator();
      indexDao.mutatorSuppressionTraceRegExploitationIndex(indexMutator,
            journee, clock);
      indexMutator.execute();

   }

   /**
    * Recherche et retourne la trace d'exploitation avec l'identifiant donné
    * 
    * @param identifiant
    *           identifiant de la trace d'exploitation
    * @return la trace d'exploitation
    */
   public final TraceRegExploitation find(UUID identifiant) {
      ColumnFamilyTemplate<UUID, String> tmpl = dao.getExploitTmpl();
      ColumnFamilyResult<UUID, String> result = tmpl.queryColumns(identifiant);

      return getTraceRegExploitationFromResult(result);
   }

   /**
    * recherche et retourne la liste des traces d'exploitation à une date donnée
    * 
    * @param date
    *           date à laquelle trouver les traces
    * @return la liste des traces d'exploitation
    */
   public final List<TraceRegExploitationIndex> findByDate(Date date) {
      List<TraceRegExploitationIndex> list = null;

      SliceQuery<String, UUID, TraceRegExploitationIndex> sliceQuery = indexDao
            .createSliceQuery();
      sliceQuery.setKey(indexDao.getJournee(date));

      TraceRegExploitationIndexIterator iterator = new TraceRegExploitationIndexIterator(
            sliceQuery);

      if (iterator.hasNext()) {
         list = new ArrayList<TraceRegExploitationIndex>();
      }

      while (iterator.hasNext()) {
         list.add(iterator.next());
      }

      return list;
   }

   /**
    * recherche et retourne la liste des traces d'exploitation pour un
    * intervalle de dates données
    * 
    * @param startDate
    *           date de début de recherche
    * @param endDate
    *           date de fin de recherche
    * @param maxCount
    *           nombre maximal d'enregistrements à retourner
    * @param reversed
    *           booleen indiquant si l'ordre décroissant doit etre appliqué<br>
    *           <ul>
    *           <li>true : ordre décroissant</li>
    *           <li>false : ordre croissant</li>
    *           </ul>
    * @return la liste des traces d'exploitation
    */
   public final List<TraceRegExploitationIndex> findByDates(Date startDate,
         Date endDate, int maxCount, boolean reversed) {
      List<TraceRegExploitationIndex> list = null;

      SliceQuery<String, UUID, TraceRegExploitationIndex> sliceQuery = indexDao
            .createSliceQuery();
      sliceQuery.setKey(indexDao.getJournee(startDate));

      UUID startUuid = TimeUUIDUtils.getTimeUUID(startDate.getTime());
      UUID endUuid = TimeUUIDUtils.getTimeUUID(endDate.getTime());

      TraceRegExploitationIndexIterator iterator = new TraceRegExploitationIndexIterator(
            sliceQuery, startUuid, endUuid, reversed);
      if (iterator.hasNext()) {
         list = new ArrayList<TraceRegExploitationIndex>();
      }

      int count = 0;
      while (iterator.hasNext() && count < maxCount) {
         list.add(iterator.next());
         count++;
      }

      return list;
   }

   private TraceRegExploitation getTraceRegExploitationFromResult(
         ColumnFamilyResult<UUID, String> result) {

      TraceRegExploitation exploit = null;

      if (result != null && result.hasResults()) {
         exploit = new TraceRegExploitation();

         exploit.setIdentifiant(result.getKey());

         exploit
               .setAction(result.getString(TraceRegExploitationDao.COL_ACTION));
         exploit.setCodeEvt(result
               .getString(TraceRegExploitationDao.COL_CODE_EVT));
         exploit.setContrat(result
               .getString(TraceRegExploitationDao.COL_CONTRAT_SERVICE));
         exploit.setLogin(result.getString(TraceRegExploitationDao.COL_LOGIN));
         exploit.setTimestamp(result
               .getDate(TraceRegExploitationDao.COL_TIMESTAMP));

         byte[] bValue = result.getByteArray(TraceRegExploitationDao.COL_INFOS);
         if (bValue != null) {
            exploit.setInfos(MapSerializer.get().fromBytes(bValue));
         }

         bValue = result.getByteArray(TraceRegExploitationDao.COL_PAGMS);
         if (bValue != null) {
            exploit.setPagms(ListSerializer.get().fromBytes(bValue));
         }

      }

      return exploit;
   }

   private void deleteRecords(TraceRegExploitationIndexIterator iterator,
         long clock) {

      // suppression de toutes les traces
      Mutator<UUID> mutator = dao.createMutator();
      while (iterator.hasNext()) {
         dao.mutatorSuppressionRegExploitation(mutator, iterator.next()
               .getIdentifiant(), clock);
      }
      mutator.execute();
   }

}
