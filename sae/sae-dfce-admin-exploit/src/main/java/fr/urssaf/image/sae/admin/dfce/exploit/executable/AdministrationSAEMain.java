package fr.urssaf.image.sae.admin.dfce.exploit.executable;

import java.io.File;
import java.util.UUID;

import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.context.ApplicationContext;

import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.sae.admin.dfce.exploit.constantes.ReindexMetaConstantes;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.AdminDfceRuntimeException;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.ArchiveLogsRunningEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.BaseAdministrationPermissionEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.BaseAdministrationServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.ConnectionServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.GeneralAdminDfceException;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.PurgeDocumentEventsException;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.PurgeSystemEventsException;
import fr.urssaf.image.sae.admin.dfce.exploit.factory.SAEApplicationContextFactory;
import fr.urssaf.image.sae.admin.dfce.exploit.services.AdministrationDFCEService;
import fr.urssaf.image.sae.admin.dfce.exploit.services.ArchiveLogDocumentDFCEService;
import fr.urssaf.image.sae.admin.dfce.exploit.services.ArchiveLogSystemDFCEService;
import fr.urssaf.image.sae.admin.dfce.exploit.services.RollbackService;
import fr.urssaf.image.sae.admin.dfce.exploit.support.CommandeSAELineHelper;
import fr.urssaf.image.sae.admin.dfce.exploit.utils.RepertoryUtils;
import fr.urssaf.image.sae.admin.dfce.exploit.utils.ValidateUtils;

/**
 * Classe qui fournit l'appele aux services:
 * <ul>
 * <li>Service de mise à jour des indexes.</li>
 * <li>Service de création de la base de données SAE.</li>
 * <li>Service de création du journal d'événement de type <b>Documents</b></li>
 * <li>Service de purge des journaux de type <b>Documents</b></li>
 * <li>Service de consultation du fichier d'archivage de type<b>Documents</b></li>
 * <li>Service de création du journal d'événement de type <b>System</b></li>
 * <li>Service de purge des journaux de type <b>System</b></li>
 * <li>Service de consultation du fichier d'archivage de type <b>System</b></li>
 * </ul>
 * 
 */
public final class AdministrationSAEMain {

   private static final Logger LOGGER = LoggerFactory
         .getLogger(AdministrationSAEMain.class);

   public static final String REINDEX = "reindex";
   public static final String CREATE_DOC_EVENT = "createDocEvent";
   public static final String CLEAR_DOC_EVENT = "clearDocEvent";
   public static final String CONSULT_DOC_EVENT = "consultDocEvent";
   public static final String CREATE_SYS_EVENT = "creatSystemEvent";
   public static final String CLEAR_SYS_EVENT = "clearSystemEvent";
   public static final String CONSULT_SYS_EVENT = "consultSystemEvent";
   public static final String CREATE_DATA_BASE = "createDataBase";
   public static final String HELP = "help";
   public static final String UPDATE_LIFECYCLE = "updateLifecycleRules";
   public static final String UPDATE_DOCUMENTS = "updateDocuments";
   public static final String INDEX_COMPOSITE = "indexComposite";
   public static final String UPDATE_DOCS_STATS = "updateDocsStats";
   public static final String ROLLBACK = "rollbackTraitement";
   public static final String SPLIT_INDEX = "splitIndex";
   public static final String MERGE_INDEX = "mergeIndex";
   public static final String GET_INDEXES_OVER_LIMIT = "getIndexesOverLimit";
   public static final String GET_INDEXES_SIZE = "getIndexesSize";
   // TIMEOUT CONFIGURE A 3H
   public static final int TIMEOUT_DFCE = 10800000; 

   public static final String[] AVAIBLE_SERVICES = new String[] { REINDEX,
         CREATE_DOC_EVENT, CLEAR_DOC_EVENT, CONSULT_DOC_EVENT,
         CREATE_SYS_EVENT, CLEAR_SYS_EVENT, CONSULT_SYS_EVENT,
         CREATE_DATA_BASE, UPDATE_LIFECYCLE, UPDATE_DOCUMENTS, ROLLBACK, 
         INDEX_COMPOSITE, UPDATE_DOCS_STATS, SPLIT_INDEX, MERGE_INDEX, 
         GET_INDEXES_OVER_LIMIT, GET_INDEXES_SIZE };

   private final String configLocation;

   protected AdministrationSAEMain(String configLocation) {

      this.configLocation = configLocation;
   }

   /**
    * Service de mise à jour des indexes.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void updateIndexes(final DFCEConnection cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx {
      // Vérification des paramètres d'entrée

      // appel du service de mise à jour des indexes
      final AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);

      adminDFCE.updateIndexes(cnxParameter);

   }
   
   /**
    * Service de mise à jour des statistiques sur les documents.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void updateDocsStats(final DFCEConnection cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx {
      // Vérification des paramètres d'entrée

      // appel du service de mise à jour des indexes
      final AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);

      adminDFCE.updateDocsStats(cnxParameter);
   }

   /**
    * Service de création du journal d'événements de type <b>Documents</b>.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws ArchiveLogsRunningEx
    *            s'il y a un problème survient lors de l'archivage.
    */
   private void createDocumentsEventLogs(
         final DFCEConnection cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         ArchiveLogsRunningEx {
      // Vérification des paramètres d'entrée

      // appel du service de mise à jour des indexes
      final ArchiveLogDocumentDFCEService adminDFCE = context
            .getBean(ArchiveLogDocumentDFCEService.class);

      adminDFCE.createDocumentsEventLogs(cnxParameter);

   }

   /**
    * Service de création du journal d'événements de type <b>Système</b>.
    * 
    * @param args
    *           arguments de la ligne de commande qui va contenir le nombre de
    *           jour permettant le calcul de la date d'arrêt des logs
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws ArchiveLogsRunningEx
    *            s'il y a un problème survient lors de l'archivage.
    */
   private void createSystemEventLogs(final String[] args,
         final DFCEConnection cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         ArchiveLogsRunningEx {
      // Vérification des paramètres d'entrée

      // appel du service de mise à jour des indexes
      final ArchiveLogSystemDFCEService adminDFCE = context
            .getBean(ArchiveLogSystemDFCEService.class);
      String durationStr = "-1";
      if (!ArrayUtils.isEmpty(args)) {
         durationStr = args[0];
      }

      final int archiveDuration = Integer.parseInt(durationStr);
      adminDFCE.createSystemEventLogs(cnxParameter, archiveDuration);

   }

   /**
    * Service de création du journal d'événements de type <b>Documents</b>.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws PurgeDocumentEventsException
    *            une exception est levée lors de la purge des événements de type
    *            document
    */
   private void purgeDocumentsEvents(final String[] args,
         final DFCEConnection cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         PurgeDocumentEventsException {

      // Vérification des paramètres d'entrée
      if (!ValidateUtils.isNotBlank(args, 0) || !StringUtils.isNumeric(args[0])) {
         throw new IllegalArgumentException(
               "La durée de conservation doit être renseigné.");
      }
      // appel du service de mise à jour des indexes
      final ArchiveLogDocumentDFCEService adminDFCE = context
            .getBean(ArchiveLogDocumentDFCEService.class);
      final String durationStr = args[0];

      final int archiveDuration = Integer.parseInt(durationStr);
      adminDFCE.purgeDocumentsEvents(cnxParameter, archiveDuration);

   }

   /**
    * Service de création du journal d'événements de type <b>Documents</b>.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws PurgeSystemEventsException
    *            une exception est levée lors de la purge des événements
    *            systèmes
    */
   private void purgeSystemEvents(final String[] args,
         final DFCEConnection cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         PurgeSystemEventsException {

      // Vérification des paramètres d'entrée
      if (!ValidateUtils.isNotBlank(args, 0) || !StringUtils.isNumeric(args[0])) {
         throw new IllegalArgumentException(
               "La durée de conservation doit être renseigné.");
      }
      // appel du service de mise à jour des indexes
      final ArchiveLogSystemDFCEService adminDFCE = context
            .getBean(ArchiveLogSystemDFCEService.class);
      final String durationStr = args[0];

      final int archiveDuration = Integer.parseInt(durationStr);
      adminDFCE.purgeSystemEvents(cnxParameter, archiveDuration);

   }

   /**
    * Service de création du journal d'événements de type <b>Documents</b>.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws ArchiveLogsRunningEx
    *            s'il y a un problème survient lors de l'archivage.
    * @throws BaseAdministrationPermissionEx
    *            s'il y a un problèmed'accès ou de droit.
    */
   private void extractDocumentsArchiveFile(final String[] args,
         final DFCEConnection cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         ArchiveLogsRunningEx, BaseAdministrationPermissionEx {

      // Vérification des paramètres d'entrée
      if (!ValidateUtils.isNotBlank(args, 0)) {
         throw new IllegalArgumentException(
               "Le chemin de dépot des fichier de log doit être renseigné.");
      }
      // appel du service de mise à jour des indexes
      final ArchiveLogDocumentDFCEService adminDFCE = context
            .getBean(ArchiveLogDocumentDFCEService.class);
      final String filePath = args[0];
      boolean dirPermission = RepertoryUtils.isWrite(filePath);

      if (!dirPermission) {

         throw new BaseAdministrationPermissionEx(
               "Le SAE ne dispose pas des droits d'écriture dans le répertoire "
                     + filePath);
      }
      adminDFCE.extractDocumentsArchiveFile(cnxParameter, filePath);

   }

   /**
    * Service de création du journal d'événements de type <b>Documents</b>.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws ArchiveLogsRunningEx
    *            s'il y a un problème survient lors de l'archivage.
    * @throws BaseAdministrationPermissionEx
    *            s'il y a un problèmed'accès ou de droit
    */
   private void extractSystemArchiveFile(final String[] args,
         final DFCEConnection cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         ArchiveLogsRunningEx, BaseAdministrationPermissionEx {

      // Vérification des paramètres d'entrée
      if (!ValidateUtils.isNotBlank(args, 0)) {
         throw new IllegalArgumentException(
               "Le chemin de dépot des fichier de log doit être renseigné.");
      }
      // appel du service de mise à jour des indexes
      final ArchiveLogSystemDFCEService adminDFCE = context
            .getBean(ArchiveLogSystemDFCEService.class);
      final String filePath = args[0];

      boolean dirPermission = RepertoryUtils.isWrite(filePath);
      if (!dirPermission) {

         throw new BaseAdministrationPermissionEx(
               "Le SAE ne dispose pas des droits d'écriture dans le répertoire "
                     + filePath);
      }
      adminDFCE.extractSystemArchiveFile(cnxParameter, filePath);

   }

   /**
    * Service de création de la base de données SAE.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws BaseAdministrationServiceEx
    *            s'il y'a une problème lors de l'appel d'un service
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void createSAEBase(final String[] args,
         final DFCEConnection cnxParameter,
         final ApplicationContext context) throws BaseAdministrationServiceEx,
         ConnectionServiceEx {

      final AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);
      // Vérification des paramètres d'entrée
      if (!ValidateUtils.isNotBlank(args, 0)) {
         throw new IllegalArgumentException(
               "Le chemin complet du fichier du modèle de la base de données SAE doit être renseigné.");
      }
      if (!ValidateUtils.isNotBlank(args, 1)) {
         throw new IllegalArgumentException(
               "Le chemin complet du fichier des types de documents SAE doit être renseigné.");
      }
      final String dataBasePath = args[0];
      final String documentsTypePath = args[1];
      final File xmlDataBaseModel = new File(dataBasePath);
      final File xmlDocumentsType = new File(documentsTypePath);
      if (!xmlDataBaseModel.isFile()) {
         throw new BaseAdministrationServiceEx(
               "Le modèle de la base de données SAE n'est pas valide.");
      }
      if (!xmlDocumentsType.isFile()) {
         throw new BaseAdministrationServiceEx(
               "Le fichier des types de documents SAE n'est pas valide.");
      }
      // appel du service de création de la base de données.

      adminDFCE.createSAEBase(cnxParameter, xmlDataBaseModel, xmlDocumentsType);

   }

   /**
    * Service de mise à jour des données de la table LifeCycle
    * 
    */
   private void updateLiveCycleRules(String[] args,
         DFCEConnection cnxParameter, ApplicationContext context)
         throws BaseAdministrationServiceEx, ConnectionServiceEx {

      AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);

      String lifeCyclePath = args[0];

      File xmlDocumentsType = new File(lifeCyclePath);

      if (!xmlDocumentsType.isFile()) {
         throw new BaseAdministrationServiceEx(
               "Le fichier des durées de conservation n'est pas valide.");
      }

      adminDFCE.updateLifeCycleRules(cnxParameter, xmlDocumentsType);

   }

   /**
    * Apple les services :
    * 
    * <ul>
    * <li>Service de mise à jour des indexes.</li>
    * <li>Service de création de la base de données SAE.</li>
    * <li>Service de création du journal d'événement de type <b>Documents</b></li>
    * <li>Service de purge des journaux de type <b>Documents</b></li>
    * <li>Service de consultation du fichier d'archivage de type<b>Documents</b>
    * </li>
    * <li>Service de création du journal d'événement de type <b>System</b></li>
    * <li>Service de purge des journaux de type <b>System</b></li>
    * <li>Service de consultation du fichier d'archivage de type <b>System</b></li>
    * </ul>
    * 
    * @param args
    *           arguments de l'exécutable
    */
   public static void main(final String[] args) {

      LOGGER.info("Arguments de la ligne de commande : {}", StringUtils.join(
            args, ' '));

      AdministrationSAEMain adminSAE = new AdministrationSAEMain(
            "/applicationContext-sae-dfce-admin-exploit.xml");

      adminSAE.execute(args);

   }

   protected void execute(String[] args) {

      if (!ValidateUtils.isNotBlank(args, 0)) {

         LOGGER.warn("L'opération du traitement doit être renseigné.");
         LOGGER
               .info("Help: ligne de commande pour les services d'administration SAE: ");
         LOGGER.info(CommandeSAELineHelper.helpCommandeLine());

         return;
      }

      String service = args[0];

      if (HELP.equals(service)) {

         LOGGER
               .info("Help: ligne de commande pour les services d'administration SAE: ");
         LOGGER.info(CommandeSAELineHelper.helpCommandeLine());

         return;

      }

      if (!ArrayUtils.contains(AVAIBLE_SERVICES, service)) {
         LOGGER.warn("Le service demande {} n'est pas valide", service);
         LOGGER.info("Services disponibles :\r{}\r{}\r{}\r{}\r{}\r{}\r{}",
               AVAIBLE_SERVICES);

         return;
      }

      // instanciation du contexte de SPRING
      if (!ValidateUtils.isNotBlank(args, 1)) {

         LOGGER
               .warn("Le chemin complet du fichier de configuration générale du SAE doit être renseigné.");

         return;
      }

      String saeConfiguration = args[1];
      ApplicationContext context = SAEApplicationContextFactory
            .createSAEApplicationContext(this.configLocation, saeConfiguration);

      String[] newArgs = (String[]) ArrayUtils.subarray(args, 2, args.length);

      try {

         this.executeService(service, context, newArgs);

      } catch (Throwable e) {
         LOGGER.error(
               "Une erreur s'est produite lors du traitement " + service, e);
      }
   }

   protected void executeService(String service, ApplicationContext context,
         String[] args) throws GeneralAdminDfceException, ConnectionServiceEx {

      DFCEConnection cnxParameter = context
            .getBean(DFCEConnection.class);
      // les operations de ce services peuvent etre relativement longue
      // on configure donc un timeout de 3h (plutot que quelques minutes)
      cnxParameter.setTimeout(TIMEOUT_DFCE);

      if (CREATE_DATA_BASE.equals(service)) {
         createSAEBase(args, cnxParameter, context);
      } 
      else if (REINDEX.equals(service)) {
         updateIndexes(cnxParameter, context);
      } 
      else if (CREATE_DOC_EVENT.equals(service)) {
         createDocumentsEventLogs(cnxParameter, context);
      } 
      else if (CLEAR_DOC_EVENT.equals(service)) {
         purgeDocumentsEvents(args, cnxParameter, context);
      } 
      else if (CONSULT_DOC_EVENT.equals(service)) {
         extractDocumentsArchiveFile(args, cnxParameter, context);
      } 
      else if (CREATE_SYS_EVENT.equals(service)) {
         createSystemEventLogs(args, cnxParameter, context);
      } 
      else if (CLEAR_SYS_EVENT.equals(service)) {
         purgeSystemEvents(args, cnxParameter, context);
      } 
      else if (CONSULT_SYS_EVENT.equals(service)) {
         extractSystemArchiveFile(args, cnxParameter, context);
      } 
      else if (UPDATE_LIFECYCLE.equals(service)) {
         updateLiveCycleRules(args, cnxParameter, context);
      } 
      else if (UPDATE_DOCUMENTS.equals(service)) {
         reindexCategories(cnxParameter, args, context);
      } 
      else if (INDEX_COMPOSITE.equals(service)) {
         reindexComposites(cnxParameter, args, context);
      } 
      else if (UPDATE_DOCS_STATS.equals(service)) {
         updateDocsStats(cnxParameter, context);
      } 
      else if (ROLLBACK.equals(service)) {
         rollbackTraitement(cnxParameter, args, context);
      } 
      else if (SPLIT_INDEX.equals(service)) {
         splitIndex(cnxParameter, args, context);
      }
      else if (MERGE_INDEX.equals(service)) {
         mergeIndex(cnxParameter, args, context);
      }
      else if (GET_INDEXES_OVER_LIMIT.equals(service)) {
         getIndexesOverLimit(cnxParameter, args, context);
      }
      else if (GET_INDEXES_SIZE.equals(service)) {
         getIndexesSize(cnxParameter, args, context);
      }
   }

   /**
    * Service permettant de réaliser le rollback pour un traitement de masse.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param args
    *           : argument passé en ligne de commande
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void rollbackTraitement(final DFCEConnection cnxParameter,
         final String[] args, final ApplicationContext context)
         throws ConnectionServiceEx {

      if (ArrayUtils.isEmpty(args) || StringUtils.isEmpty(args[0])) {
         throw new IllegalArgumentException(
               "Identifiant du traitement de masse obligatoire");
      }

      String sUuid = args[0];
      try {
         // initialisation du contexte du LOGBACK
         MDC.put("log_contexte_uuid", sUuid);

         UUID idTraitement = UUID.fromString(sUuid);
         RollbackService rollbackService = context
               .getBean(RollbackService.class);
         rollbackService.rollback(cnxParameter, idTraitement);

      } catch (IllegalArgumentException exception) {
         throw new IllegalArgumentException(
               "Identifiant du traitement de masse : format erroné");
      }
   }

   /**
    * Service de reindexation des métadonnées.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param args
    *           : argument passé en ligne de commande
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void reindexCategories(final DFCEConnection cnxParameter,
         final String[] args, final ApplicationContext context)
         throws ConnectionServiceEx {

      // appel du service de mise à jour des indexes
      final AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);

      LOGGER.info("Vérification des arguments passés en ligne de commande ");
      // Vérification des paramètres d'entrée
      if (!ValidateUtils.isNotBlank(args, 0)) {
         throw new IllegalArgumentException(
               "Aucune métadonnée n'a été spécifiée");
      }

      String metadataToIndex = args[0];

      boolean controleOk = controleListeMetaPourUpdateDocuments(metadataToIndex);
      if (controleOk) {
         LOGGER.debug("Appel du service d'indexation");
         adminDFCE.reindexCategories(cnxParameter, metadataToIndex);
      } else {
         LOGGER
               .error("Les métadonnées spécifiées ne respectent pas la syntaxe xxx;yy;zzzz");

         throw new AdminDfceRuntimeException(
               "Les métadonnées spécifiées ne respectent pas la syntaxe xxx;yy;zzzz");
      }
   }

   /**
    * Service de reindexation des métadonnées.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param args
    *           : argument passé en ligne de commande
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void reindexComposites(final DFCEConnection cnxParameter,
         final String[] args, final ApplicationContext context)
         throws ConnectionServiceEx {

      // appel du service de mise à jour des indexes
      final AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);

      LOGGER.info("Vérification des arguments passés en ligne de commande ");
      // Vérification des paramètres d'entrée
      if (!ValidateUtils.isNotBlank(args, 0)) {
         throw new IllegalArgumentException(
               "Aucune métadonnée n'a été spécifiée");
      }
      
      //-- Récupération du paramètre envoyé
      String indexesComposites = args[0];
      
      if(isValidListeIndexesComposites(indexesComposites)){
         LOGGER.debug("Appel du service d'indexation d'indexes composites");
         adminDFCE.reindexIdxComposites(cnxParameter, indexesComposites);
      } else {
         String mssgErreur = String.format(
               "Les indexes composites spécifiées '%s' ne respectent pas la syntaxe " +
         		"xxx&yy&zzzz&|aaa&bb&ccc&", indexesComposites);
         
         LOGGER.error(mssgErreur);
  
         throw new AdminDfceRuntimeException(mssgErreur);
      }
   }
   
   /**
    * On vérifie que la liste des indees composites est bien
    * au format 'meta1&meta2&|meta3&meta4&meta5&'
    * @param indexesComposites
    * 
    * @return true si la validation se passe bien false sinion
    */
   public Boolean isValidListeIndexesComposites(String indexesComposites){
      boolean result = Boolean.TRUE;
      LOGGER.debug("Vérification de la syntaxe des indexescomposites spécifiées");
      
      if(StringUtils.isEmpty(indexesComposites)) {
         return Boolean.FALSE;
      }
      
      String[] indexes = StringUtils.split(indexesComposites,
            ReindexMetaConstantes.SEPARATEUR_IDX_COMPOSITES);  
      
      for (String idx : indexes) {
         
         //-- l'indexe composite ne doit pas être vide
         if(StringUtils.isEmpty(idx)) {
            return Boolean.FALSE;
         }
         
         String[] metas = StringUtils.split(idx,
               ReindexMetaConstantes.SEPARATEUR_METAS_IDX_COMPOSITES);  
         
         //-- On test qu'il y'a au moins 2 métas
         // dans un indexe composite
         if(metas.length < 2) {
            return Boolean.FALSE;
         }
         
         //-- Validation des caractères utilisé
         int size = idx.length();
         for (int i = 0; i < size; i++) {
            if (!Character.isLetterOrDigit(idx.charAt(i))
                  && (idx.charAt(i) != '_') && (idx.charAt(i) != '&')) {
               return Boolean.FALSE;
            }
         }
         
         //-- Chaque indexe composite à créer doit se terminer par le caractère '&'
         if(idx.charAt(size-1) != '&'){
            return Boolean.FALSE;
         }
      }
      
      return result;
   }

   protected boolean controleListeMetaPourUpdateDocuments(String metadataToIndex) {

      LOGGER.debug("Vérification de la syntaxe des métadonnées spécifiées");

      // Les métadonnées doivent être sous la forme meta1;meta2;meta3
      // On doit donc avoir une chaîne contenant uniquement des caractères
      // alphanumériques, ou le séparateur de métadonnées.

      boolean result;
      if (StringUtils.isBlank(metadataToIndex)) {
         result = Boolean.FALSE;
      } else {

         result = Boolean.TRUE;

         String[] metas = StringUtils.split(metadataToIndex,
               ReindexMetaConstantes.SEPARATEUR_METAS);

         for (String meta : metas) {
            int size = meta.length();
            for (int i = 0; i < size; i++) {
               if (!Character.isLetterOrDigit(meta.charAt(i))
                     && (meta.charAt(i) != '_')) {
                  result = Boolean.FALSE;
                  break;
               }
            }
            if (result == Boolean.FALSE) {
               break;
            }
         }
      }

      return result;

   }
   
   /**
    * Service de split d'un index en plage d'index.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param args
    *           : argument passé en ligne de commande
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void splitIndex(final DFCEConnection cnxParameter,
         final String[] args, final ApplicationContext context)
         throws ConnectionServiceEx {

      final AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);

      LOGGER.info("Vérification des arguments passés en ligne de commande ");
      // Vérification des paramètres d'entrée
      if (!ValidateUtils.isNotBlank(args, 1)) {
         throw new IllegalArgumentException(
               "Le nom de l'index n'est pas renseigné.");
      }
      if (!ValidateUtils.isNotBlank(args, 1)) {
         throw new IllegalArgumentException(
               "Les paramètres additionnels du job de split ne sont pas renseignés.");
      }

      // -- Récupération du paramètre envoyé
      String indexName = args[0];
      String additionalsParams = args[1];

      LOGGER.debug("Appel du service de split d'index");
      adminDFCE.splitIndex(cnxParameter, indexName, additionalsParams);
   }

   /**
    * Service de merge de plage d'index.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param args
    *           : argument passé en ligne de commande
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void mergeIndex(final DFCEConnection cnxParameter,
         final String[] args, final ApplicationContext context)
         throws ConnectionServiceEx {

      final AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);

      LOGGER.info("Vérification des arguments passés en ligne de commande ");
      // Vérification des paramètres d'entrée
      if (!ValidateUtils.isNotBlank(args, 1)) {
         throw new IllegalArgumentException(
               "Le nom de l'index n'est pas renseigné.");
      }
      if (!ValidateUtils.isNotBlank(args, 1)) {
         throw new IllegalArgumentException(
               "Les paramètres additionnels du job de split ne sont pas renseignés.");
      }

      // -- Récupération du paramètre envoyé
      String indexName = args[0];
      String additionalsParams = args[1];

      LOGGER.debug("Appel du service de merge d'index");
      adminDFCE.mergeIndex(cnxParameter, indexName, additionalsParams);
   }
   
   /**
    * Service de controle de la taille des index.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param args
    *           : argument passé en ligne de commande
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void getIndexesOverLimit(final DFCEConnection cnxParameter,
         final String[] args, final ApplicationContext context)
         throws ConnectionServiceEx {

      final AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);
      
      LOGGER.info("Vérification des arguments passés en ligne de commande ");
      // Vérification des paramètres d'entrée
      if (!ValidateUtils.isNotBlank(args, 0) || !StringUtils.isNumeric(args[0])) {
         throw new IllegalArgumentException(
               "la taille maximal des index doit être renseigné.");
      }
      Integer limit = Integer.parseInt(args[0]);

      LOGGER.debug("Appel du service de controle de la taille des index");
      adminDFCE.getIndexesOverLimit(cnxParameter, limit);
   }
   
   /**
    * Service de consultation de la taille des indexes.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param args
    *           : argument passé en ligne de commande
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void getIndexesSize(final DFCEConnection cnxParameter,
         final String[] args, final ApplicationContext context)
         throws ConnectionServiceEx {

      final AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);
      
      LOGGER.debug("Appel du service de consultation de la taille des index");
      adminDFCE.getIndexesSize(cnxParameter);
   }
}
