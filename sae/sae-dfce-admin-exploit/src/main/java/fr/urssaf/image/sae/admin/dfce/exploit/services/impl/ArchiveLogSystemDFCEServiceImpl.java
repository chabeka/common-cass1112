package fr.urssaf.image.sae.admin.dfce.exploit.services.impl;

import java.util.Date;
import java.util.UUID;

import net.docubase.toolkit.service.ged.ArchiveService;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import com.docubase.dfce.exception.IllegalEventsPurgeException;

import fr.urssaf.image.sae.admin.dfce.exploit.exception.AdminDfceRuntimeException;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.ArchiveLogsRunningEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.ConnectionServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.PurgeSystemEventsException;
import fr.urssaf.image.sae.admin.dfce.exploit.messages.ResourceMessagesUtils;
import fr.urssaf.image.sae.admin.dfce.exploit.model.ConnectionParameter;
import fr.urssaf.image.sae.admin.dfce.exploit.services.AbstractService;
import fr.urssaf.image.sae.admin.dfce.exploit.services.ArchiveLogSystemDFCEService;
import fr.urssaf.image.sae.admin.dfce.exploit.utils.Utils;

/**
 * Implémente l'interface : {@link ArchiveLogSystemDFCEService}
 * <ul>
 * <li>Service de création du journal d'événement de type <b>System</b></li>
 * <li>Service de purge des journaux de type <b>System</b></li>
 * <li>Service de consultation du fichier d'archivage de type <b>System</b></li>
 * </ul>
 * 
 */
@Service
@Qualifier("archiveLogSystemDFCEService")
public class ArchiveLogSystemDFCEServiceImpl 
   extends AbstractService implements ArchiveLogSystemDFCEService {

   private static final Logger LOGGER = LoggerFactory
         .getLogger(ArchiveLogSystemDFCEServiceImpl.class);

   /**
    * Service de journalisation DFCE.
    * La classe ne devrait communiquer qu'avec ce service
    * et non pas avec {@link net.docubase.toolkit.service.ServiceProvider}. 
    */
   private ArchiveService archiveService;
   
   /**
    * Rend la classe testable en limitant la violation 
    * de la loi de Déméter à cette méthode.
    */
   private void ensureArchiveService() {
      if (this.archiveService == null) {
         LOGGER.debug("Instanciation du service de journalisation DFCE");
         this.archiveService = getServiceProvider().getArchiveService();
      }
      assert this.archiveService != null;
   }

   /**
    * {@inheritDoc} 
    * <p>
    * La redéfinition de cette méthode permet de s'affranchir 
    * de la conception d'origine qui viole la loi de Déméter.
    * </p>
    */
   @Override
   protected void buildAndOpenSAEConnexion(final ConnectionParameter connParams) 
      throws ConnectionServiceEx {
      super.buildAndOpenSAEConnexion(connParams);
      this.ensureArchiveService();
   }

   @Override
   public void createSystemEventLogs(ConnectionParameter connParams, int days) 
   throws ConnectionServiceEx, ArchiveLogsRunningEx {
      try {
         assert connParams != null;
         buildAndOpenSAEConnexion(connParams);
         checkSystemLogNotRunning(connParams);
         
         /**
          * Lancement du job de journalisation DFCE : 
          * si une durée est spécifiée on la retranche de la
          * date du jour avant de lancer la production de journal.
          */
         if (days == -1) {
            logBeforeArchiveJob(connParams, days, null);
            archiveService.createNextSystemLogsArchive();
         } else {
            Date endDay = Utils.dateFromDeltaInDays(days);
            logBeforeArchiveJob(connParams, days, endDay);
            archiveService.createNextSystemLogsArchiveToDate(endDay);
         }
         logAfterArchiveJob(connParams);
      } finally {
         closeSAEConnection();
      }
   }

   @Override
   public void purgeSystemEvents(final ConnectionParameter connParams, int days)
         throws ConnectionServiceEx, PurgeSystemEventsException {
      try {
         assert connParams != null;
         assert days > 0;
         
         Date endDate = Utils.dateFromDeltaInDays(days);
         logBeforePurgeJob(connParams, days, endDate);
         buildAndOpenSAEConnexion(connParams);
         // Lancement du job de purge DFCE
         archiveService.clearSystemEventsTo(endDate);
         logAfterPurgeJob(connParams);
      } catch (IllegalEventsPurgeException e) {
         throw new PurgeSystemEventsException(e);
      } finally {
         closeSAEConnection();
      }
   }

   @Override
   public final void extractSystemArchiveFile(
         final ConnectionParameter cnxParameter, final String filePath)
         throws ConnectionServiceEx, ArchiveLogsRunningEx {
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("consultArchiveDocument.start"), cnxParameter
               .getHost().getHostName());
         LOGGER.debug(ResourceMessagesUtils
               .loadMessage("consultArchiveDocument.filetpath"), filePath);
         final UUID docUuid = archiveService.getLastSystemLogsArchiveUUID();

         if (docUuid == null) {
            throw new AdminDfceRuntimeException(
                  "Aucun journal des événements actuellement disponible dans la base");
         }

         LOGGER
               .debug(
                     "UUID de la dernière création réussi de la journalisation de type System  {}",
                     docUuid);
         LOGGER
               .debug(
                     "Date de la dernière création réussi de la journalisation de type System {}",
                     Utils.dateToString(archiveService.getLastSucessfulSystemLogsArchiveRunDate()));
         buildArchiveLogFile(filePath, docUuid);
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("consultArchiveDocument.end"), cnxParameter
               .getHost().getHostName());
      } finally {
         closeSAEConnection();
      }
   }

   /**
    * Lève une exception si le job DFCE de journalisation des évènements 
    * du système est déjà lancé.
    * 
    * @param connParams
    * @throws ArchiveLogsRunningEx si le job de journalisation est déjà lancé.
    */
   private void checkSystemLogNotRunning(ConnectionParameter connParams)
         throws ArchiveLogsRunningEx {
      if (archiveService.isSystemLogsArchiveRunning()) {
         throw new ArchiveLogsRunningEx(ResourceMessagesUtils.loadMessage(
               "systemEventLogs.error", connParams.getHost().getHostName()));
      }
   }   
   
   /**
    * Informations à logger avant la journalisation des évènements du système.
    * 
    * @param connParams paramètres de connexion à DFCE.
    * @param days nombre de jours à retrancher à la date actuelle.
    * @param computedDate date calculée à partir du paramètre <code>days</code>.
    */
   private void logBeforeArchiveJob(ConnectionParameter connParams, int days, Date computedDate) {

      LOGGER.info(ResourceMessagesUtils.loadMessage("systemEventLogs.start"),
            connParams.getHost().getHostName());

      LOGGER.debug(ResourceMessagesUtils.loadMessage("systemEventLogs.days"),
            days);

      if (computedDate != null) {
         LOGGER.debug(ResourceMessagesUtils.loadMessage("systemEventLogs.date"),
               Utils.dateToString(computedDate));
      }
   }

   /**
    * Informations à logger après la journalisation des évènements du système.
    * 
    * @param connParams paramètres de connexion à DFCE.
    */
   private void logAfterArchiveJob(ConnectionParameter connParams) {
      LOGGER.info(ResourceMessagesUtils.loadMessage("systemEventLogs.end"),
            connParams.getHost().getHostName());
      
      if (archiveService.isSystemLogsArchiveRunning()) {
         LOGGER.warn("Le job SystemLogsArchive est à l'état running");
      }
      LOGGER.debug("UUID du dernier journal système {}",
            archiveService.getLastSystemLogsArchiveUUID());
      LOGGER.debug("Date de création du dernier journal système {}", 
            Utils.dateToString(archiveService.getLastSucessfulSystemLogsArchiveRunDate()));
   }
   
   /**
    * Informations à logger avant la purge des évènements du système.
    * 
    * @param connParams paramètres de connexion à DFCE.
    * @param days nombre de jours à retrancher à la date actuelle.
    * @param computedDate date calculée à partir du paramètre <code>days</code>.
    */
   private void logBeforePurgeJob(ConnectionParameter connParams, int days, Date computedDate) {
      LOGGER.info(ResourceMessagesUtils.loadMessage("purgeSystemEvents.start"),
            connParams.getHost().getHostName());
      LOGGER.debug(
            ResourceMessagesUtils.loadMessage("purgeEvents.archiveDuration"),
            days);
      LOGGER.debug(ResourceMessagesUtils.loadMessage("purgeSystemEvents.date"),
            Utils.dateToString(computedDate));
   }
   
   /**
    * Informations à logger après la purge des évènements du système.
    * 
    * @param connParams paramètres de connexion à DFCE.
    */
   private void logAfterPurgeJob(ConnectionParameter connParams) {
      LOGGER.info(
            ResourceMessagesUtils.loadMessage("purgeSystemEvents.end"),
            connParams.getHost().getHostName());
   }

   /**
    * @return Service de journalisation DFCE
    */
   public ArchiveService getArchiveService() {
      return this.archiveService;
   }

   /**
    * Définit le service de journalisation.<br />
    * Rend la classe testable.
    * 
    * @param archiveService Service de journalisation DFCE ou mock/fake
    */
   public void setArchiveService(ArchiveService archiveService) {
      this.archiveService = archiveService;
   }
}
