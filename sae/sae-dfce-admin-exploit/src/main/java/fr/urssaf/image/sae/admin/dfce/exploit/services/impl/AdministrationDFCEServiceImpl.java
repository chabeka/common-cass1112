package fr.urssaf.image.sae.admin.dfce.exploit.services.impl;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.List;

import net.docubase.toolkit.model.ToolkitFactory;
import net.docubase.toolkit.model.base.Base;
import net.docubase.toolkit.model.base.BaseCategory;
import net.docubase.toolkit.model.reference.LifeCycleLengthUnit;
import net.docubase.toolkit.model.reference.LifeCycleRule;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.Validate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.core.JobExecutionException;
import org.springframework.batch.core.JobParametersInvalidException;
import org.springframework.batch.core.UnexpectedJobExecutionException;
import org.springframework.batch.core.launch.JobInstanceAlreadyExistsException;
import org.springframework.batch.core.launch.NoSuchJobException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import com.docubase.dfce.commons.jobs.JobUtils;
import com.docubase.dfce.exception.ObjectAlreadyExistsException;
import com.thoughtworks.xstream.mapper.CannotResolveClassException;

import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.sae.admin.dfce.exploit.constantes.ReindexMetaConstantes;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.AdminDfceRuntimeException;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.BaseAdministrationServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.ConnectionServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.messages.ResourceMessagesUtils;
import fr.urssaf.image.sae.admin.dfce.exploit.model.DataBaseModel;
import fr.urssaf.image.sae.admin.dfce.exploit.model.DocumentType;
import fr.urssaf.image.sae.admin.dfce.exploit.model.DocumentsType;
import fr.urssaf.image.sae.admin.dfce.exploit.services.AbstractService;
import fr.urssaf.image.sae.admin.dfce.exploit.services.AdministrationDFCEService;
import fr.urssaf.image.sae.admin.dfce.exploit.utils.BaseUtils;
import fr.urssaf.image.sae.admin.dfce.exploit.utils.Utils;
import fr.urssaf.image.sae.admin.dfce.exploit.xml.XmlDataService;

/**
 * Implémente l'interface : {@link AdministrationDFCEService}
 * <ul>
 * <li>Service de mise à jour des indexes.</li>
 * <li>Service de création de la base SAE et des catégories(Life cycle).</li>
 * </ul>
 * 
 */
@Service
@Qualifier("administrationDfceService")
public class AdministrationDFCEServiceImpl extends AbstractService implements
      AdministrationDFCEService {
   private static final String DATABASE_EXISTS = "database.already.exists";
   private static final Logger LOGGER = LoggerFactory
         .getLogger(AdministrationDFCEServiceImpl.class);
   @Autowired
   private XmlDataService xmlDBModelService;

   /**
    * 
    * @param xmlDBModelService
    *           : Le service de gestion du fichier xml
    */
   public final void setXmlDBModelService(final XmlDataService xmlDBModelService) {
      this.xmlDBModelService = xmlDBModelService;
   }

   /**
    * 
    * @return Le service de gestion du fichier xml
    */
   public final XmlDataService getXmlDBModelService() {
      return xmlDBModelService;
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final void updateIndexes(final DFCEConnection cnxParameter)
         throws ConnectionServiceEx {
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         LOGGER.info(ResourceMessagesUtils.loadMessage("update.start"),
               cnxParameter.getHostName());

         try {

            getServiceProvider().getJobAdministrationService()
                  .startNextInstance(JobUtils.INDEX_COUNTER_JOB);

         } catch (JobExecutionException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (UnexpectedJobExecutionException e) {
            throw new AdminDfceRuntimeException(e);
         }

         LOGGER.info(ResourceMessagesUtils.loadMessage("update.end"),
               cnxParameter.getHostName());

      } finally {
         closeSAEConnection();
      }
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final String createSAEBase(final DFCEConnection cnxParameter,
         final File xmlDataBaseModel, final File xmlDocumentsType)
         throws BaseAdministrationServiceEx, ConnectionServiceEx {
      String baseId = null;
      DataBaseModel dataBaseModel = null;
      DocumentsType documentsType = null;
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         // Vérification du contenu du fichier
         Validate.notNull(xmlDataBaseModel, ResourceMessagesUtils
               .loadMessage("xmlDataBaseModel.required"));
         Validate.notNull(xmlDocumentsType, ResourceMessagesUtils
               .loadMessage("xmlDocumentsType.required"));
         // Lecture du fichier correspondent à la structure de base de données
         LOGGER.debug("Chemin de la structure de la base SAE ({})",
               xmlDataBaseModel.getAbsoluteFile());
         LOGGER
               .debug(
                     "Début du chargement et traitement du fichier mod\u00E8le de la base de donn\u00E9es SAE {}",
                     xmlDataBaseModel.getName());
         try {
            dataBaseModel = xmlDBModelService.baseModelReader(xmlDataBaseModel);
            baseId = dataBaseModel.getBase().getBaseId();
         } catch (CannotResolveClassException except) {

            throw new BaseAdministrationServiceEx(
                  "Le contenu du  fichier ("
                        + xmlDataBaseModel.getAbsoluteFile()
                        + ")  ne correspond pas au mod\u00E8le de la base de donn\u00E9es SAE",
                  except);
         } catch (FileNotFoundException e) {
            throw new BaseAdministrationServiceEx(e);
         }
         LOGGER
               .debug(
                     "Fin du chargement et traitement du fichier mod\u00E8le de la base de donn\u00E9es SAE ({})",
                     xmlDataBaseModel.getName());

         LOGGER.debug("Chemin du fichier cycle de vie des documents SAE ({})",
               xmlDocumentsType.getAbsoluteFile());
         LOGGER
               .debug(
                     "Début du chargement et traitement du fichier cycle de vie des documents SAE ({})",
                     xmlDocumentsType.getName());
         try {
            documentsType = xmlDBModelService
                  .documentsTypeReader(xmlDocumentsType);
         } catch (CannotResolveClassException except) {

            throw new BaseAdministrationServiceEx("Le contenu du fichier ("
                  + xmlDocumentsType.getAbsoluteFile()
                  + ") ne correspond pas au cycle de vie des documents SAE",
                  except);
         } catch (FileNotFoundException e) {
            throw new BaseAdministrationServiceEx(e);
         }
         LOGGER
               .debug(
                     "Fin du chargement et traitement du fichier cycle de vie des documents SAE ({})",
                     xmlDocumentsType.getName());
         LOGGER
               .info(
                     "Début de la création de la base SAE. Identifiant de la base: ({})",
                     baseId);
         final ToolkitFactory toolkitFactory = ToolkitFactory.getInstance();
         LOGGER.info(ResourceMessagesUtils.loadMessage(
               "database.initialization", dataBaseModel.toString()));
         // Instantiation d'une base
         Base base = getServiceProvider().getBaseAdministrationService()
               .getBase(baseId);
         LOGGER.debug(
               "Début de v\u00E9rification de l'exsitance de la base {}",
               baseId);
         if (base == null) {
            base = toolkitFactory.createBase(baseId);
         } else {
            LOGGER.warn(ResourceMessagesUtils.loadMessage(DATABASE_EXISTS,
                  baseId));
            throw new BaseAdministrationServiceEx(ResourceMessagesUtils
                  .loadMessage(DATABASE_EXISTS, baseId));
         }
         LOGGER.debug(
               "Fin de v\u00E9rification de l'exsitance de la base ({})",
               baseId);

         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.initialization.technical.metadatas"));
         // Définition des propriétes de la base
         BaseUtils.initBaseProperties(base, dataBaseModel);
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.initialization.base.categories"));
         // Création des baseCatégories
         final List<BaseCategory> baseCategories = BaseUtils
               .initBaseCategories(dataBaseModel, getServiceProvider());
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.base.categories.creation"));
         for (BaseCategory baseCategory : Utils
               .nullSafeIterable(baseCategories)) {
            base.addBaseCategory(baseCategory);
         }
         LOGGER.info(ResourceMessagesUtils.loadMessage("database.creation",
               baseId));
         // Création de la base
         getServiceProvider().getBaseAdministrationService().createBase(base);
         LOGGER.debug("Début Création des indexes composites");
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.index.composite.creation"));
         // Création des indexes composites
         BaseUtils.createIndexComposite(dataBaseModel, getServiceProvider());
         LOGGER.debug("Fin Création des indexes composites");
         // on démarre la base
         getServiceProvider().getBaseAdministrationService().startBase(base);
         // Alimentation de la colonne famille LifeCycleRule
         LOGGER
               .debug("Début d'alimentation de la colonne famille LifeCycleRule");
         createDocumentsType(documentsType);
         LOGGER.debug("Fin d'alimentation de la colonne famille LifeCycleRule");
         LOGGER
               .info(
                     "Fin de la création de la base SAE. Identifiant de la base: ({})",
                     baseId);
         return base.getBaseId();
      } catch (ObjectAlreadyExistsException objAlreadyExistsEx) {

         throw new BaseAdministrationServiceEx(ResourceMessagesUtils
               .loadMessage(DATABASE_EXISTS, baseId), objAlreadyExistsEx);
      } finally {
         closeSAEConnection();
      }

   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final void updateLifeCycleRules(DFCEConnection cnxParameter,
         File xmlDocumentsType) throws BaseAdministrationServiceEx,
         ConnectionServiceEx {

      buildAndOpenSAEConnexion(cnxParameter);

      Validate.notNull(xmlDocumentsType, ResourceMessagesUtils
            .loadMessage("xmlDocumentsType.required"));

      DocumentsType documentsType = null;

      try {
         documentsType = xmlDBModelService
               .documentsTypeReader(xmlDocumentsType);
         LOGGER
               .debug("Début d'alimentation de la colonne famille LifeCycleRule");
         updateDocumentType(documentsType);
         LOGGER.debug("Fin d'alimentation de la colonne famille LifeCycleRule");

      } catch (CannotResolveClassException except) {

         throw new BaseAdministrationServiceEx("Le contenu du fichier ("
               + xmlDocumentsType.getAbsoluteFile()
               + ") ne correspond pas au cycle de vie des documents SAE",
               except);
      } catch (FileNotFoundException e) {
         throw new BaseAdministrationServiceEx(e);
      } finally {
         closeSAEConnection();
      }

   }

   /**
    * Service permettant de mettre à jour le cycle de vie d'un document.
    * 
    * @param documentsType
    *           : Le service de désérialisation des flux xml
    * @throws FileNotFoundException
    *            Lorsque le fichier n'existe pas
    * @throws ConnectionServiceEx
    *            Lorsqu'un problème survient lors de la connexion.
    */
   private void updateDocumentType(final DocumentsType documentsType)
         throws FileNotFoundException {

      LOGGER.info(ResourceMessagesUtils
            .loadMessage("lifeCycleRule.initialization"));
      LOGGER.info(ResourceMessagesUtils.loadMessage("lifeCycleRule.create"));

      for (DocumentType typeDocument : Utils.nullSafeIterable(documentsType
            .getListDocumentsType())) {

         try {

            LifeCycleRule lifeCycleRule = getServiceProvider()
                  .getStorageAdministrationService().getLifeCycleRule(
                        typeDocument.getRndCode());

            if (lifeCycleRule == null) {

               LOGGER.info(ResourceMessagesUtils.loadMessage(
                     "lifeCycleRule.document", typeDocument.getRndCode()));
               getServiceProvider().getStorageAdministrationService()
                     .createNewLifeCycleRule(typeDocument.getRndCode(),
                           typeDocument.getStorageDuration(),
                           LifeCycleLengthUnit.DAY);
            } else {
               LOGGER.warn(ResourceMessagesUtils.loadMessage(
                     "lifeCycleRule.already.exist", typeDocument.getRndCode()));
               // FIXME MAJ de la valeur ?
            }
         } catch (ObjectAlreadyExistsException objectExist) {
            LOGGER.warn(ResourceMessagesUtils.loadMessage(
                  "lifeCycleRule.already.exist", typeDocument.getRndCode()));
         }
      }
   }

   /**
    * Service permettant de créer le cycle de vie d'un document.
    * 
    * @param documentsType
    *           : Le service de désérialisation des flux xml
    * @throws ConnectionServiceEx
    *            Lorsqu'un problème survient lors de la connexion.
    */
   private void createDocumentsType(final DocumentsType documentsType) {

      LOGGER.info(ResourceMessagesUtils
            .loadMessage("lifeCycleRule.initialization"));
      LOGGER.info(ResourceMessagesUtils.loadMessage("lifeCycleRule.create"));

      for (DocumentType typeDocument : Utils.nullSafeIterable(documentsType
            .getListDocumentsType())) {
         try {
            LOGGER.info(ResourceMessagesUtils.loadMessage(
                  "lifeCycleRule.document", typeDocument.getRndCode()));
            getServiceProvider().getStorageAdministrationService()
                  .createNewLifeCycleRule(typeDocument.getRndCode(),
                        typeDocument.getStorageDuration(),
                        LifeCycleLengthUnit.DAY);
         } catch (ObjectAlreadyExistsException objectExist) {
            LOGGER.warn(ResourceMessagesUtils.loadMessage(
                  "lifeCycleRule.already.exist", typeDocument.getRndCode()));
         }
      }
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public void reindexCategories(DFCEConnection cnxParameter, String categories)
         throws ConnectionServiceEx {

      buildAndOpenSAEConnexion(cnxParameter);
      LOGGER.info(ResourceMessagesUtils.loadMessage("update.start"),
            cnxParameter.getHostName());

      // Split des métadonnées selon le caractère séparateur utilisé dans la
      // ligne de commande
      String[] listeMetas = StringUtils.split(categories,
            ReindexMetaConstantes.SEPARATEUR_METAS);
      LOGGER.info("Métadonnée(s) sur lesquelles réindexer les documents: {}",
            StringUtils.join(listeMetas, ' '));

      // Construction des paramètres du job DFCE dans le format attendu
      String listeMetasPourJobDfce = StringUtils.join(listeMetas, '|');
      String parametresJobDfce = String.format(
            "category.names=%s,timestamp=%s", listeMetasPourJobDfce, System
                  .currentTimeMillis());
      LOGGER.info("Appel du job DFCE {} avec les paramètres {}",
            JobUtils.INDEX_CATEGORIES_JOB, parametresJobDfce);

      try {
         getServiceProvider().getJobAdministrationService().start(
               JobUtils.INDEX_CATEGORIES_JOB, parametresJobDfce);

      } catch (NoSuchJobException e) {

         throw new AdminDfceRuntimeException(e);

      } catch (UnexpectedJobExecutionException e) {

         throw new AdminDfceRuntimeException(e);

      } catch (JobParametersInvalidException e) {

         throw new AdminDfceRuntimeException(e);

      } catch (JobInstanceAlreadyExistsException e) {

         throw new AdminDfceRuntimeException(e);
      }
      LOGGER.info(ResourceMessagesUtils.loadMessage("update.end"), cnxParameter
            .getHostName());
   }
}
