package fr.urssaf.image.sae.admin.dfce.exploit.services.impl;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.List;

import net.docubase.toolkit.model.ToolkitFactory;
import net.docubase.toolkit.model.base.Base;
import net.docubase.toolkit.model.base.BaseCategory;
import net.docubase.toolkit.model.index.IndexInformation;
import net.docubase.toolkit.model.index.RangeIndexInformation;
import net.docubase.toolkit.model.reference.LifeCycleLengthUnit;
import net.docubase.toolkit.model.reference.LifeCycleRule;
import net.docubase.toolkit.model.reference.LifeCycleStep;
import net.docubase.toolkit.service.administration.JobAdministrationService;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.Validate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import com.docubase.dfce.commons.LifeCycleEndAction;
import com.docubase.dfce.commons.jobs.JobUtils;
import com.docubase.dfce.exception.ObjectAlreadyExistsException;
import com.docubase.dfce.exception.batch.DfceJobParametersInvalidException;
import com.docubase.dfce.exception.batch.UnexpectedDfceJobExecutionException;
import com.docubase.dfce.exception.batch.launch.DfceJobInstanceAlreadyExistsException;
import com.docubase.dfce.exception.batch.launch.DfceJobParametersNotFoundException;
import com.docubase.dfce.exception.batch.launch.NoSuchDfceJobException;
import com.docubase.dfce.exception.batch.repository.DfceJobExecutionAlreadyRunningException;
import com.docubase.dfce.exception.batch.repository.DfceJobInstanceAlreadyCompleteException;
import com.docubase.dfce.exception.batch.repository.DfceJobRestartException;
import com.thoughtworks.xstream.mapper.CannotResolveClassException;

import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.sae.admin.dfce.exploit.constantes.ReindexMetaConstantes;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.AdminDfceRuntimeException;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.BaseAdministrationServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.ConnectionServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.messages.ResourceMessagesUtils;
import fr.urssaf.image.sae.admin.dfce.exploit.model.DataBaseModel;
import fr.urssaf.image.sae.admin.dfce.exploit.model.DocumentType;
import fr.urssaf.image.sae.admin.dfce.exploit.model.DocumentsType;
import fr.urssaf.image.sae.admin.dfce.exploit.services.AbstractService;
import fr.urssaf.image.sae.admin.dfce.exploit.services.AdministrationDFCEService;
import fr.urssaf.image.sae.admin.dfce.exploit.utils.BaseUtils;
import fr.urssaf.image.sae.admin.dfce.exploit.utils.Utils;
import fr.urssaf.image.sae.admin.dfce.exploit.xml.XmlDataService;

/**
 * Implémente l'interface : {@link AdministrationDFCEService}
 * <ul>
 * <li>Service de mise à jour des indexes.</li>
 * <li>Service de création de la base SAE et des catégories(Life cycle).</li>
 * </ul>
 * 
 */
@Service
@Qualifier("administrationDfceService")
public class AdministrationDFCEServiceImpl extends AbstractService implements
      AdministrationDFCEService {
   private static final String DATABASE_EXISTS = "database.already.exists";
   private static final Logger LOGGER = LoggerFactory
         .getLogger(AdministrationDFCEServiceImpl.class);
   @Autowired
   private XmlDataService xmlDBModelService;

   /**
    * 
    * @param xmlDBModelService
    *           : Le service de gestion du fichier xml
    */
   public final void setXmlDBModelService(final XmlDataService xmlDBModelService) {
      this.xmlDBModelService = xmlDBModelService;
   }

   /**
    * 
    * @return Le service de gestion du fichier xml
    */
   public final XmlDataService getXmlDBModelService() {
      return xmlDBModelService;
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final void updateIndexes(final DFCEConnection cnxParameter)
         throws ConnectionServiceEx {
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         LOGGER.info(ResourceMessagesUtils.loadMessage("update.start"),
               cnxParameter.getHostName());

         try {

            getServiceProvider().getJobAdministrationService()
                  .startNextInstance(JobUtils.INDEX_COUNTER_JOB);

         } catch (NoSuchDfceJobException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobParametersNotFoundException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobRestartException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobExecutionAlreadyRunningException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobInstanceAlreadyCompleteException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobParametersInvalidException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (UnexpectedDfceJobExecutionException e) {
            throw new AdminDfceRuntimeException(e);
         }

         LOGGER.info(ResourceMessagesUtils.loadMessage("update.end"),
               cnxParameter.getHostName());

      } finally {
         closeSAEConnection();
      }
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final String createSAEBase(final DFCEConnection cnxParameter,
         final File xmlDataBaseModel, final File xmlDocumentsType)
         throws BaseAdministrationServiceEx, ConnectionServiceEx {
      String baseId = null;
      DataBaseModel dataBaseModel = null;
      DocumentsType documentsType = null;
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         // Vérification du contenu du fichier
         Validate.notNull(xmlDataBaseModel, ResourceMessagesUtils
               .loadMessage("xmlDataBaseModel.required"));
         Validate.notNull(xmlDocumentsType, ResourceMessagesUtils
               .loadMessage("xmlDocumentsType.required"));
         // Lecture du fichier correspondent à la structure de base de données
         LOGGER.debug("Chemin de la structure de la base SAE ({})",
               xmlDataBaseModel.getAbsoluteFile());
         LOGGER
               .debug(
                     "Début du chargement et traitement du fichier mod\u00E8le de la base de donn\u00E9es SAE {}",
                     xmlDataBaseModel.getName());
         try {
            dataBaseModel = xmlDBModelService.baseModelReader(xmlDataBaseModel);
            baseId = dataBaseModel.getBase().getBaseId();
         } catch (CannotResolveClassException except) {

            throw new BaseAdministrationServiceEx(
                  "Le contenu du  fichier ("
                        + xmlDataBaseModel.getAbsoluteFile()
                        + ")  ne correspond pas au mod\u00E8le de la base de donn\u00E9es SAE",
                  except);
         } catch (FileNotFoundException e) {
            throw new BaseAdministrationServiceEx(e);
         }
         LOGGER
               .debug(
                     "Fin du chargement et traitement du fichier mod\u00E8le de la base de donn\u00E9es SAE ({})",
                     xmlDataBaseModel.getName());

         LOGGER.debug("Chemin du fichier cycle de vie des documents SAE ({})",
               xmlDocumentsType.getAbsoluteFile());
         LOGGER
               .debug(
                     "Début du chargement et traitement du fichier cycle de vie des documents SAE ({})",
                     xmlDocumentsType.getName());
         try {
            documentsType = xmlDBModelService
                  .documentsTypeReader(xmlDocumentsType);
         } catch (CannotResolveClassException except) {

            throw new BaseAdministrationServiceEx("Le contenu du fichier ("
                  + xmlDocumentsType.getAbsoluteFile()
                  + ") ne correspond pas au cycle de vie des documents SAE",
                  except);
         } catch (FileNotFoundException e) {
            throw new BaseAdministrationServiceEx(e);
         }
         LOGGER
               .debug(
                     "Fin du chargement et traitement du fichier cycle de vie des documents SAE ({})",
                     xmlDocumentsType.getName());
         LOGGER
               .info(
                     "Début de la création de la base SAE. Identifiant de la base: ({})",
                     baseId);
         final ToolkitFactory toolkitFactory = ToolkitFactory.getInstance();
         LOGGER.info(ResourceMessagesUtils.loadMessage(
               "database.initialization", dataBaseModel.toString()));
         // Instantiation d'une base
         Base base = getServiceProvider().getBaseAdministrationService()
               .getBase(baseId);
         LOGGER.debug(
               "Début de v\u00E9rification de l'exsitance de la base {}",
               baseId);
         if (base == null) {
            base = toolkitFactory.createBase(baseId);
         } else {
            LOGGER.warn(ResourceMessagesUtils.loadMessage(DATABASE_EXISTS,
                  baseId));
            throw new BaseAdministrationServiceEx(ResourceMessagesUtils
                  .loadMessage(DATABASE_EXISTS, baseId));
         }
         LOGGER.debug(
               "Fin de v\u00E9rification de l'exsitance de la base ({})",
               baseId);

         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.initialization.technical.metadatas"));
         // Définition des propriétes de la base
         BaseUtils.initBaseProperties(base, dataBaseModel);
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.initialization.base.categories"));
         // Création des baseCatégories
         final List<BaseCategory> baseCategories = BaseUtils
               .initBaseCategories(dataBaseModel, getServiceProvider());
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.base.categories.creation"));
         for (BaseCategory baseCategory : Utils
               .nullSafeIterable(baseCategories)) {
            base.addBaseCategory(baseCategory);
         }
         LOGGER.info(ResourceMessagesUtils.loadMessage("database.creation",
               baseId));
         // Création de la base
         getServiceProvider().getBaseAdministrationService().createBase(base);
         LOGGER.debug("Début Création des indexes composites");
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.index.composite.creation"));
         // Création des indexes composites
         BaseUtils.createIndexComposite(dataBaseModel, getServiceProvider());
         LOGGER.debug("Fin Création des indexes composites");
         // on démarre la base
         getServiceProvider().getBaseAdministrationService().startBase(base);
         // Alimentation de la colonne famille LifeCycleRule
         LOGGER
               .debug("Début d'alimentation de la colonne famille LifeCycleRule");
         createDocumentsType(documentsType);
         LOGGER.debug("Fin d'alimentation de la colonne famille LifeCycleRule");
         LOGGER
               .info(
                     "Fin de la création de la base SAE. Identifiant de la base: ({})",
                     baseId);
         return base.getBaseId();
      } catch (ObjectAlreadyExistsException objAlreadyExistsEx) {

         throw new BaseAdministrationServiceEx(ResourceMessagesUtils
               .loadMessage(DATABASE_EXISTS, baseId), objAlreadyExistsEx);
      } finally {
         closeSAEConnection();
      }

   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final void updateLifeCycleRules(DFCEConnection cnxParameter,
         File xmlDocumentsType) throws BaseAdministrationServiceEx,
         ConnectionServiceEx {

      buildAndOpenSAEConnexion(cnxParameter);

      Validate.notNull(xmlDocumentsType, ResourceMessagesUtils
            .loadMessage("xmlDocumentsType.required"));

      DocumentsType documentsType = null;

      try {
         documentsType = xmlDBModelService
               .documentsTypeReader(xmlDocumentsType);
         LOGGER
               .debug("Début d'alimentation de la colonne famille LifeCycleRule");
         updateDocumentType(documentsType);
         LOGGER.debug("Fin d'alimentation de la colonne famille LifeCycleRule");

      } catch (CannotResolveClassException except) {

         throw new BaseAdministrationServiceEx("Le contenu du fichier ("
               + xmlDocumentsType.getAbsoluteFile()
               + ") ne correspond pas au cycle de vie des documents SAE",
               except);
      } catch (FileNotFoundException e) {
         throw new BaseAdministrationServiceEx(e);
      } finally {
         closeSAEConnection();
      }

   }

   /**
    * Service permettant de mettre à jour le cycle de vie d'un document.
    * 
    * @param documentsType
    *           : Le service de désérialisation des flux xml
    * @throws FileNotFoundException
    *            Lorsque le fichier n'existe pas
    * @throws ConnectionServiceEx
    *            Lorsqu'un problème survient lors de la connexion.
    */
   private void updateDocumentType(final DocumentsType documentsType)
         throws FileNotFoundException {

      LOGGER.info(ResourceMessagesUtils
            .loadMessage("lifeCycleRule.initialization"));
      LOGGER.info(ResourceMessagesUtils.loadMessage("lifeCycleRule.create"));

      for (DocumentType typeDocument : Utils.nullSafeIterable(documentsType
            .getListDocumentsType())) {

         try {

            LifeCycleRule lifeCycleRule = getServiceProvider()
                  .getStorageAdministrationService().getLifeCycleRule(
                        typeDocument.getRndCode());

            if (lifeCycleRule == null) {

               LOGGER.info(ResourceMessagesUtils.loadMessage(
                     "lifeCycleRule.document", typeDocument.getRndCode()));

               LifeCycleRule newLifeCycleRule = new LifeCycleRule();
               newLifeCycleRule.setDocumentType(typeDocument.getRndCode());
               // Depuis DFCe 1.7.0, le cycle de vie peut comporter des etapes
               // Coté Ged Nationale, nous n'en aurons qu'une seule
               LifeCycleStep etape = new LifeCycleStep();
               etape.setLength(typeDocument.getStorageDuration());
               etape.setUnit(LifeCycleLengthUnit.DAY);
               etape.setEndAction(LifeCycleEndAction.DELETE);
               newLifeCycleRule.addStep(etape);

               getServiceProvider().getStorageAdministrationService()
                     .createNewLifeCycleRule(newLifeCycleRule);
            } else {
               LOGGER.warn(ResourceMessagesUtils.loadMessage(
                     "lifeCycleRule.already.exist", typeDocument.getRndCode()));
               // FIXME MAJ de la valeur ?
            }
         } catch (ObjectAlreadyExistsException objectExist) {
            LOGGER.warn(ResourceMessagesUtils.loadMessage(
                  "lifeCycleRule.already.exist", typeDocument.getRndCode()));
         }
      }
   }

   /**
    * Service permettant de créer le cycle de vie d'un document.
    * 
    * @param documentsType
    *           : Le service de désérialisation des flux xml
    * @throws ConnectionServiceEx
    *            Lorsqu'un problème survient lors de la connexion.
    */
   private void createDocumentsType(final DocumentsType documentsType) {

      LOGGER.info(ResourceMessagesUtils
            .loadMessage("lifeCycleRule.initialization"));
      LOGGER.info(ResourceMessagesUtils.loadMessage("lifeCycleRule.create"));

      for (DocumentType typeDocument : Utils.nullSafeIterable(documentsType
            .getListDocumentsType())) {
         try {
            LOGGER.info(ResourceMessagesUtils.loadMessage(
                  "lifeCycleRule.document", typeDocument.getRndCode()));

            LifeCycleRule newLifeCycleRule = new LifeCycleRule();
            newLifeCycleRule.setDocumentType(typeDocument.getRndCode());
            // Depuis DFCe 1.7.0, le cycle de vie peut comporter des etapes
            // Coté Ged Nationale, nous n'en aurons qu'une seule
            LifeCycleStep etape = new LifeCycleStep();
            etape.setLength(typeDocument.getStorageDuration());
            etape.setUnit(LifeCycleLengthUnit.DAY);
            etape.setEndAction(LifeCycleEndAction.DELETE);
            newLifeCycleRule.addStep(etape);

            getServiceProvider().getStorageAdministrationService()
                  .createNewLifeCycleRule(newLifeCycleRule);
         } catch (ObjectAlreadyExistsException objectExist) {
            LOGGER.warn(ResourceMessagesUtils.loadMessage(
                  "lifeCycleRule.already.exist", typeDocument.getRndCode()));
         }
      }
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public void reindexCategories(DFCEConnection cnxParameter, String categories)
         throws ConnectionServiceEx {

      buildAndOpenSAEConnexion(cnxParameter);
      LOGGER.info(ResourceMessagesUtils.loadMessage("update.start"),
            cnxParameter.getHostName());

      // Split des métadonnées selon le caractère séparateur utilisé dans la
      // ligne de commande
      String[] listeMetas = StringUtils.split(categories,
            ReindexMetaConstantes.SEPARATEUR_METAS);
      LOGGER.info("Métadonnée(s) sur lesquelles réindexer les documents: {}",
            StringUtils.join(listeMetas, ' '));

      // Construction des paramètres du job DFCE dans le format attendu
      String listeMetasPourJobDfce = StringUtils.join(listeMetas, '|');
      String parametresJobDfce = String.format(
            "category.names=%s,timestamp=%s", listeMetasPourJobDfce, System
                  .currentTimeMillis());
      LOGGER.info("Appel du job DFCE {} avec les paramètres {}",
            JobUtils.INDEX_CATEGORIES_JOB, parametresJobDfce);

      try {
         getServiceProvider().getJobAdministrationService().start(
               JobUtils.INDEX_CATEGORIES_JOB, parametresJobDfce);

      } catch (NoSuchDfceJobException e) {
         throw new AdminDfceRuntimeException(e);
      } catch (DfceJobInstanceAlreadyExistsException e) {
         throw new AdminDfceRuntimeException(e);
      } catch (DfceJobParametersInvalidException e) {
         throw new AdminDfceRuntimeException(e);
      }
      LOGGER.info(ResourceMessagesUtils.loadMessage("update.end"), cnxParameter
            .getHostName());
   }

   @Override
   public void reindexIdxComposites(DFCEConnection cnxParameter, String indexes)
         throws ConnectionServiceEx {

      buildAndOpenSAEConnexion(cnxParameter);
      LOGGER.info(ResourceMessagesUtils.loadMessage("updateComposites.start"),
            cnxParameter.getHostName());

      String jobType = JobUtils.INDEX_COMPOSITES_JOB;
      String parametresJob = "composite.names=" + indexes;

      JobAdministrationService jobAdminService;
      jobAdminService = getServiceProvider().getJobAdministrationService();

      LOGGER.info("Appel du job DFCE {} avec les paramètres {}", jobType,
            parametresJob);

      Long idJob;
      try {
         // -- lancement de l'indexation
         idJob = jobAdminService.start(jobType, parametresJob);
         LOGGER.info("Job {} lancé, jobId={}", jobType, idJob);
      } catch (NoSuchDfceJobException e) {
         throw new AdminDfceRuntimeException(e);
      } catch (DfceJobInstanceAlreadyExistsException e) {
         throw new AdminDfceRuntimeException(e);
      } catch (DfceJobParametersInvalidException e) {
         throw new AdminDfceRuntimeException(e);
      }
      LOGGER.info(ResourceMessagesUtils.loadMessage("updateComposites.end"),
            cnxParameter.getHostName());
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public void updateDocsStats(DFCEConnection cnxParameter)
         throws ConnectionServiceEx {
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         LOGGER.info(
               ResourceMessagesUtils.loadMessage("updateDocsStats.start"),
               cnxParameter.getHostName());

         try {

            getServiceProvider().getJobAdministrationService()
                  .startNextInstance(JobUtils.PROCESS_DOC_STATISTICS_JOB);

         } catch (NoSuchDfceJobException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobParametersNotFoundException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobRestartException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobExecutionAlreadyRunningException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobInstanceAlreadyCompleteException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobParametersInvalidException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (UnexpectedDfceJobExecutionException e) {
            throw new AdminDfceRuntimeException(e);
         }

         LOGGER.info(ResourceMessagesUtils.loadMessage("updateDocsStats.end"),
               cnxParameter.getHostName());

      } finally {
         closeSAEConnection();
      }
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public void splitIndex(final DFCEConnection cnxParameter, String indexName,
         String additionalsParams) throws ConnectionServiceEx {
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         LOGGER.info(ResourceMessagesUtils.loadMessage("splitIndex.start"),
               cnxParameter.getHostName());
         
         String parametresJobDfce = String.format(
               "index.name=%s,base.id=%s,%s", indexName, cnxParameter
                     .getBaseName(), additionalsParams);
         LOGGER.info("Appel du job DFCE {} avec les paramètres {}",
               JobUtils.SPLIT_RANGE_INDEX_JOB, parametresJobDfce);

         try {

            getServiceProvider().getJobAdministrationService().start(
                  JobUtils.SPLIT_RANGE_INDEX_JOB, parametresJobDfce);

         } catch (NoSuchDfceJobException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobInstanceAlreadyExistsException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobParametersInvalidException e) {
            throw new AdminDfceRuntimeException(e);
         }

         LOGGER.info(ResourceMessagesUtils.loadMessage("splitIndex.end"),
               cnxParameter.getHostName());

      } finally {
         closeSAEConnection();
      }
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public void mergeIndex(final DFCEConnection cnxParameter, String indexName,
         String additionalsParams) throws ConnectionServiceEx {
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         LOGGER.info(ResourceMessagesUtils.loadMessage("mergeIndex.start"),
               cnxParameter.getHostName());

         String parametresJobDfce = String.format(
               "index.name=%s,base.id=%s,%s", indexName, cnxParameter
                     .getBaseName(), additionalsParams);
         LOGGER.info("Appel du job DFCE {} avec les paramètres {}",
               JobUtils.MERGE_RANGE_INDEX_JOB, parametresJobDfce);

         try {

            getServiceProvider().getJobAdministrationService().start(
                  JobUtils.MERGE_RANGE_INDEX_JOB, parametresJobDfce);

         } catch (NoSuchDfceJobException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobInstanceAlreadyExistsException e) {
            throw new AdminDfceRuntimeException(e);
         } catch (DfceJobParametersInvalidException e) {
            throw new AdminDfceRuntimeException(e);
         }

         LOGGER.info(ResourceMessagesUtils.loadMessage("mergeIndex.end"),
               cnxParameter.getHostName());

      } finally {
         closeSAEConnection();
      }
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public void getIndexesOverLimit(final DFCEConnection cnxParameter,
         Integer limit) throws ConnectionServiceEx {
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("getIndexesOverLimit.start"), cnxParameter
               .getHostName());

         // recuperation de la base DFCE
         Base base = getServiceProvider().getBaseAdministrationService()
               .getBase(cnxParameter.getBaseName());

         List<IndexInformation> listeIndexes = getServiceProvider()
               .getIndexAdministrationService().getIndexesOverLimitInBase(
                     limit, base.getUuid());

         for (IndexInformation index : listeIndexes) {
            for (RangeIndexInformation range : index.getRangeIndexes()) {
               if (range.getTotalIndexUseCount() > limit) {
                  LOGGER
                        .error(
                              "Le plage allant {} à {} de l'index {} a dépassé la limite ({})",
                              new String[] {
                                    range.getLowerBound(),
                                    range.getUpperBound(),
                                    index.getIndexKey(),
                                    Integer.toString(range
                                          .getTotalIndexUseCount()) });
               }
            }
         }

         LOGGER.info(ResourceMessagesUtils
               .loadMessage("getIndexesOverLimit.end"), cnxParameter
               .getHostName());

      } finally {
         closeSAEConnection();
      }
   }
   
   /**
    * {@inheritDoc}
    */
   @Override
   public void getIndexesSize(final DFCEConnection cnxParameter)
         throws ConnectionServiceEx {
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         LOGGER.info(ResourceMessagesUtils.loadMessage("getIndexesSize.start"),
               cnxParameter.getHostName());

         // recuperation de la base DFCE
         Base base = getServiceProvider().getBaseAdministrationService()
               .getBase(cnxParameter.getBaseName());

         List<IndexInformation> listeIndexes = getServiceProvider()
               .getIndexAdministrationService()
               .getIndexesInBase(base.getUuid());

         for (IndexInformation index : listeIndexes) {
            for (RangeIndexInformation range : index.getRangeIndexes()) {
               LOGGER
                     .info(
                           "La taille de plage allant {} à {} de l'index {} est de {}",
                           new String[] {
                                 range.getLowerBound(),
                                 range.getUpperBound(),
                                 index.getIndexKey(),
                                 Integer
                                       .toString(range.getTotalIndexUseCount()) });
            }
         }

         LOGGER.info(ResourceMessagesUtils.loadMessage("getIndexesSize.end"),
               cnxParameter.getHostName());

      } finally {
         closeSAEConnection();
      }
   }
}
