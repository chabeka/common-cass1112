package fr.urssaf.image.sae.admin.dfce.exploit.services.impl;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.List;

import net.docubase.toolkit.exception.ObjectAlreadyExistsException;
import net.docubase.toolkit.model.ToolkitFactory;
import net.docubase.toolkit.model.base.Base;
import net.docubase.toolkit.model.base.BaseCategory;
import net.docubase.toolkit.model.reference.LifeCycleLengthUnit;

import org.apache.commons.lang.Validate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import com.thoughtworks.xstream.mapper.CannotResolveClassException;

import fr.urssaf.image.sae.admin.dfce.exploit.exception.BaseAdministrationServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.ConnectionServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.messages.ResourceMessagesUtils;
import fr.urssaf.image.sae.admin.dfce.exploit.model.ConnectionParameter;
import fr.urssaf.image.sae.admin.dfce.exploit.model.DataBaseModel;
import fr.urssaf.image.sae.admin.dfce.exploit.model.DocumentType;
import fr.urssaf.image.sae.admin.dfce.exploit.model.DocumentsType;
import fr.urssaf.image.sae.admin.dfce.exploit.services.AbstractService;
import fr.urssaf.image.sae.admin.dfce.exploit.services.AdministrationDFCEService;
import fr.urssaf.image.sae.admin.dfce.exploit.utils.BaseUtils;
import fr.urssaf.image.sae.admin.dfce.exploit.utils.Utils;
import fr.urssaf.image.sae.admin.dfce.exploit.xml.XmlDataService;

/**
 * Implémente l'interface : {@link AdministrationDFCEService}
 * <ul>
 * <li>Service de mise à jour des indexes.</li>
 * <li>Service de création de la base SAE et des catégories(Life cycle).</li>
 * </ul>
 * 
 * @author rhofir
 */
@Service
@Qualifier("administrationDfceService")
public class AdministrationDFCEServiceImpl extends AbstractService implements
      AdministrationDFCEService {
   private static final String DATABASE_EXISTS = "database.already.exists";
   private static final Logger LOGGER = LoggerFactory
         .getLogger(AdministrationDFCEServiceImpl.class);
   @Autowired
   private XmlDataService xmlDBModelService;

   /**
    * 
    * @param xmlDBModelService
    *           : Le service de gestion du fichier xml
    */
   public final void setXmlDBModelService(final XmlDataService xmlDBModelService) {
      this.xmlDBModelService = xmlDBModelService;
   }

   /**
    * 
    * @return Le service de gestion du fichier xml
    */
   public final XmlDataService getXmlDBModelService() {
      return xmlDBModelService;
   }

   @Override
   public final void updateIndexes(final ConnectionParameter cnxParameter)
         throws ConnectionServiceEx {
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         LOGGER.info(ResourceMessagesUtils.loadMessage("update.start"),
               cnxParameter.getHost().getHostName());
         getServiceProvider().getStorageAdministrationService()
               .updateAllIndexesUsageCount();
         LOGGER.info(ResourceMessagesUtils.loadMessage("update.end"),
               cnxParameter.getHost().getHostName());
      } catch (ConnectionServiceEx except) {
         throw new ConnectionServiceEx(ResourceMessagesUtils.loadMessage(
               "url.connection.malformed", "connection.impact",
               "connection.action"), except);
      } finally {
         closeSAEConnection();
      }
   }

   /**
    * 
    * {@inheritDoc}
    */
   @SuppressWarnings( { "PMD.LongVariable", "DataflowAnomalyAnalysis",
         "PMD.ExcessiveMethodLength" })
   public final String createSAEBase(final ConnectionParameter cnxParameter,
         final File xmlDataBaseModel, final File xmlDocumentsType)
         throws BaseAdministrationServiceEx, FileNotFoundException,
         ConnectionServiceEx {
      String baseId = null;
      DataBaseModel dataBaseModel = null;
      DocumentsType documentsType = null;
      try {
         buildAndOpenSAEConnexion(cnxParameter);
         // Vérification du contenu du fichier
         Validate.notNull(xmlDataBaseModel, ResourceMessagesUtils
               .loadMessage("xmlDataBaseModel.required"));
         Validate.notNull(xmlDocumentsType, ResourceMessagesUtils
               .loadMessage("xmlDocumentsType.required"));
         // Lecture du fichier correspondent à la structure de base de données
         LOGGER.debug("Chemin de la structure de la base SAE ({})",
               xmlDataBaseModel.getAbsoluteFile());
         LOGGER
               .debug(
                     "Début du chargement et traitement du fichier mod\u00E8le de la base de donn\u00E9es SAE {}",
                     xmlDataBaseModel.getName());
         try {
            dataBaseModel = xmlDBModelService.baseModelReader(xmlDataBaseModel);
            baseId = dataBaseModel.getBase().getBaseId();
         } catch (CannotResolveClassException except) {
            LOGGER
                  .error(
                        "Le contenu du  fichier ({}) ne correspond pas au mod\u00E8le de la base de donn\u00E9es SAE",
                        xmlDataBaseModel.getAbsoluteFile());
            throw new BaseAdministrationServiceEx(
                  "Le contenu du  fichier ("
                        + xmlDataBaseModel.getAbsoluteFile()
                        + ")  ne correspond pas au mod\u00E8le de la base de donn\u00E9es SAE",
                  except);
         }
         LOGGER
               .debug(
                     "Fin du chargement et traitement du fichier mod\u00E8le de la base de donn\u00E9es SAE ({})",
                     xmlDataBaseModel.getName());

         LOGGER.debug("Chemin du fichier cycle de vie des documents SAE ({})",
               xmlDocumentsType.getAbsoluteFile());
         LOGGER
               .debug(
                     "Début du chargement et traitement du fichier cycle de vie des documents SAE ({})",
                     xmlDocumentsType.getName());
         try {
            documentsType = xmlDBModelService
                  .documentsTypeReader(xmlDocumentsType);
         } catch (CannotResolveClassException except) {
            LOGGER
                  .error(
                        "Le contenu du  fichier ({}) ne correspond pas au cycle de vie des documents SAE",
                        xmlDocumentsType.getAbsoluteFile());
            throw new BaseAdministrationServiceEx("Le contenu du fichier ("
                  + xmlDocumentsType.getAbsoluteFile()
                  + ") ne correspond pas au cycle de vie des documents SAE",
                  except);
         }
         LOGGER
               .debug(
                     "Fin du chargement et traitement du fichier cycle de vie des documents SAE ({})",
                     xmlDocumentsType.getName());
         LOGGER
               .info(
                     "Début de la création de la base SAE. Identifiant de la base: ({})",
                     baseId);
         final ToolkitFactory toolkitFactory = ToolkitFactory.getInstance();
         LOGGER.info(ResourceMessagesUtils.loadMessage(
               "database.initialization", dataBaseModel.toString()));
         // Instantiation d'une base
         Base base = getServiceProvider().getBaseAdministrationService()
               .getBase(baseId);
         LOGGER.debug("Début de v\u00E9rification de l'exsitance de la base {}",
               baseId);
         if (base == null) {
            base = toolkitFactory.createBase(baseId);
         } else {
            LOGGER.warn(ResourceMessagesUtils.loadMessage(DATABASE_EXISTS,
                  baseId));
            throw new BaseAdministrationServiceEx(ResourceMessagesUtils
                  .loadMessage(DATABASE_EXISTS, baseId));
         }
         LOGGER.debug("Fin de v\u00E9rification de l'exsitance de la base ({})",
               baseId);

         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.initialization.technical.metadatas"));
         // Définition des propriétes de la base
         BaseUtils.initBaseProperties(base, dataBaseModel);
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.initialization.base.categories"));
         // Création des baseCatégories
         final List<BaseCategory> baseCategories = BaseUtils
               .initBaseCategories(dataBaseModel, getServiceProvider());
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.base.categories.creation"));
         for (BaseCategory baseCategory : Utils
               .nullSafeIterable(baseCategories)) {
            base.addBaseCategory(baseCategory);
         }
         LOGGER.info(ResourceMessagesUtils.loadMessage("database.creation",
               baseId));
         // Création de la base
         getServiceProvider().getBaseAdministrationService().createBase(base);
         LOGGER.debug("Début Création des indexes composites");
         LOGGER.info(ResourceMessagesUtils
               .loadMessage("database.index.composite.creation"));
         // Création des indexes composites
         BaseUtils.createIndexComposite(dataBaseModel, getServiceProvider());
         LOGGER.debug("Fin Création des indexes composites");
         // on démarre la base
         getServiceProvider().getBaseAdministrationService().startBase(base);
         // Alimentation de la colonne famille LifeCycleRule
         LOGGER
               .debug("Début d'alimentation de la colonne famille LifeCycleRule");
         createDocumentsType(documentsType);
         LOGGER
               .debug("Fin d'alimentation de la colonne famille LifeCycleRule");
         LOGGER
               .info(
                     "Fin de la création de la base SAE. Identifiant de la base: ({})",
                     baseId);
         return base.getBaseId();
      } catch (ObjectAlreadyExistsException objAlreadyExistsEx) {
         LOGGER.error(ResourceMessagesUtils
               .loadMessage(DATABASE_EXISTS, baseId));
         throw new BaseAdministrationServiceEx(ResourceMessagesUtils
               .loadMessage(DATABASE_EXISTS), objAlreadyExistsEx);
      } finally {
         closeSAEConnection();
      }

   }

   /**
    * Service permettant de créer le cycle de vie d'un document.
    * 
    * @param documentsType
    *           : Le service de désérialisation des flux xml
    * @throws FileNotFoundException
    *            Lorsque le fichier n'existe pas
    * @throws ConnectionServiceEx
    *            Lorsqu'un problème survient lors de la connexion.
    */
   private void createDocumentsType(final DocumentsType documentsType)
         throws FileNotFoundException {
      LOGGER.info(ResourceMessagesUtils
            .loadMessage("lifeCycleRule.initialization"));
      LOGGER.info(ResourceMessagesUtils.loadMessage("lifeCycleRule.create"));
      for (DocumentType typeDocument : Utils.nullSafeIterable(documentsType
            .getListDocumentsType())) {
         try {
            LOGGER.info(ResourceMessagesUtils.loadMessage(
                  "lifeCycleRule.document", typeDocument.getRndCode()));
            getServiceProvider().getStorageAdministrationService()
                  .createNewLifeCycleRule(typeDocument.getRndCode(),
                        typeDocument.getStorageDuration(),
                        LifeCycleLengthUnit.DAY);
         } catch (ObjectAlreadyExistsException objectExist) {
            LOGGER.warn(ResourceMessagesUtils.loadMessage(
                  "lifeCycleRule.already.exist", typeDocument.getRndCode()));
         }
      }
   }
}
