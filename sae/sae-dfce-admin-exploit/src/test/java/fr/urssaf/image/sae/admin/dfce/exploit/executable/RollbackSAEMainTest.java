package fr.urssaf.image.sae.admin.dfce.exploit.executable;

import java.util.List;

import junit.framework.Assert;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.spi.ILoggingEvent;
import fr.urssaf.image.sae.admin.dfce.exploit.util.AppenderTestBase;

@SuppressWarnings("PMD.MethodNamingConventions")
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "/applicationContext-sae-dfce-admin-exploit-service-mock-test.xml" })
public class RollbackSAEMainTest {

   private AppenderTestBase appenderTest;

   @SuppressWarnings("PMD.LoggerIsNotStaticFinal")
   private Logger rootLogger;

   private AdministrationSAEMain administrationSAEMain;

   @Autowired
   private ApplicationContext context;

   @Before
   public void before() {

      administrationSAEMain = new AdministrationSAEMain(
            "applicationContext-sae-dfce-admin-exploit-mock-test.xml");

      // on récupère le root logger
      rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);

      // instanciation d'un Appender
      appenderTest = new AppenderTestBase(Level.WARN,
            "fr.urssaf.image.sae.admin.dfce.exploit");
      // l'instance est attachée au root logger
      rootLogger.addAppender(appenderTest);

   }

   @After
   public void after() {

      // on détache l'instance Appender du root logger à chaque fin de tests
      // ceci pour éviter de mémoriser à chaque test unitaire un Appender
      // nouveau
      rootLogger.detachAppender(appenderTest);

   }

   private void assertLog(ILoggingEvent actual, Level expectedLevel,
         String expectedMessage) {

      Assert.assertEquals("le niveau du log est inattendu", expectedLevel,
            actual.getLevel());
      Assert.assertEquals("le message du log est inattendu", expectedMessage,
            actual.getFormattedMessage());
   }

   private void assertLogCount(int expectedCount,
         List<ILoggingEvent> loggingEvents) {

      Assert.assertEquals("le nombre de logs est inattendu", expectedCount,
            loggingEvents.size());
   }

   @Test
   public void main_failure_id_manquant() {

      try {
         administrationSAEMain.executeService("rollbackTraitement", context,
               new String[] {});
         Assert.fail("une exception est attendue");

      } catch (IllegalArgumentException exception) {
         Assert.assertEquals("l'erreur doit etre correcte",
               "Identifiant du traitement de masse obligatoire", exception
                     .getMessage());

      } catch (Exception exception) {
         Assert.fail("mauvais type d'erreur : "
               + exception.getClass().toString() + ". Attendue : "
               + IllegalArgumentException.class.toString());
      }

   }
   
   @Test
   public void main_failure_id_blanc() {

      try {
         administrationSAEMain.executeService("rollbackTraitement", context,
               new String[] { "" });
         Assert.fail("une exception est attendue");

      } catch (IllegalArgumentException exception) {
         Assert.assertEquals("l'erreur doit etre correcte",
               "Identifiant du traitement de masse obligatoire", exception
                     .getMessage());

      } catch (Exception exception) {
         Assert.fail("mauvais type d'erreur : "
               + exception.getClass().toString() + ". Attendue : "
               + IllegalArgumentException.class.toString());
      }

   }
   
   @Test
   public void main_failure_id_errone() {

      try {
         administrationSAEMain.executeService("rollbackTraitement", context,
               new String[] { "a" });
         Assert.fail("une exception est attendue");

      } catch (IllegalArgumentException exception) {
         Assert.assertEquals("l'erreur doit etre correcte",
               "Identifiant du traitement de masse : format erroné", exception
                     .getMessage());

      } catch (Exception exception) {
         Assert.fail("mauvais type d'erreur : "
               + exception.getClass().toString() + ". Attendue : "
               + IllegalArgumentException.class.toString());
      }

   }

   @Test
   public void main_failure_service_non_renseigne() {

      administrationSAEMain.execute(new String[] { "" });

      // on récupère la liste des logs
      List<ILoggingEvent> loggingEvents = appenderTest.getLoggingEvents();

      // on teste le nombre de logs retrouvés
      assertLogCount(1, loggingEvents);

      // on teste pour chacun son message et son niveau
      assertLog(loggingEvents.get(0), Level.WARN,
            "L'opération du traitement doit être renseigné.");
   }

   @Test
   public void main_failure_context_non_renseigne() {

      administrationSAEMain.execute(new String[] { "rollbackTraitement" });

      // on récupère la liste des logs
      List<ILoggingEvent> loggingEvents = appenderTest.getLoggingEvents();

      // on teste le nombre de logs retrouvés
      assertLogCount(1, loggingEvents);

      // on teste pour chacun son message et son niveau
      assertLog(
            loggingEvents.get(0),
            Level.WARN,
            "Le chemin complet du fichier de configuration générale du SAE doit être renseigné.");

   }
}
