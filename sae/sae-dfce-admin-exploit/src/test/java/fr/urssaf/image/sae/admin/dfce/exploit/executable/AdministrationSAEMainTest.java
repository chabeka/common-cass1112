package fr.urssaf.image.sae.admin.dfce.exploit.executable;

import java.util.List;

import org.easymock.EasyMock;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.spi.ILoggingEvent;
import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.ArchiveLogsRunningEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.ConnectionServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.services.ArchiveLogSystemDFCEService;
import fr.urssaf.image.sae.admin.dfce.exploit.support.CommandeSAELineHelper;
import fr.urssaf.image.sae.admin.dfce.exploit.util.AppenderTestBase;
import fr.urssaf.image.sae.admin.dfce.exploit.util.ServiceMockFactory;
import org.junit.Assert;

@SuppressWarnings("PMD.MethodNamingConventions")
public class AdministrationSAEMainTest {

   private AppenderTestBase appenderTest;

   @SuppressWarnings("PMD.LoggerIsNotStaticFinal")
   private Logger rootLogger;

   private AdministrationSAEMain administrationSAEMain;

   private ArchiveLogSystemDFCEService service;

   @Before
   public void before() {

      administrationSAEMain = new AdministrationSAEMain(
            "applicationContext-sae-dfce-admin-exploit-mock-test.xml");

      // on récupère le root logger
      rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);

      // instanciation d'un Appender
      appenderTest = new AppenderTestBase(Level.WARN,
            "fr.urssaf.image.sae.admin.dfce.exploit");
      // l'instance est attachée au root logger
      rootLogger.addAppender(appenderTest);

      service = ServiceMockFactory.createArchiveLogSystemDFCEService();

      EasyMock.reset(service);

   }

   @After
   public void after() {

      // on détache l'instance Appender du root logger à chaque fin de tests
      // ceci pour éviter de mémoriser à chaque test unitaire un Appender
      // nouveau
      rootLogger.detachAppender(appenderTest);

   }

   private void assertLog(ILoggingEvent actual, Level expectedLevel,
         String expectedMessage) {

      Assert.assertEquals("le niveau du log est inattendu", expectedLevel,
            actual.getLevel());
      Assert.assertEquals("le message du log est inattendu", expectedMessage,
            actual.getFormattedMessage());
   }

   private void assertLogCount(int expectedCount,
         List<ILoggingEvent> loggingEvents) {

      Assert.assertEquals("le nombre de logs est inattendu", expectedCount,
            loggingEvents.size());
   }

   @Test
   public void main_failure_service_non_disponible() {

      administrationSAEMain.execute(new String[] { "unknownOperation" });

      // on récupère la liste des logs
      List<ILoggingEvent> loggingEvents = appenderTest.getLoggingEvents();

      // on teste le nombre de logs retrouvés
      assertLogCount(1, loggingEvents);

      // on teste pour chacun son message et son niveau
      assertLog(loggingEvents.get(0), Level.WARN,
            "Le service demande unknownOperation n'est pas valide");

   }

   @Test
   public void main_failure_service_non_renseigne() {

      administrationSAEMain.execute(new String[] { "" });

      // on récupère la liste des logs
      List<ILoggingEvent> loggingEvents = appenderTest.getLoggingEvents();

      // on teste le nombre de logs retrouvés
      assertLogCount(1, loggingEvents);

      // on teste pour chacun son message et son niveau
      assertLog(loggingEvents.get(0), Level.WARN,
            "L'opération du traitement doit être renseigné.");
   }

   @Test
   public void main_failure_context_non_renseigne() {

      administrationSAEMain.execute(new String[] { "consultSystemEvent" });

      // on récupère la liste des logs
      List<ILoggingEvent> loggingEvents = appenderTest.getLoggingEvents();

      // on teste le nombre de logs retrouvés
      assertLogCount(1, loggingEvents);

      // on teste pour chacun son message et son niveau
      assertLog(
            loggingEvents.get(0),
            Level.WARN,
            "Le chemin complet du fichier de configuration générale du SAE doit être renseigné.");

   }

   @Test
   public void main_success_help() {

      appenderTest = new AppenderTestBase(Level.INFO,
            "fr.urssaf.image.sae.admin.dfce.exploit");

      // l'instance est attachée au root logger
      rootLogger.addAppender(appenderTest);

      administrationSAEMain.execute(new String[] { "help" });

      List<ILoggingEvent> loggingEvents = appenderTest.getLoggingEvents();

      // on teste le nombre de logs retrouvés
      assertLogCount(2, loggingEvents);

      // on teste pour chacun son message et son niveau
      assertLog(loggingEvents.get(0), Level.INFO,
            "Help: ligne de commande pour les services d'administration SAE: ");

      assertLog(loggingEvents.get(1), Level.INFO, CommandeSAELineHelper
            .helpCommandeLine());

   }

   @Test
   public void main_failure_service() throws ArchiveLogsRunningEx,
         ConnectionServiceEx {

      service.createSystemEventLogs(EasyMock
            .anyObject(DFCEConnection.class), EasyMock.anyInt());

      EasyMock.expectLastCall().andThrow(
            new ArchiveLogsRunningEx("une exception a eu lieu"));

      EasyMock.replay(service);

      administrationSAEMain.execute(new String[] { "creatSystemEvent",
            "src/test/resources/config_sae.properties" });

      List<ILoggingEvent> loggingEvents = appenderTest.getLoggingEvents();

      // on teste le nombre de logs retrouvés
      assertLogCount(1, loggingEvents);

      // on teste pour chacun son message et son niveau
      assertLog(loggingEvents.get(0), Level.ERROR,
            "Une erreur s'est produite lors du traitement creatSystemEvent");

      EasyMock.verify(service);

   }

   @Test
   public void main_success_service() throws ArchiveLogsRunningEx,
         ConnectionServiceEx {

      administrationSAEMain.execute(new String[] { "creatSystemEvent",
            "src/test/resources/config_sae.properties" });

      List<ILoggingEvent> loggingEvents = appenderTest.getLoggingEvents();

      // on teste le nombre de logs retrouvés
      assertLogCount(0, loggingEvents);

   }

   @Test
   public void controleListeMetaPourUpdateDocuments() {

      Assert
            .assertTrue(
                  "La syntaxe de la liste des métadonnées est pourtant correct",
                  administrationSAEMain
                        .controleListeMetaPourUpdateDocuments("meta1"));

      Assert.assertTrue(
            "La syntaxe de la liste des métadonnées est pourtant correct",
            administrationSAEMain
                  .controleListeMetaPourUpdateDocuments("meta1;meta2"));

      Assert.assertTrue(
            "La syntaxe de la liste des métadonnées est pourtant correct",
            administrationSAEMain
                  .controleListeMetaPourUpdateDocuments("meta1;meta2;meta3"));
      
      Assert.assertTrue(
            "La syntaxe de la liste des métadonnées est pourtant correct",
            administrationSAEMain
                  .controleListeMetaPourUpdateDocuments("meta_1;meta_2;meta_3"));

      Assert.assertFalse(
            "La syntaxe de la liste des métadonnées est pourtant incorrect",
            administrationSAEMain
                  .controleListeMetaPourUpdateDocuments("meta1|meta2"));

      Assert.assertFalse(
            "La syntaxe de la liste des métadonnées est pourtant incorrect",
            administrationSAEMain.controleListeMetaPourUpdateDocuments("@"));

   }
   
   @Test
   public void controleParamIndexationIndexesComposites() {
      Assert.assertFalse(
            "Le paramètre indexesComposites est vide",
            administrationSAEMain.isValidListeIndexesComposites(""));
      
      Assert.assertFalse(
            "Le paramètre indexesComposites est vide",
            administrationSAEMain.isValidListeIndexesComposites(" "));
      
      Assert.assertFalse(
            "Le paramètre indexesComposites est vide",
            administrationSAEMain.isValidListeIndexesComposites(null));

      Assert.assertTrue(
            "Le paramètre indexesComposites est valide",
            administrationSAEMain.isValidListeIndexesComposites("sac&SM_DOCUMENT_TYPE&"));
      
      Assert.assertTrue(
            "Le paramètre indexesComposites est valide",
            administrationSAEMain.isValidListeIndexesComposites("meta1&meta2&|meta1&meta2meta3&"));
      
      Assert.assertTrue(
            "Le paramètre indexesComposites est valide",
            administrationSAEMain.isValidListeIndexesComposites("meta1&meta2&|meta1&meta2meta3&|meta4&meta5&"));    
      
      Assert.assertFalse(
            "Le paramètre indexesComposites est invalide: il faut au minimun 2 metas par index composite",
            administrationSAEMain.isValidListeIndexesComposites("meta1&|meta2&meta3&"));
      
      Assert.assertFalse(
            "Le paramètre indexesComposites est invalide: carractère invalide '+'",
            administrationSAEMain.isValidListeIndexesComposites("meta1&meta2&+meta1&meta2meta3&"));
      
      Assert.assertFalse(
            "Le paramètre indexesComposites est invalide: chaque indexe composite dioit se teminer par '&'",
            administrationSAEMain.isValidListeIndexesComposites("meta1&meta|meta2&meta3"));
   }
}
