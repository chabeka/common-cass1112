package fr.urssaf.image.sae.ihm.web.exploit.service.impl;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import me.prettyprint.hector.api.Keyspace;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import fr.urssaf.image.commons.cassandra.support.clock.JobClockConfiguration;
import fr.urssaf.image.commons.cassandra.support.clock.JobClockSupport;
import fr.urssaf.image.commons.cassandra.support.clock.impl.JobClockSupportImpl;
import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.commons.dfce.service.DFCEConnectionService;
import fr.urssaf.image.commons.dfce.service.impl.DFCEConnectionServiceImpl;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucuneTraceException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.ErreurTechniqueException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.TraceException;
import fr.urssaf.image.sae.ihm.web.exploit.modele.DfceTrace;
import fr.urssaf.image.sae.ihm.web.exploit.modele.SaeTrace;
import fr.urssaf.image.sae.ihm.web.exploit.service.TraceService;
import fr.urssaf.image.sae.trace.dao.TraceDestinataireDao;
import fr.urssaf.image.sae.trace.dao.TraceJournalEvtDao;
import fr.urssaf.image.sae.trace.dao.TraceJournalEvtIndexDao;
import fr.urssaf.image.sae.trace.dao.TraceRegExploitationDao;
import fr.urssaf.image.sae.trace.dao.TraceRegExploitationIndexDao;
import fr.urssaf.image.sae.trace.dao.TraceRegSecuriteDao;
import fr.urssaf.image.sae.trace.dao.TraceRegSecuriteIndexDao;
import fr.urssaf.image.sae.trace.dao.TraceRegTechniqueDao;
import fr.urssaf.image.sae.trace.dao.TraceRegTechniqueIndexDao;
import fr.urssaf.image.sae.trace.dao.model.TraceJournalEvt;
import fr.urssaf.image.sae.trace.dao.model.TraceJournalEvtIndex;
import fr.urssaf.image.sae.trace.dao.model.TraceRegExploitation;
import fr.urssaf.image.sae.trace.dao.model.TraceRegExploitationIndex;
import fr.urssaf.image.sae.trace.dao.model.TraceRegSecurite;
import fr.urssaf.image.sae.trace.dao.model.TraceRegSecuriteIndex;
import fr.urssaf.image.sae.trace.dao.model.TraceRegTechnique;
import fr.urssaf.image.sae.trace.dao.model.TraceRegTechniqueIndex;
import fr.urssaf.image.sae.trace.dao.support.CycleVieSupport;
import fr.urssaf.image.sae.trace.dao.support.HistEvenementSupport;
import fr.urssaf.image.sae.trace.dao.support.ServiceProviderSupport;
import fr.urssaf.image.sae.trace.dao.support.TraceDestinataireSupport;
import fr.urssaf.image.sae.trace.dao.support.TraceJournalEvtSupport;
import fr.urssaf.image.sae.trace.dao.support.TraceRegExploitationSupport;
import fr.urssaf.image.sae.trace.dao.support.TraceRegSecuriteSupport;
import fr.urssaf.image.sae.trace.dao.support.TraceRegTechniqueSupport;
import fr.urssaf.image.sae.trace.model.DfceTraceDoc;
import fr.urssaf.image.sae.trace.model.DfceTraceSyst;
import fr.urssaf.image.sae.trace.model.TraceType;
import fr.urssaf.image.sae.trace.service.CycleVieService;
import fr.urssaf.image.sae.trace.service.HistEvenementService;
import fr.urssaf.image.sae.trace.service.JournalEvtService;
import fr.urssaf.image.sae.trace.service.RegExploitationService;
import fr.urssaf.image.sae.trace.service.RegSecuriteService;
import fr.urssaf.image.sae.trace.service.RegTechniqueService;
import fr.urssaf.image.sae.trace.service.TraceDestinaireService;
import fr.urssaf.image.sae.trace.service.impl.CycleVieServiceImpl;
import fr.urssaf.image.sae.trace.service.impl.HistEvenementServiceImpl;
import fr.urssaf.image.sae.trace.service.impl.JournalEvtServiceImpl;
import fr.urssaf.image.sae.trace.service.impl.RegExploitationServiceImpl;
import fr.urssaf.image.sae.trace.service.impl.RegSecuriteServiceImpl;
import fr.urssaf.image.sae.trace.service.impl.RegTechniqueServiceImpl;
import fr.urssaf.image.sae.trace.service.impl.TraceDestinataireServiceImpl;
import fr.urssaf.image.sae.trace.service.support.LoggerSupport;
import fr.urssaf.image.sae.trace.service.support.TraceFileSupport;
import fr.urssaf.image.sae.trace.support.TimeUUIDEtTimestampSupport;

/**
 * Classe d'implémentation de l'interface TraceService. Cette classe est n
 * singleton et peut être accessible via le mécanisme d'injection IOC
 * 
 * 
 */
@Service
public class TraceServiceImpl implements TraceService {

   public static final int MAX_TIME_SYNCHRO_ERROR = 1000000;
   public static final int MAX_TIME_SYNCHRO_WARN = 1500000;

   private static final String FIN_LOG = "{} - fin";
   private static final String DEBUT_LOG = "{} - début";
   private static final Logger LOGGER = LoggerFactory
         .getLogger(TraceServiceImpl.class);

   
   /**
    * {@inheritDoc}
    */
   @Override
   public final SaeTrace lectureTraceSaeParUuid(TraceType type, UUID uuidTrace,
         Keyspace keyspace) throws AucuneTraceException, TraceException {

      String prefix = "lectureTraceSaeParUuid()";
      LOGGER.debug(DEBUT_LOG, prefix);

      LOGGER.debug("{} - Type de trace : {}", new String[] { prefix,
            type.toString() });
      LOGGER.debug("{} - UUID trace : {}", new String[] { prefix, uuidTrace.toString() });

      if (!TraceType.TECHNIQUE.equals(type) && !TraceType.SECURITE.equals(type)
            && !TraceType.EXPLOITATION.equals(type) && !TraceType.JOURNAL_EVT.equals(type)) {
         throw new TraceException("Le type de trace demandé n'est pas correct.");
      }

      JobClockConfiguration clockConfiguration = new JobClockConfiguration();
      clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
      clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);
      JobClockSupport clockSupport = new JobClockSupportImpl(keyspace,
            clockConfiguration);

      LoggerSupport loggerSupport = new LoggerSupport();

      SaeTrace saeTrace = new SaeTrace();

      if (TraceType.EXPLOITATION.equals(type)) {

         TraceRegExploitationDao dao = new TraceRegExploitationDao(keyspace);
         TraceRegExploitationIndexDao indexDao = new TraceRegExploitationIndexDao(
               keyspace);
         TimeUUIDEtTimestampSupport timeUUIDSupport = new TimeUUIDEtTimestampSupport();
         TraceRegExploitationSupport support = new TraceRegExploitationSupport(
               dao, indexDao, timeUUIDSupport);

         RegExploitationService service = new RegExploitationServiceImpl(
               support, clockSupport, loggerSupport);
         TraceRegExploitation trace = service.lecture(uuidTrace);

         saeTrace.setAction(trace.getAction());
         saeTrace.setCodeEvt(trace.getCodeEvt());
         // saeTrace.setContexte();
         saeTrace.setContrat(trace.getContratService());
         saeTrace.setLogin(trace.getLogin());
         //saeTrace.setStacktrace();
         saeTrace.setTimestamp(trace.getTimestamp());
         saeTrace.setPagms(trace.getPagms());
         saeTrace.setInfos(trace.getInfos());

      } else if (TraceType.TECHNIQUE.equals(type)) {

         TraceRegTechniqueDao dao = new TraceRegTechniqueDao(keyspace);
         TraceRegTechniqueIndexDao indexDao = new TraceRegTechniqueIndexDao(
               keyspace);
         TimeUUIDEtTimestampSupport timeUUIDSupport = new TimeUUIDEtTimestampSupport();
         TraceRegTechniqueSupport support = new TraceRegTechniqueSupport(dao,
               indexDao, timeUUIDSupport);

         RegTechniqueService service = new RegTechniqueServiceImpl(support,
               clockSupport, loggerSupport);
         TraceRegTechnique trace = service.lecture(uuidTrace);

         saeTrace.setCodeEvt(trace.getCodeEvt());
         saeTrace.setContexte(trace.getContexte());
         saeTrace.setContrat(trace.getContratService());
         saeTrace.setLogin(trace.getLogin());
         String stacktrace = trace.getStacktrace();
         
         stacktrace = StringUtils.replace(stacktrace, "\n", "<br/>");
         stacktrace = StringUtils.replace(stacktrace, "Caused by", "<b>Caused by</b>");
         stacktrace = StringUtils.replace(stacktrace, "\t", "&nbsp&nbsp&nbsp");
         saeTrace.setStacktrace(stacktrace);
         saeTrace.setTimestamp(trace.getTimestamp());
         saeTrace.setPagms(trace.getPagms());
         
         Map<String, Object> infos = trace.getInfos();
         //String soap = (String)infos.get("soapRequest");
         //soap = StringUtils.replace(soap, "\n", "<br/>");
         //infos.put("soapRequest", soap);
         
         saeTrace.setInfos(infos);
         

      } else if (TraceType.SECURITE.equals(type)) {

         TraceRegSecuriteDao dao = new TraceRegSecuriteDao(keyspace);
         TraceRegSecuriteIndexDao indexDao = new TraceRegSecuriteIndexDao(
               keyspace);
         TimeUUIDEtTimestampSupport timeUUIDSupport = new TimeUUIDEtTimestampSupport();
         TraceRegSecuriteSupport support = new TraceRegSecuriteSupport(dao,
               indexDao, timeUUIDSupport);

         RegSecuriteService service = new RegSecuriteServiceImpl(support,
               clockSupport, loggerSupport);
         TraceRegSecurite trace = service.lecture(uuidTrace);

         //saeTrace.setAction();
         saeTrace.setCodeEvt(trace.getCodeEvt());
         saeTrace.setContexte(trace.getContexte());
         saeTrace.setContrat(trace.getContratService());
         saeTrace.setLogin(trace.getLogin());
         //saeTrace.setStacktrace();
         saeTrace.setTimestamp(trace.getTimestamp());
         saeTrace.setPagms(trace.getPagms());
         saeTrace.setInfos(trace.getInfos());

      } else if (TraceType.JOURNAL_EVT.equals(type)) {
         TraceJournalEvtDao dao = new TraceJournalEvtDao(keyspace);
         TraceJournalEvtIndexDao indexDao = new TraceJournalEvtIndexDao(
               keyspace);
         TimeUUIDEtTimestampSupport timeUUIDSupport = new TimeUUIDEtTimestampSupport();
         TraceJournalEvtSupport support = new TraceJournalEvtSupport(dao,
               indexDao, timeUUIDSupport);
         TraceFileSupport traceFileSupport = new TraceFileSupport();
         JournalEvtService service = new JournalEvtServiceImpl(support,
               clockSupport, loggerSupport, traceFileSupport);
         
         TraceJournalEvt trace = service.lecture(uuidTrace);
         
         //saeTrace.setAction(trace.getAction());
         saeTrace.setCodeEvt(trace.getCodeEvt());
         saeTrace.setContexte(trace.getContexte());
         saeTrace.setContrat(trace.getContratService());
         saeTrace.setLogin(trace.getLogin());
         //saeTrace.setStacktrace();
         saeTrace.setTimestamp(trace.getTimestamp());
         saeTrace.setPagms(trace.getPagms());
         saeTrace.setInfos(trace.getInfos());
      
      }

      LOGGER.debug(FIN_LOG, prefix);
      return saeTrace;

   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final List<DfceTrace> lectureTracesDfceParDates(TraceType type,
         Date dateDebut, Date dateFin, int taille, boolean ordreInverse, DFCEConnection dfceConnection)
         throws AucuneTraceException, TraceException, ErreurTechniqueException {

      String prefix = "lectureTracesDfceParDates()";
      LOGGER.debug(DEBUT_LOG, prefix);

      LOGGER.debug("{} - Arguments entrée :", prefix);
      LOGGER.debug("{} - Type de trace : {}", new String[] { prefix,
            type.toString() });
      LOGGER.debug("{} - Date début : {}", new String[] { prefix,
            dateDebut.toString() });
      LOGGER.debug("{} - Date fin : {}", new String[] { prefix,
            dateFin.toString() });
      LOGGER.debug("{} - Taille : {}", new String[] { prefix,
            Integer.toString(taille) });
      LOGGER.debug("{} - Connexion DFCE : {}", new String[] { prefix,
            dfceConnection.getServerUrl().toString() });

      if (!TraceType.HIST_EVT.equals(type) && !TraceType.CYCLE_VIE.equals(type)) {
         throw new TraceException("Le type de trace demandé n'est pas correct.");
      }

      List<DfceTrace> listeTraces;
      try {
         DFCEConnectionService dfceConnectionService = new DFCEConnectionServiceImpl(
               dfceConnection);
         ServiceProviderSupport providerSupport = new ServiceProviderSupport(
               dfceConnectionService);
         providerSupport.connect();

         listeTraces = new ArrayList<DfceTrace>();

         if (TraceType.HIST_EVT.equals(type)) {

            HistEvenementSupport support = new HistEvenementSupport(
                  providerSupport);
            HistEvenementService service = new HistEvenementServiceImpl(support);

            List<DfceTraceSyst> events = service.lecture(dateDebut, dateFin,
                  taille, ordreInverse);

            if (events != null) {
               for (DfceTraceSyst event : events) {
                  DfceTrace dfceTrace = new DfceTrace();
                  dfceTrace.setAttributs(event.getAttributs());
                  dfceTrace.setDateEvt(event.getDateEvt());
                  dfceTrace.setDocUuid(event.getDocUuid());
                  dfceTrace.setLogin(event.getLogin());
                  dfceTrace.setTypeEvt(event.getTypeEvt());
                  listeTraces.add(dfceTrace);
               }
            }

         } else if (TraceType.CYCLE_VIE.equals(type)) {

            CycleVieSupport support = new CycleVieSupport(providerSupport);
            CycleVieService service = new CycleVieServiceImpl(support);

            List<DfceTraceDoc> events = service.lecture(dateDebut, dateFin,
                  taille, ordreInverse);

            if (events != null) {
               for (DfceTraceDoc dfceTraceDoc : events) {
                  DfceTrace dfceTrace = new DfceTrace();
                  dfceTrace.setAttributs(dfceTraceDoc.getAttributs());
                  dfceTrace.setDateEvt(dfceTraceDoc.getDateEvt());
                  dfceTrace.setDocUuid(dfceTraceDoc.getDocUuid());
                  dfceTrace.setLogin(dfceTraceDoc.getLogin());
                  dfceTrace.setTypeEvt(dfceTraceDoc.getTypeEvt());
                  listeTraces.add(dfceTrace);
               }
            }

         }

         providerSupport.disconnect();
      } catch (Exception e) {
         throw new ErreurTechniqueException(e.getMessage());
      }

      LOGGER.debug("{} - Sortie nb traces : {}", new String[] { prefix,
            Integer.toString(listeTraces.size()) });
      LOGGER.debug(FIN_LOG, prefix);
      return listeTraces;
   }

   /**
    * {@inheritDoc}
    * 
    * @throws TraceException
    */
   @Override
   public final List<DfceTrace> lectureTracesDfceParDocUuid(TraceType type,
         UUID docUuid, DFCEConnection dfceConnection) throws TraceException {

      String prefix = "lectureTracesDfceParDocUuid()";
      LOGGER.debug(DEBUT_LOG, prefix);

      LOGGER.debug("{} - Type de trace : {}", new String[] { prefix,
            type.toString() });
      LOGGER.debug("{} - UUID : {}",
            new String[] { prefix, docUuid.toString() });
      LOGGER.debug("{} - Connexion DFCE : {}", new String[] { prefix,
            dfceConnection.getServerUrl().toString() });

      if (!TraceType.CYCLE_VIE.equals(type)) {
         throw new TraceException("Le type de trace demandé n'est pas correct.");
      }

      DFCEConnectionService dfceConnectionService = new DFCEConnectionServiceImpl(
            dfceConnection);

      ServiceProviderSupport providerSupport = new ServiceProviderSupport(
            dfceConnectionService);
      providerSupport.connect();

      List<DfceTrace> listeTraces = new ArrayList<DfceTrace>();
      CycleVieSupport support = new CycleVieSupport(providerSupport);
      CycleVieService service = new CycleVieServiceImpl(support);

      List<DfceTraceDoc> events = service.lectureParDocument(docUuid);

      providerSupport.disconnect();

      if (events != null) {
         for (DfceTraceDoc dfceTraceDoc : events) {
            DfceTrace dfceTrace = new DfceTrace();
            dfceTrace.setAttributs(dfceTraceDoc.getAttributs());
            dfceTrace.setDateEvt(dfceTraceDoc.getDateEvt());
            dfceTrace.setDocUuid(dfceTraceDoc.getDocUuid());
            dfceTrace.setLogin(dfceTraceDoc.getLogin());
            dfceTrace.setTypeEvt(dfceTraceDoc.getTypeEvt());
            listeTraces.add(dfceTrace);
         }
      }

      LOGGER.debug("{} - Sortie nb traces : {}", new String[] { prefix,
            Integer.toString(listeTraces.size()) });

      LOGGER.debug(FIN_LOG, prefix);
      return listeTraces;
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final List<SaeTrace> lectureTracesSaeParDates(TraceType type,
         Date dateDebut, Date dateFin, int taille, boolean ordreInverse, Keyspace keyspace)
         throws AucuneTraceException, TraceException, ErreurTechniqueException {

      String prefix = "lectureTracesSaeParDates()";
      LOGGER.debug(DEBUT_LOG, prefix);

      LOGGER.debug("{} - Type de trace : {}", new String[] { prefix,
            type.toString() });
      LOGGER.debug("{} - Date début : {}", new String[] { prefix,
            dateDebut.toString() });
      LOGGER.debug("{} - Date fin : {}", new String[] { prefix,
            dateFin.toString() });
      LOGGER.debug("{} - Taille : {}", new String[] { prefix,
            Integer.toString(taille) });

      if (!TraceType.TECHNIQUE.equals(type) && !TraceType.SECURITE.equals(type)
            && !TraceType.EXPLOITATION.equals(type)
            && !TraceType.JOURNAL_EVT.equals(type)) {
         throw new TraceException("Le type de trace demandé n'est pas correct.");
      }

      List<SaeTrace> listeTraces = new ArrayList<SaeTrace>();

         JobClockConfiguration clockConfiguration = new JobClockConfiguration();
         clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
         clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);
         JobClockSupport clockSupport = new JobClockSupportImpl(keyspace,
               clockConfiguration);

         LoggerSupport loggerSupport = new LoggerSupport();

         listeTraces = new ArrayList<SaeTrace>();
         if (TraceType.EXPLOITATION.equals(type)) {

            TraceRegExploitationDao dao = new TraceRegExploitationDao(keyspace);
            TraceRegExploitationIndexDao indexDao = new TraceRegExploitationIndexDao(
                  keyspace);
            TimeUUIDEtTimestampSupport timeUUIDSupport = new TimeUUIDEtTimestampSupport();
            TraceRegExploitationSupport support = new TraceRegExploitationSupport(
                  dao, indexDao, timeUUIDSupport);

            RegExploitationService service = new RegExploitationServiceImpl(
                  support, clockSupport, loggerSupport);
            List<TraceRegExploitationIndex> traces = service.lecture(dateDebut,
                  dateFin, taille, ordreInverse);

            if (traces != null) {
               for (TraceRegExploitationIndex trace : traces) {
                  SaeTrace saeTrace = new SaeTrace();
                  saeTrace.setIdentifiant(trace.getIdentifiant());
                  saeTrace.setAction(trace.getAction());
                  saeTrace.setCodeEvt(trace.getCodeEvt());
                  // saeTrace.setContexte();
                  saeTrace.setContrat(trace.getContrat());
                  saeTrace.setLogin(trace.getLogin());
                  // saeTrace.setStacktrace();
                  saeTrace.setTimestamp(trace.getTimestamp());
                  saeTrace.setPagms(trace.getPagms());
                  listeTraces.add(saeTrace);

               }
            }
         } else if (TraceType.TECHNIQUE.equals(type)) {

            TraceRegTechniqueDao dao = new TraceRegTechniqueDao(keyspace);
            TraceRegTechniqueIndexDao indexDao = new TraceRegTechniqueIndexDao(
                  keyspace);
            TimeUUIDEtTimestampSupport timeUUIDSupport = new TimeUUIDEtTimestampSupport();
            TraceRegTechniqueSupport support = new TraceRegTechniqueSupport(
                  dao, indexDao, timeUUIDSupport);

            RegTechniqueService service = new RegTechniqueServiceImpl(support,
                  clockSupport, loggerSupport);
            List<TraceRegTechniqueIndex> traces = service.lecture(dateDebut,
                  dateFin, taille, ordreInverse);

            if (traces != null) {
               for (TraceRegTechniqueIndex trace : traces) {
                  SaeTrace saeTrace = new SaeTrace();
                  saeTrace.setIdentifiant(trace.getIdentifiant());
                  // saeTrace.setAction();
                  saeTrace.setCodeEvt(trace.getCodeEvt());
                  saeTrace.setContexte(trace.getContexte());
                  saeTrace.setContrat(trace.getContrat());
                  saeTrace.setLogin(trace.getLogin());
                  // saeTrace.setStacktrace();
                  saeTrace.setTimestamp(trace.getTimestamp());
                  saeTrace.setPagms(trace.getPagms());
                  listeTraces.add(saeTrace);
               }
            }

         } else if (TraceType.SECURITE.equals(type)) {

            TraceRegSecuriteDao dao = new TraceRegSecuriteDao(keyspace);
            TraceRegSecuriteIndexDao indexDao = new TraceRegSecuriteIndexDao(
                  keyspace);
            TimeUUIDEtTimestampSupport timeUUIDSupport = new TimeUUIDEtTimestampSupport();
            TraceRegSecuriteSupport support = new TraceRegSecuriteSupport(dao,
                  indexDao, timeUUIDSupport);

            RegSecuriteService service = new RegSecuriteServiceImpl(support,
                  clockSupport, loggerSupport);
            List<TraceRegSecuriteIndex> traces = service.lecture(dateDebut,
                  dateFin, taille, ordreInverse);

            if (traces != null) {
               for (TraceRegSecuriteIndex trace : traces) {
                  SaeTrace saeTrace = new SaeTrace();
                  saeTrace.setIdentifiant(trace.getIdentifiant());
                  // saeTrace.setAction();
                  saeTrace.setCodeEvt(trace.getCodeEvt());
                  saeTrace.setContexte(trace.getContexte());
                  saeTrace.setContrat(trace.getContrat());
                  saeTrace.setLogin(trace.getLogin());
                  // saeTrace.setStacktrace();
                  saeTrace.setTimestamp(trace.getTimestamp());
                  saeTrace.setPagms(trace.getPagms());
                  listeTraces.add(saeTrace);
               }
            }

         } else if (TraceType.JOURNAL_EVT.equals(type)) {

            TraceJournalEvtDao dao = new TraceJournalEvtDao(keyspace);
            TraceJournalEvtIndexDao indexDao = new TraceJournalEvtIndexDao(
                  keyspace);
            TimeUUIDEtTimestampSupport timeUUIDSupport = new TimeUUIDEtTimestampSupport();
            TraceJournalEvtSupport support = new TraceJournalEvtSupport(dao,
                  indexDao, timeUUIDSupport);

            TraceFileSupport traceFileSupport = new TraceFileSupport();

            JournalEvtService service = new JournalEvtServiceImpl(support,
                  clockSupport, loggerSupport, traceFileSupport);

            List<TraceJournalEvtIndex> traces = service.lecture(dateDebut,
                  dateFin, taille, ordreInverse);
            if (traces != null) {
               for (TraceJournalEvtIndex trace : traces) {
                  SaeTrace saeTrace = new SaeTrace();
                  saeTrace.setIdentifiant(trace.getIdentifiant());
                  // saeTrace.setAction();
                  saeTrace.setCodeEvt(trace.getCodeEvt());
                  saeTrace.setContexte(trace.getContexte());
                  saeTrace.setContrat(trace.getContratService());
                  saeTrace.setLogin(trace.getLogin());
                  // saeTrace.setStacktrace();
                  saeTrace.setTimestamp(trace.getTimestamp());
                  saeTrace.setPagms(trace.getPagms());
                  listeTraces.add(saeTrace);
               }
            }
         }
     

      LOGGER.debug("{} - Sortie nb traces : {}", new String[] { prefix,
            Integer.toString(listeTraces.size()) });

      LOGGER.debug(FIN_LOG, prefix);
      return listeTraces;
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final List<String> getListeCodeEvenementByTypeTrace(String typeTrace, Keyspace keyspace) {
      TraceDestinataireDao traceDestDao = new TraceDestinataireDao(keyspace);
      TraceDestinataireSupport traceDestSupport = new TraceDestinataireSupport(traceDestDao);
      
      TraceDestinaireService traceDestService = new TraceDestinataireServiceImpl(traceDestSupport);   
      return traceDestService.getCodeEvenementByTypeTrace(typeTrace);
      
   }
   
}
