package fr.urssaf.image.sae.ihm.web.exploit.controller;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.validation.Valid;

import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucunDocumentException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.ErreurTechniqueException;
import fr.urssaf.image.sae.ihm.web.exploit.formulaire.ConsulterDocumentForm;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationEnvironnement;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationEnvironnementFrontal;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationsEnvironnement;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationsEnvironnementFrontal;
import fr.urssaf.image.sae.ihm.web.exploit.modele.Metadonnee;
import fr.urssaf.image.sae.ihm.web.exploit.modele.SaeDocument;
import fr.urssaf.image.sae.ihm.web.exploit.service.MetadonneesService;
import fr.urssaf.image.sae.ihm.web.exploit.service.RechercherService;
import fr.urssaf.image.sae.ihm.web.exploit.service.impl.MetadonneesServiceImpl;
import fr.urssaf.image.sae.metadata.referential.model.MetadataReference;
import fr.urssaf.image.sae.storage.dfce.model.StorageTechnicalMetadatas;
import me.prettyprint.hector.api.Keyspace;

/**
 * Classe centralisant les opérations utilisateurs pour la consultation d'un
 * document
 * 
 */

@SuppressWarnings("PMD.AvoidDuplicateLiterals")
@Controller
public class ConsulterDocumentController {

   /**
    * Service offrant les opérations de recherche sur un ou plusieurs documents
    */
   @Autowired
   private RechercherService rechercherService;

   /**
    * Liste des environnements disponibles pour effectuer les opérations
    */
   @Autowired
   private ConfigurationsEnvironnement environnements;

   @Autowired
   private ConfigurationsEnvironnementFrontal frontaux;

   @Autowired
   private ConfigurationsEnvironnement config;

   /**
    * Initialisation du formulaire de consultation de document
    * 
    * @param model
    *           le modèle
    * @param session
    *           la session
    * @param request
    *           la requête
    * @return la page à afficher
    * @throws InterruptedException
    *            l'exception levée
    */
   @RequestMapping(value = "consulterDocument", method = RequestMethod.GET)
   public final String initialisation(final Model model, final HttpSession session,
         final HttpServletRequest request) throws InterruptedException {

	   // Récupération du Frontal de la session
      final String frontal = (String) session.getAttribute("nomFrontal");

      // Permet d'identifier le frontal choisi
      ConfigurationEnvironnementFrontal frontalChoisie;

      // S'il n'y a pas de frontal en session, on charge le premier de la liste
      if (StringUtils.isBlank(frontal)) {
         frontalChoisie = frontaux.getConfigurationsFrontaux()[0];
      } else {
         frontalChoisie = frontaux.getConfigurationFrontal(frontal);
      }

      // Liste des noms des frontaux
      final List<String> listNomFrontaux = frontaux.getListeNoms();
      request.setAttribute("listNomFrontaux", listNomFrontaux);

      // On charge le frontal en session
      session.setAttribute("nomFrontal", frontalChoisie.getNom());

      request.setAttribute("frontal", frontalChoisie);

      // Instancie le service des m�tadonn�es dans la configuration courante
      final MetadonneesService metaService = new MetadonneesServiceImpl(session,
            config);

      // Préparation de la liste des métadonnées disponibles pour la
      // consultation
      final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
            .findMetadatasConsultables());
      request.setAttribute("listeMetaAffichage", listeMetaConsultable);
      
      final ConsulterDocumentForm form = new ConsulterDocumentForm();
      form.setFrontal(frontalChoisie.getNom());
      model.addAttribute("consultationForm", form);

      return "consulterDocument";

   }

   /**
    * Lance la consultation de document
    * 
    * @param consulterForm
    *           le formulaire de consultation
    * @param result
    *           gestion des erreurs
    * @param session
    *           la session
    * @param request
    *           la requête
    * @return la page à afficher
    */
   @RequestMapping(value = "lancerConsultDoc")
   public final String consulterDocument(
         @ModelAttribute("consultationForm") @Valid final ConsulterDocumentForm consulterForm,
         final BindingResult result, final HttpSession session, final HttpServletRequest request) {

      boolean changementFrontal;
      
      // Permet d'identifier le frontal choisi
      ConfigurationEnvironnementFrontal frontal;
      String nomFrontal = consulterForm.getFrontal();
      
      if(nomFrontal !=null &&
            !nomFrontal.equalsIgnoreCase((String) session.getAttribute("nomFrontal"))){
         changementFrontal = true;
      }else {
         changementFrontal = false;
      }
      
      if(StringUtils.isBlank(nomFrontal) && 
            StringUtils.isNotBlank((String) session.getAttribute("nomFrontal"))) {
         nomFrontal = (String) session.getAttribute("nomFrontal");
      }
      
      // S'il n'y a pas de frontal en session, on charge le premier de la liste
      if (StringUtils.isBlank(nomFrontal) ) {
         frontal = frontaux.getConfigurationsFrontaux()[0];
      } else {
         frontal = frontaux.getConfigurationFrontal(nomFrontal);
      }
      
      // Chargement de la liste des frontaux
      final List<String> listNomFrontaux = frontaux.getListeNoms();
      request.setAttribute("listNomFrontaux", listNomFrontaux);
      
      // si changement du frontal
      session.setAttribute("nomFrontal", nomFrontal);
      request.setAttribute("frontal",
            frontaux.getConfigurationFrontal(nomFrontal));
      
      
      if (!result.hasFieldErrors() || !changementFrontal) {
         try {
            SaeDocument saeDoc;
            final UUID uuid = consulterForm.getIdentifiant();
            final List<String> codesMeta = consulterForm.getCodeMeta();

//            String nomConf = (String) session.getAttribute("nomConfiguration");
//            ConfigurationEnvironnement conf = environnements
//                  .getConfiguration(nomConf);
//            String urlServiceWeb = conf.getUrlWs().toString();

            final String urlServiceWeb = frontal.getUrlWsFrontal().toString();

            // Récupération du login de l'utilisateur (pour la traçabilité)
            final String login = (String) session.getAttribute("login");

            
            // On ne lance pas la recherche suite au changement du
            // frontal ou en cas d'erreur de validation
            if(!changementFrontal && !result.hasFieldErrors()) {
            // Lancement de la consultation (on ne stocke pas le contenu du
            // document)
            saeDoc = rechercherService.consulterDocument(uuid, codesMeta,
                  urlServiceWeb, false, login);

            request.setAttribute("resRecherche", saeDoc);
            request.setAttribute("id", uuid.toString());
            }

         } catch (final ErreurTechniqueException e) {
            final ObjectError erreur = new ObjectError("consultationForm", e
                  .getMessage());
            result.addError(erreur);

            final StringWriter sw = new StringWriter();
            final PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            final String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);

         } catch (final AucunDocumentException e) {
            final ObjectError erreur = new ObjectError("consultationForm",
                  "Aucun document ne correspond � cet identifiant");
            result.addError(erreur);
         }

      }

      if(changementFrontal){
         request.setAttribute("validationForm", null);
      } else {
         request.setAttribute("validationForm", true);
      }

      // Instancie le service des métadonnées dans la configuration courante
      final MetadonneesService metaService = new MetadonneesServiceImpl(session,
            config);

      // Préparation de la liste des métadonnées disponibles pour la
      // consultation
      final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
            .findMetadatasConsultables());
      request.setAttribute("listeMetaAffichage", listeMetaConsultable);

      return "consulterDocument";
   }


   /**
    * Initialisation de la consultation de document dans la corbeille
    * @param model
    * @param session
    * @param request
    * @return
    * @throws InterruptedException
    */
   @RequestMapping(value = "consulterDocumentEnCorbeille", method = RequestMethod.GET)
   public final String initConsultDocInRecycleBin(final Model model, final HttpSession session,
         final HttpServletRequest request) throws InterruptedException {

      // Instancie le service des métadonnées dans la configuration courante
      final MetadonneesService metaService = new MetadonneesServiceImpl(session,
            config);

      // Préparation de la liste des métadonnées disponibles pour la
      // consultation
      final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
            .findMetadatasConsultables());
      
      // Enlever le GEL de la liste des métadonnées consultables dans la corbeille
      int indexGel = -1;
      for (final Metadonnee metadonnee : listeMetaConsultable) {
         if(metadonnee.getShortCode().equals(StorageTechnicalMetadatas.GEL.getShortCode())){
            indexGel = listeMetaConsultable.indexOf(metadonnee);
         }
      }
      if(indexGel > 0 ){
         listeMetaConsultable.remove(indexGel);
      }
      
      request.setAttribute("listeMetaAffichage", listeMetaConsultable);
      final ConsulterDocumentForm form = new ConsulterDocumentForm();

      model.addAttribute("consultationForm", form);

      return "consulterDocumentEnCorbeille";

   }

   /**
    * Conversion d'une liste de MetadataReference en une liste de Metadonnee
    * @param findMetadatasRecherchables
    * @return une liste de Metadonnee
    */
   private List<Metadonnee> metaReferenceToMetadonnee(
         final List<MetadataReference> findMetadatasRecherchables) {
      final List<Metadonnee> listeMetadonnee = new ArrayList<>();
      for (final MetadataReference metadataReference : findMetadatasRecherchables) {
         final Metadonnee meta = new Metadonnee();
         meta.setShortCode(metadataReference.getShortCode());
         meta.setCode(metadataReference.getLongCode());
         if (metadataReference.getIsIndexed()) {
            meta.setIndexee("Oui");
         } else {
            meta.setIndexee("Non");
         }
         meta.setLibelle(metadataReference.getLabel());
         listeMetadonnee.add(meta);
      }
      return listeMetadonnee;
   }

   
   /**
    * Permet le téléchargement du document
    * 
    * @param session
    *           la session
    * @param response
    *           la réponse
    * @param idConsult
    *           l'identifiant du document à télécharger
    * @throws AucunDocumentException
    *            Exception levée si aucun document retourné
    * @throws ErreurTechniqueException
    *            Excpetion levée si erreur technique
    * @throws IOException
    *            Exception levée lors de l'affichage du fichier
    */
   @RequestMapping(value = "telecharger")
   public final void telecharger(final HttpSession session,
         final HttpServletResponse response, final String idConsult)
               throws AucunDocumentException, ErreurTechniqueException, IOException {

      SaeDocument saeDoc;

      // Récupération de l'UUID
      final UUID uuid = UUID.fromString(idConsult);

      final List<String> codesMeta = null;

      // Récupération de l'url du webservice
      final String nomConf = (String) session.getAttribute("nomConfiguration");
      final ConfigurationEnvironnement conf = environnements
            .getConfiguration(nomConf);
      final String urlServiceWeb = conf.getUrlWs().toString();

      // Récupération du login de l'utilisateur (pour la traçabilité)
      final String login = (String) session.getAttribute("login");

      // Lancement de la consultation (on stocke le contenu du document)
      saeDoc = rechercherService.consulterDocument(uuid, codesMeta,
            urlServiceWeb, true, login);

      final List<Metadonnee> listeMeta = saeDoc.getMetadonnees();
      String nomFichier = idConsult.concat(".pdf");
      for (final Metadonnee metadonnee : listeMeta) {
         if ("NomFichier".equals(metadonnee.getCode())) {
            nomFichier = metadonnee.getValeur();
            break;
         }
      }

      // Affichage du fichier
      response.setContentType("application/pdf");
      response.setHeader("Content-Disposition", "attachment; filename=\""
            + nomFichier + "\"");

      final ServletOutputStream outputStream = response.getOutputStream();
      outputStream.write(saeDoc.getContenu());

      outputStream.flush();
      outputStream.close();

   }

   /**
    * Permet le téléchargement du document
    * 
    * @param session
    *           la session
    * @param response
    *           la réponse
    * @param idConsult
    *           l'identifiant du document à télécharger
    * @throws AucunDocumentException
    *            Exception levée si aucun document retourné
    * @throws ErreurTechniqueException
    *            Excpetion levée si erreur technique
    * @throws IOException
    *            Exception levée lors de l'affichage du fichier
    */
   @RequestMapping(value = "telechargerInRecycleBin")
   public final void telechargerInRecycleBin(final HttpSession session,
         final HttpServletResponse response, final String idConsult)
               throws AucunDocumentException, ErreurTechniqueException, IOException {

      SaeDocument saeDoc;

      final UUID uuid = UUID.fromString(idConsult);
      final List<String> codesMeta = null;

      // Récupération du nom de la cofig seléctionné
      final String nomConf = (String) session.getAttribute("nomConfiguration");
      final Keyspace keyspace = (Keyspace) session.getServletContext().getAttribute(
            nomConf);

      final DFCEConnection dfceConnection = (DFCEConnection) session
            .getServletContext().getAttribute(nomConf + "-dfce");

      // Lancement de la consultation (on stocke le contenu du document)
      saeDoc = rechercherService.consultDocInRecycleBin(uuid, codesMeta, true,
            dfceConnection, keyspace);

      final List<Metadonnee> listeMeta = saeDoc.getMetadonnees();
      String nomFichier = idConsult.concat(".pdf");
      for (final Metadonnee metadonnee : listeMeta) {
         if ("NomFichier".equals(metadonnee.getCode())) {
            nomFichier = metadonnee.getValeur();
            break;
         }
      }

      // Affichage du fichier
      response.setContentType("application/pdf");
      response.setHeader("Content-Disposition", "attachment; filename=\""
            + nomFichier + "\"");

      final ServletOutputStream outputStream = response.getOutputStream();
      outputStream.write(saeDoc.getContenu());

      outputStream.flush();
      outputStream.close();

   }

   /**
    * Action de consultation de document dans la corbeille
    * @param consulterForm
    * @param result
    * @param session
    * @param request
    * @return
    */
   @RequestMapping(value = "lancerConsultDocEnCorbeille")
   public final String consultDocInRecycleBin(
         @ModelAttribute("consultationForm") @Valid final ConsulterDocumentForm consulterForm,
         final BindingResult result, final HttpSession session, final HttpServletRequest request) {

      if (!result.hasFieldErrors()) {
         try {
            SaeDocument saeDoc;
            // Récupération de l'UUID
            final UUID uuid = consulterForm.getIdentifiant();
            // Récupération des métadonnées à afficher en retour
            final List<String> shortCodesMeta = consulterForm.getShortCodeMeta();

            // Instancie le service des métadonnées dans la configuration courante
            final MetadonneesService metaService = new MetadonneesServiceImpl(session,
                  config);            
            // Préparation de la liste des métadonnées disponibles pour la
            // consultation
            final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
                  .findMetadatasConsultables());
            
            // Enlever le GEL de la liste des métadonnées consultables dans la corbeille
            int indexGel = -1;
            for (final Metadonnee metadonnee : listeMetaConsultable) {
               if(metadonnee.getShortCode().equals(StorageTechnicalMetadatas.GEL.getShortCode())){
                  indexGel = listeMetaConsultable.indexOf(metadonnee);
               }
            }
            if(indexGel > 0 ){
               listeMetaConsultable.remove(indexGel);
            }
            
            request.setAttribute("listeMetaAffichage", listeMetaConsultable);

            // Récupération du nom de la configuration séléctionnée
            final String nomConf = (String) session.getAttribute("nomConfiguration");
            final Keyspace keyspace = (Keyspace) session.getServletContext()
                  .getAttribute(nomConf);
            
            // Récupération de la connexion DFCE
            final DFCEConnection dfceConnection = (DFCEConnection) session
                  .getServletContext().getAttribute(nomConf + "-dfce");

            saeDoc = rechercherService.consultDocInRecycleBin(uuid,
                  shortCodesMeta, false, dfceConnection, keyspace);

            final List<Metadonnee> metadataSaeDoc = getMetadonneeSaeDocByShortCodes(saeDoc.getMetadonnees(), listeMetaConsultable);

            saeDoc.setMetadonnees(metadataSaeDoc);

            request.setAttribute("resRecherche", saeDoc);
            request.setAttribute("id", uuid.toString());

         } catch (final ErreurTechniqueException e) {
            final ObjectError erreur = new ObjectError("consultationForm", e
                  .getMessage());
            result.addError(erreur);

            final StringWriter sw = new StringWriter();
            final PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            final String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);

         } catch (final AucunDocumentException e) {
            final ObjectError erreur = new ObjectError("consultationForm",
                  "Aucun document dans la corbeille ne correspond à cet identifiant");
            result.addError(erreur);
         }
      }
      return "consulterDocumentEnCorbeille";
   }

   /**
    * Mapping du shortCode par le code dans les métadonnées retournées
    * @param metadonnees
    * @param listeMetaRecherchable
    * @return
    */
   private List<Metadonnee> getMetadonneeSaeDocByShortCodes(
         final List<Metadonnee> metadonnees, final List<Metadonnee> listeMetaRecherchable) {
      for (final Metadonnee metadonnee : metadonnees) {
         for (final Metadonnee metadonneeRecherchable : listeMetaRecherchable) {
            if( metadonnee.getCode().equals(metadonneeRecherchable.getShortCode())){
               metadonnee.setCode(metadonneeRecherchable.getCode());
            }
         }
      }
      return metadonnees;
   }

}
