package fr.urssaf.image.sae.ihm.web.exploit.service.impl;

import java.io.IOException;
import java.io.InputStream;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

import javax.activation.DataHandler;

import org.apache.commons.io.IOUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import fr.urssaf.image.commons.cassandra.helper.CassandraCQLClientFactory;
import fr.urssaf.image.commons.cassandra.support.clock.JobClockConfiguration;
import fr.urssaf.image.commons.cassandra.support.clock.JobClockSupport;
import fr.urssaf.image.commons.cassandra.support.clock.impl.JobClockSupportImpl;
import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.commons.dfce.service.DFCEServices;
import fr.urssaf.image.commons.dfce.service.impl.DFCEServicesImpl;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucunDocumentException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.ErreurTechniqueException;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationBean;
import fr.urssaf.image.sae.ihm.web.exploit.modele.Metadonnee;
import fr.urssaf.image.sae.ihm.web.exploit.modele.SaeDocument;
import fr.urssaf.image.sae.ihm.web.exploit.modele.SaeDonneesRecherche;
import fr.urssaf.image.sae.ihm.web.exploit.modele.SaeResultatRecherche;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.SaeStubUtils;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.Consultation;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.ConsultationRequestType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.ConsultationResponseType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.ListeMetadonneeCodeType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.MetadonneeCodeType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.MetadonneeType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.Recherche;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.RechercheRequestType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.RechercheResponseType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.RequeteRechercheType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.ResultatRechercheType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.UuidType;
import fr.urssaf.image.sae.ihm.web.exploit.service.RechercherService;
import fr.urssaf.image.sae.ihm.web.exploit.utils.MetadonneesComparateur;
import fr.urssaf.image.sae.mapping.services.impl.MappingDocumentServiceImpl;
import fr.urssaf.image.sae.metadata.exceptions.ReferentialException;
import fr.urssaf.image.sae.metadata.referential.dao.SaeMetadataDao;
import fr.urssaf.image.sae.metadata.referential.dao.cql.IMetadataDaoCql;
import fr.urssaf.image.sae.metadata.referential.dao.cql.impl.MetadataCqlDaoImpl;
import fr.urssaf.image.sae.metadata.referential.services.MetadataReferenceDAO;
import fr.urssaf.image.sae.metadata.referential.services.impl.MetadataReferenceDAOImpl;
import fr.urssaf.image.sae.metadata.referential.support.SaeMetadataSupport;
import fr.urssaf.image.sae.metadata.referential.support.cql.SaeMetadataCqlSupport;
import fr.urssaf.image.sae.metadata.referential.support.facade.SaeMetadataSupportFacade;
import fr.urssaf.image.sae.storage.dfce.services.impl.storagedocument.RecycleBinServiceImpl;
import fr.urssaf.image.sae.storage.dfce.services.impl.storagedocument.crud.SearchingServiceImpl;
import fr.urssaf.image.sae.storage.dfce.support.StorageDocumentServiceSupport;
import fr.urssaf.image.sae.storage.dfce.support.TracesDfceSupport;
import fr.urssaf.image.sae.storage.exception.RecycleBinServiceEx;
import fr.urssaf.image.sae.storage.exception.StorageException;
import fr.urssaf.image.sae.storage.model.storagedocument.PaginatedStorageDocuments;
import fr.urssaf.image.sae.storage.model.storagedocument.StorageDocument;
import fr.urssaf.image.sae.storage.model.storagedocument.StorageMetadata;
import fr.urssaf.image.sae.storage.model.storagedocument.searchcriteria.PaginatedLuceneCriteria;
import fr.urssaf.image.sae.storage.model.storagedocument.searchcriteria.UUIDCriteria;
import fr.urssaf.image.sae.trace.service.DispatcheurService;
import fr.urssaf.image.sae.trace.service.impl.DispatcheurServiceImpl;
import me.prettyprint.hector.api.Keyspace;

/**
 * Classe implémentant le service Rechercher Service Ce service permet de
 * réaliser des opérations de recherche sur un ou plusieurs document
 *
 */
@Component
public class RechercherServiceImpl implements RechercherService {

  private final SaeStubUtils saeStubUtils;

  private RecycleBinServiceImpl recycleBinService;

  private SearchingServiceImpl searchingService;

  private final ConfigurationBean configurationBean;

  private CassandraCQLClientFactory ccf;

  @Autowired
  public RechercherServiceImpl(final SaeStubUtils saeStubUtils,
                               final ConfigurationBean configurationBean) {
    this.saeStubUtils = saeStubUtils;
    this.configurationBean = configurationBean;

  }

  /**
   * @param ccf
   *          the ccf to set
   */
  @Override
  public void setCcf(final CassandraCQLClientFactory ccf) {
    this.ccf = ccf;
  }
  /**
   * Renvoie la liste des documents satisfaisants à la requête lucène passée en
   * paramètre
   *
   * @param requeteLucene
   *           Requête permettant de déterminer quels sont les documents à
   *           renvoyer
   * @param codes
   *           Liste des codes de métadonnées voulues à l'affichage
   * @param urlServiceWeb
   *           l'url du web service de la configuration choisie
   * @param login
   *           login de l'utilisateur (pour la traçabilité)
   * @return Informations sur les documents satisfaisant à la requête lucène
   *
   * @throws ErreurTechniqueException
   *            Exception levée lors d'une erreur technique
   * @throws AucunDocumentException
   *            Exception levée lorsque la recherche ne renvoie aucun document
   */
  @Override
  public final SaeResultatRecherche rechercherDocuments(final String requeteLucene,
                                                        final List<String> codes, final String urlServiceWeb, final String login)
                                                            throws ErreurTechniqueException, AucunDocumentException {

    // Récupération du stub
    final SaeServiceStub stub = saeStubUtils.getStub(urlServiceWeb, login);

    // Création de la requête de recherche
    final RechercheRequestType requestType = creationRequeteRecherche(
                                                                      requeteLucene, codes);

    // Lancement de la recherche
    try {
      RechercheResponseType reponse;
      reponse = appelWSRecherche(stub, requestType);

      final ResultatRechercheType[] resultats = reponse.getResultats()
          .getResultat();

      // Exception si aucun résultat
      if (resultats == null || resultats.length == 0) {
        throw new AucunDocumentException();
      }

      // Résultat tronqué ?
      final boolean tronque = reponse.getResultatTronque();

      // Conversion du résultat en objet SaeDonneesRecherche
      final List<SaeDonneesRecherche> listeDonneesRech = convertToSdr(resultats);
      return new SaeResultatRecherche(listeDonneesRech, tronque);

    } catch (final RemoteException e) {
      throw new ErreurTechniqueException(e);
    }
  }

  /**
   * Renvoie la lsite de documents depuis la corbeille satisfaisant la requête passée en paramètre
   */
  @Override
  public final SaeResultatRecherche getDocsFromRecycleBin(
                                                          final DFCEConnection dfceConnection, final String requeteLucene,
                                                          final List<String> codes, final int nbrRes, final Keyspace keyspace)
                                                              throws ReferentialException, StorageException, IOException,
                                                              AucunDocumentException {

    SaeResultatRecherche resultatRecherche = null;

    boolean resultatTronquee = false;
    final List<StorageMetadata> desiredStorageMetadatas = new ArrayList<>();
    StorageMetadata metadata = null;

    if (codes != null && codes.size() > 0) {
      for (final String code : codes) {
        metadata = new StorageMetadata(code);
        desiredStorageMetadatas.add(metadata);
      }
    }

    final PaginatedLuceneCriteria paginatedLuceneCriteria = new PaginatedLuceneCriteria(
                                                                                        requeteLucene,
                                                                                        nbrRes,
                                                                                        desiredStorageMetadatas,
                                                                                        null,
                                                                                        null);

    initSearchingService(openConnectionService(dfceConnection), keyspace);
    final PaginatedStorageDocuments strDocuments = searchingService
        .searchStorageDocumentsInRecycleBean(
                                             paginatedLuceneCriteria);

    // Conversion
    final List<SaeDonneesRecherche> resultats = convertToSaeDonneeRechercheList(strDocuments);

    // Exception si aucun résultat
    if (resultats == null || resultats.size() == 0) {
      throw new AucunDocumentException();
    }

    if (resultats.size() > nbrRes) {
      resultatTronquee = true;
    }
    resultatRecherche = new SaeResultatRecherche(resultats, resultatTronquee);

    return resultatRecherche;

  }

  /**
   * Permet de convertir le résultat de recherche passée en paramètre en une liste de SaeDonneesRecherche
   * @param strDocuments
   * @return une liste de SaeDonneesRecherche
   */
  private List<SaeDonneesRecherche> convertToSaeDonneeRechercheList(
                                                                    final PaginatedStorageDocuments strDocuments) {

    final List<SaeDonneesRecherche> donneeRechercheList = new ArrayList<>();
    SaeDonneesRecherche donneeRecherche = null;

    for (final StorageDocument strDoc : strDocuments.getAllStorageDocuments()) {
      donneeRecherche = new SaeDonneesRecherche(
                                                convertToMetaDonneeList(strDoc.getMetadatas()), strDoc.getUuid());
      donneeRechercheList.add(donneeRecherche);
    }

    return donneeRechercheList;
  }

  /**
   * Permet de retourner une liste de MetaDonnee à partir d'une liste de
   * StorageMetaData
   *
   * @param metadatas
   * @return
   */
  private List<Metadonnee> convertToMetaDonneeList(
                                                   final List<StorageMetadata> storageMetadatas) {

    final List<Metadonnee> metaDonneeList = new ArrayList<>();
    Metadonnee metaDonnee = null;

    for (final StorageMetadata storageMetadata : storageMetadatas) {
      metaDonnee = new Metadonnee(storageMetadata.getShortCode(),
                                  storageMetadata.getValue().toString(), null);
      metaDonneeList.add(metaDonnee);
    }

    return metaDonneeList;
  }

  /**
   * Renvoie le document associé à l'uuid passé en paramètre
   *
   * @param uuid
   *           Identifiant unique du document à chercher
   * @param codes
   *           Liste des codes de métadonnées voulues à l'affichage
   * @param urlServiceWeb
   *           l'url du service web de la configuration choisie
   * @param avecContenu
   *           indique si on récupère le contenu du document ou juste les
   *           métadonnées
   * @param login
   *           login de l'utilisateur (pour la traçabilité)
   * @return Document recherché
   *
   * @throws AucunDocumentException
   *            Exception levée lorsqu'aucun document n'est trouvé
   * @throws ErreurTechniqueException
   *            Exception levée lors d'une erreur technique
   */
  @Override
  public final SaeDocument consulterDocument(final UUID uuid, final List<String> codes,
                                             final String urlServiceWeb, final boolean avecContenu, final String login)
                                                 throws AucunDocumentException, ErreurTechniqueException {

    // Récupération du Stub
    final SaeServiceStub stub = saeStubUtils.getStub(urlServiceWeb, login);

    // Création de la requête de consultation
    final ConsultationRequestType consultRequestType = creationRequeteConsult(uuid,
                                                                              codes);

    try {
      // Lancement de la consultation
      final ConsultationResponseType resultat = appelWSConsultation(stub,
                                                                    consultRequestType);

      // Exception si aucun résultat
      if (resultat == null) {
        throw new AucunDocumentException();
      }

      // Conversion du résultat en SaeDocument
      return convertToSD(resultat, avecContenu);

    } catch (final ErreurTechniqueException e) {
      throw new ErreurTechniqueException(e);
    } catch (final RemoteException e) {
      //throw new AucunDocumentException(e.getMessage());
      throw new ErreurTechniqueException(e);
    }
  }

  /**
   * Permet de consulter le document depuis la corbeille à partir de son uuid passé en paramètre
   */
  @Override
  public final SaeDocument consultDocInRecycleBin(final UUID uuid,
                                                  final List<String> codes, final boolean avecContenu,
                                                  final DFCEConnection dfceConnection, final Keyspace keyspace)
                                                      throws AucunDocumentException, ErreurTechniqueException {

    // constitue la liste des métadonnées du document à retourner
    List<StorageMetadata> metadatasStorageDoc = new ArrayList<>();

    List<StorageMetadata> desiredStorageMetadatas = null;
    StorageMetadata metadata = null;

    if (codes != null && codes.size() > 0) {
      desiredStorageMetadatas = new ArrayList<>();
      for (final String code : codes) {
        metadata = new StorageMetadata(code);
        desiredStorageMetadatas.add(metadata);
      }
    }

    final UUIDCriteria uuidCriteria = new UUIDCriteria(uuid,
                                                       desiredStorageMetadatas);
    try {

      initRecycleBinService(openConnectionService(dfceConnection), keyspace);

      final StorageDocument doc = recycleBinService
          .getStorageDocumentFromRecycleBin(uuidCriteria, avecContenu);

      // Exception si aucun résultat
      if (doc.getMetadatas() == null
          || doc.getMetadatas() != null && doc.getMetadatas().isEmpty()) {
        throw new AucunDocumentException();
      }

      metadatasStorageDoc = doc.getMetadatas();

      if (avecContenu && doc.getContent() != null) {
        try {
          final DataHandler data = doc.getContent();
          InputStream inStream;
          inStream = data.getInputStream();
          final byte[] contenu = IOUtils.toByteArray(inStream);
          inStream.close();
          return new SaeDocument(
                                 convertToMetaDonneeList(metadatasStorageDoc), contenu);
        } catch (final IOException e) {
          throw new ErreurTechniqueException(e);
        }
      }

      return new SaeDocument(convertToMetaDonneeList(metadatasStorageDoc) , null);

    } catch (final RecycleBinServiceEx frozenExcept) {
      throw new ErreurTechniqueException(frozenExcept);
    }  catch (final StorageException e) {
      throw new ErreurTechniqueException(e);
    } catch (final IOException e) {
      throw new ErreurTechniqueException(e);
    } finally {
    }

  }

  /**
   * Création requete pour l'appel WS de recherche
   *
   * @param requeteLucene
   *           la requête lucène souhaitée pour la recherche
   * @param codes
   *           les codes des métadonnées à retourner par la recherche
   */
  private RechercheRequestType creationRequeteRecherche(final String requeteLucene,
                                                        final List<String> codes) {

    final RechercheRequestType requestType = new RechercheRequestType();

    // Requête Lucène
    final RequeteRechercheType requete = new RequeteRechercheType();
    requete.setRequeteRechercheType(requeteLucene);
    requestType.setRequete(requete);

    // Métadonnées à afficher en retour
    MetadonneeCodeType[] tabMetaCodeType = null;
    if (codes != null) {
      tabMetaCodeType = new MetadonneeCodeType[codes.size()];
      int index = 0;
      for (final String codeMeta : codes) {
        final MetadonneeCodeType metaCodeType = new MetadonneeCodeType();
        metaCodeType.setMetadonneeCodeType(codeMeta);
        tabMetaCodeType[index] = metaCodeType;
        index++;
      }
    }
    final ListeMetadonneeCodeType listeMeta = new ListeMetadonneeCodeType();
    listeMeta.setMetadonneeCode(tabMetaCodeType);
    requestType.setMetadonnees(listeMeta);

    return requestType;
  }

  /**
   * Appel au WS de recherche
   *
   * @param stub
   * @param requestType
   *           la requête contenant la requete lucene et les métadonnées
   * @throws RemoteException
   */
  private RechercheResponseType appelWSRecherche(final SaeServiceStub stub,
                                                 final RechercheRequestType requestType) throws RemoteException {
    final Recherche recherche = new Recherche();
    recherche.setRecherche(requestType);
    return stub.recherche(recherche).getRechercheResponse();
  }

  /**
   * Permet de convertir le résultat de recherche
   */
  private List<SaeDonneesRecherche> convertToSdr(
                                                 final ResultatRechercheType[] resultats) {
    final List<SaeDonneesRecherche> listeDonneesRech = new ArrayList<>();
    for (final ResultatRechercheType resRechType : resultats) {

      final MetadonneeType[] metaType = resRechType.getMetadonnees()
          .getMetadonnee();

      final List<Metadonnee> metadonnees = new ArrayList<>();
      for (final MetadonneeType element : metaType) {
        final Metadonnee meta = new Metadonnee(element.getCode()
                                               .getMetadonneeCodeType(), element.getValeur()
                                               .getMetadonneeValeurType(), "");
        metadonnees.add(meta);
      }

      final String idArchivage = resRechType.getIdArchive().getUuidType();
      final UUID uuid = UUID.fromString(idArchivage);

      // Tri des métadonnées par ordre alphabétique du code
      Collections.sort(metadonnees, new MetadonneesComparateur());

      final SaeDonneesRecherche sdr = new SaeDonneesRecherche(metadonnees, uuid);
      listeDonneesRech.add(sdr);
    }
    return listeDonneesRech;
  }

  /**
   * Création de la requete de consultation
   *
   * @param uuid
   *           uuid du document à consulter
   * @param codes
   *           liste des métadonnées à retourner par la consultation
   * @return
   */
  private ConsultationRequestType creationRequeteConsult(final UUID uuid,
                                                         final List<String> codes) {
    final ConsultationRequestType consultRequestType = new ConsultationRequestType();

    // UUID
    final UuidType uuidType = new UuidType();
    uuidType.setUuidType(uuid.toString());
    consultRequestType.setIdArchive(uuidType);

    // Métadonnées à afficher en retour
    if (codes != null && !codes.isEmpty()) {// EC && !codes.isEmpty()
      final MetadonneeCodeType[] tabMetaCodeType = new MetadonneeCodeType[codes
                                                                          .size()];
      int index = 0;
      for (final String codeMeta : codes) {
        final MetadonneeCodeType metaCodeType = new MetadonneeCodeType();
        metaCodeType.setMetadonneeCodeType(codeMeta);
        tabMetaCodeType[index] = metaCodeType;
        index++;
      }
      final ListeMetadonneeCodeType listeMeta = new ListeMetadonneeCodeType();
      listeMeta.setMetadonneeCode(tabMetaCodeType);
      consultRequestType.setMetadonnees(listeMeta);
    }

    return consultRequestType;
  }

  /**
   * Appel au WS de consultation
   *
   * @param stub
   * @param ConsultationRequestType
   *           la requête contenant l'uuid et les métadonnées
   * @throws RemoteException
   */
  private ConsultationResponseType appelWSConsultation(final SaeServiceStub stub,
                                                       final ConsultationRequestType consultRequestType) throws RemoteException {

    final Consultation consultation = new Consultation();
    consultation.setConsultation(consultRequestType);
    return stub.consultation(consultation).getConsultationResponse();
  }

  private SaeDocument convertToSD(final ConsultationResponseType resultat,
                                  final boolean avecContenu) throws ErreurTechniqueException {
    // Métadonnées retournée
    final MetadonneeType[] metaType = resultat.getMetadonnees().getMetadonnee();
    final List<Metadonnee> metadonnees = new ArrayList<>();
    for (final MetadonneeType element : metaType) {
      final Metadonnee meta = new Metadonnee(element.getCode()
                                             .getMetadonneeCodeType(), element.getValeur()
                                             .getMetadonneeValeurType(), "");
      metadonnees.add(meta);
    }
    // Tri des métadonnées par ordre alphabétique du code
    Collections.sort(metadonnees, new MetadonneesComparateur());

    if (avecContenu) {
      try {
        final DataHandler data = resultat.getObjetNumerique()
            .getObjetNumeriqueConsultationTypeChoice_type0().getContenu();
        InputStream inStream;
        inStream = data.getInputStream();
        final byte[] contenu = IOUtils.toByteArray(inStream);
        inStream.close();
        return new SaeDocument(metadonnees, contenu);
      } catch (final IOException e) {
        throw new ErreurTechniqueException(e);
      }
    } else {
      return new SaeDocument(metadonnees, null);
    }
  }

  /**
   * Méthode permettant d'ouvrir la connection vers DFCe
   *
   * @param dfceConnection
   *           connection DFCe
   * @return le service de connection vers DFCe
   */
  private DFCEServices openConnectionService(final DFCEConnection dfceConnection) {
    // Initialisation du service de connection vers DFCe
    final DFCEServices dfceServices = new DFCEServicesImpl(dfceConnection);
    dfceServices.connectTheFistTime();
    return dfceServices;
  }

  /**
   * Méthode permettant d'initialiser le service de gestion de la corbeille
   *
   * @param dfceService
   *           Service de connection vers DFCe
   * @param dfceConnection
   */
  private void initRecycleBinService(final DFCEServices dfceServices, final Keyspace keyspace) {

    // Instantiation du JobClockSupport
    final JobClockConfiguration clock = new JobClockConfiguration();
    clock.setMaxTimeSynchroError(10000000);
    clock.setMaxTimeSynchroWarn(2000000);
    final JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
                                                                    clock);

    final DispatcheurService dispatcheur = new DispatcheurServiceImpl(jobClockSupport, null, null, null, null, null,
                                                                      null, null, null, null, null, null, null);
    final TracesDfceSupport tracesSupport = new TracesDfceSupport(dispatcheur);
    final StorageDocumentServiceSupport storageDocumentServiceSupport = new StorageDocumentServiceSupport();
    recycleBinService = new RecycleBinServiceImpl();
    recycleBinService.setDfceServices(dfceServices);
    recycleBinService.setStorageDocumentServiceSupport(storageDocumentServiceSupport);
    recycleBinService.setTracesSupport(tracesSupport);
  }

  /**
   *
   * Methode permettant d'initialiser le service de recherche dans la corbeille
   *
   * @param dfceServices
   *           Service de connection vers DFCe
   * @param keyspace
   */

  private void initSearchingService(final DFCEServices dfceServices, final Keyspace keyspace) {

    final JobClockConfiguration clock = new JobClockConfiguration();
    clock.setMaxTimeSynchroError(10000000);
    clock.setMaxTimeSynchroWarn(2000000);
    final JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
                                                                    clock);

    // Instantiation du SaeMetadataDao
    final SaeMetadataDao metaDao = new SaeMetadataDao(keyspace);

    // Instantiation du SaeMetadataSupport
    final SaeMetadataSupport saeMetadataSupport = new SaeMetadataSupport(metaDao);

    //Instanciation du SaeMetadataSupport
    final IMetadataDaoCql metadataDaoCql = new MetadataCqlDaoImpl(ccf);
    final SaeMetadataCqlSupport saeMetadataCqlSupport = new SaeMetadataCqlSupport(metadataDaoCql);
    //Instanciation du SaeMetadataSupport
    final SaeMetadataSupportFacade saeMetadataSupportFacade = new SaeMetadataSupportFacade(saeMetadataSupport, saeMetadataCqlSupport, jobClockSupport);

    final MetadataReferenceDAO metaRefDao = new MetadataReferenceDAOImpl(
                                                                         configurationBean.getMetadataCache(),

                                                                         configurationBean.isMetadataInitCacheOnStartup(),
                                                                         saeMetadataSupportFacade);

    final MappingDocumentServiceImpl mappingService = new MappingDocumentServiceImpl(metaRefDao);// EC
    // mappingService.setReferenceDAO(metaRefDao);
    final StorageDocumentServiceSupport storageDocumentServiceSupport = new StorageDocumentServiceSupport();

    searchingService = new SearchingServiceImpl();
    searchingService.setDfceServices(dfceServices);
    searchingService.setReferenceDAO(metaRefDao);
    searchingService.setMappingService(mappingService);
    searchingService
    .setStorageDocumentServiceSupport(storageDocumentServiceSupport);
  }

}
