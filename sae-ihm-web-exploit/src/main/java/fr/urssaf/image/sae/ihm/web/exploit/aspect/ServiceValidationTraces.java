package fr.urssaf.image.sae.ihm.web.exploit.aspect;

import java.util.Date;
import java.util.UUID;

import me.prettyprint.hector.api.Keyspace;

import org.apache.commons.lang.StringUtils;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.sae.trace.model.TraceType;

/**
 * Classe de validation
 * 
 * 
 */
@Aspect
public class ServiceValidationTraces {

   private static final String LECTURE_TRACES_SAE_PAR_DATES = "execution(java.util.List<fr.urssaf.image.sae.ihm.web.exploit.modele.SaeTrace> "
         + "fr.urssaf.image.sae.ihm.web.exploit.service.TraceService.lectureTracesSaeParDates(*,*,*,*,*,*))"
         + "&& args(type, dateDebut, dateFin, taille, ordreInverse, keyspace)";

   private static final String LECTURE_TRACES_DFCE_PAR_DATES = "execution(java.util.List<fr.urssaf.image.sae.ihm.web.exploit.modele.DfceTrace> "
         + "fr.urssaf.image.sae.ihm.web.exploit.service.TraceService.lectureTracesDfceParDates(*,*,*,*,*,*))"
         + "&& args(type, dateDebut, dateFin, taille, ordreInverse, dfceConnection)";

   private static final String LECTURE_TRACES_DFCE_PAR_DOCUUID = "execution(java.util.List<fr.urssaf.image.sae.ihm.web.exploit.modele.DfceTrace> "
         + "fr.urssaf.image.sae.ihm.web.exploit.service.TraceService.lectureTracesDfceParDocUuid(*,*,*))"
         + "&& args(type, uuid, dfceConnection)";

   private static final String LECTURE_TRACES_SAE_PAR_UUID = "execution(fr.urssaf.image.sae.ihm.web.exploit.modele.SaeTrace "
         + "fr.urssaf.image.sae.ihm.web.exploit.service.TraceService.lectureTraceSaeParUuid(*,*,*))"
         + "&& args(type, uuid, keyspace)";

   private static final String LECTURE_TRACES_DFCE_PAR_UUID = "execution(fr.urssaf.image.sae.ihm.web.exploit.modele.DfceTrace "
         + "fr.urssaf.image.sae.ihm.web.exploit.service.TraceService.lectureTraceDfceParUuid(*,*,*))"
         + "&& args(type, uuid, dfceConnection)";

   /**
    * Vérification des arguments de la méthode lectureTracesSaeParDates
    * 
    * @param type
    *           Type de la trace à récupérer
    * @param dateDebut
    *           Date de début de l'intervalle
    * @param dateFin
    *           Date de fin de l'intervalle
    * @param taille
    *           Taille de la liste à retourner
    * @param ordreInverse Récupération des résultats dans l'ordre inverse          
    * @param keyspace
    *           Keyspace de la configuration choisie
    */
   @Before(LECTURE_TRACES_SAE_PAR_DATES)
   public final void validationArgLectureTracesSaeParDates(TraceType type,
         Date dateDebut, Date dateFin, int taille, boolean ordreInverse,
         Keyspace keyspace) {

      if (type == null) {
         throw new IllegalArgumentException("l'argument type n'est pas valide");
      }

      if (dateDebut == null) {
         throw new IllegalArgumentException(
               "l'argument dateDebut n'est pas valide");
      }

      if (dateFin == null) {
         throw new IllegalArgumentException(
               "l'argument dateFin n'est pas valide");
      }

      if (keyspace == null) {
         throw new IllegalArgumentException(
               "l'argument keyspace n'est pas valide");
      }
   }

   /**
    * Vérification des arguments de la méthode lectureTracesDfceParDates
    * 
    * @param type
    *           Type de la trace à récupérer
    * @param dateDebut
    *           Date de début de l'intervalle
    * @param dateFin
    *           Date de fin de l'intervalle
    * @param taille
    *           Taille de la liste à retourner
    * @param ordreInverse Récupération des résultats dans l'ordre inverse          
    * @param dfceConnection
    *           Paramètres de connexion à DFCE
    */
   @Before(LECTURE_TRACES_DFCE_PAR_DATES)
   public final void validationArgLectureTracesDfceParDates(TraceType type,
         Date dateDebut, Date dateFin, int taille, Boolean ordreInverse,
         DFCEConnection dfceConnection) {

      if (type == null) {
         throw new IllegalArgumentException("l'argument type n'est pas valide");
      }

      if (dateDebut == null) {
         throw new IllegalArgumentException(
               "l'argument dateDebut n'est pas valide");
      }

      if (dateFin == null) {
         throw new IllegalArgumentException(
               "l'argument dateFin n'est pas valide");
      }

      if (taille <= 0) {
         throw new IllegalArgumentException(
               "l'argument taille n'est pas valide");
      }

      if (dfceConnection == null) {
         throw new IllegalArgumentException(
               "l'argument dfceConnection n'est pas valide");
      } else {
         if (dfceConnection.getLogin() == null) {
            throw new IllegalArgumentException(
            "l'argument dfceConnection n'est pas valide (Login non renseigné)");
         }
         if (dfceConnection.getPassword() == null) {
            throw new IllegalArgumentException(
            "l'argument dfceConnection n'est pas valide (Password non renseigné)");
         }
         if (dfceConnection.getServerUrl() == null) {
            throw new IllegalArgumentException(
            "l'argument dfceConnection n'est pas valide (URL serveur non renseignée)");
         }
      }
      
   }

   /**
    * 
    * Vérification des arguments de la méthode lectureTracesDfceParDocUuid
    * 
    * @param type
    *           Type de la trace à récupérer
    * @param uuid
    *           Identifiant unique de la trace
    * @param dfceConnection
    *           Paramètres de connexion à DFCE
    */
   @Before(LECTURE_TRACES_DFCE_PAR_DOCUUID)
   public final void validationArgLectureTracesDfceParDocUuid(TraceType type,
         UUID uuid, DFCEConnection dfceConnection) {

      if (type == null) {
         throw new IllegalArgumentException("l'argument type n'est pas valide");
      }

      if (uuid == null) {
         throw new IllegalArgumentException("l'argument uuid n'est pas valide");
      } else if (StringUtils.isBlank(uuid.toString())) {
         throw new IllegalArgumentException("l'argument uuid n'est pas valide");
      }

      if (dfceConnection == null) {
         throw new IllegalArgumentException(
               "l'argument dfceConnection n'est pas valide");
      } else {
         if (dfceConnection.getLogin() == null) {
            throw new IllegalArgumentException(
            "l'argument dfceConnection n'est pas valide (Login non renseigné)");
         }
         if (dfceConnection.getPassword() == null) {
            throw new IllegalArgumentException(
            "l'argument dfceConnection n'est pas valide (Password non renseigné)");
         }
         if (dfceConnection.getServerUrl() == null) {
            throw new IllegalArgumentException(
            "l'argument dfceConnection n'est pas valide (URL serveur non renseignée)");
         }
      }
   }

   /**
    * Vérification des arguments de la méthode lectureTraceSaeParUuid
    * 
    * @param type
    *           Type de la trace à récupérer
    * @param uuid
    *           Identifiant unique de la trace
    * @param keyspace
    *           Keyspace de la configuration choisie
    */
   @Before(LECTURE_TRACES_SAE_PAR_UUID)
   public final void validationArgLectureTraceSaeParUuid(TraceType type,
         UUID uuid, Keyspace keyspace) {

      if (type == null) {
         throw new IllegalArgumentException("l'argument type n'est pas valide");
      }

      if (uuid == null) {
         throw new IllegalArgumentException("l'argument uuid n'est pas valide");
      } else if (StringUtils.isBlank(uuid.toString())) {
         throw new IllegalArgumentException("l'argument uuid n'est pas valide");
      }

      if (keyspace == null) {
         throw new IllegalArgumentException(
               "l'argument keyspace n'est pas valide");
      }
   }

   /**
    * Vérification des arguments de la méthode lectureTraceDfceParUuid
    * 
    * @param type
    *           Type de la trace à récupérer
    * @param uuid
    *           Identifiant unique de la trace
    * @param dfceConnection
    *           Paramètres de connexion à DFCE
    */
   @Before(LECTURE_TRACES_DFCE_PAR_UUID)
   public final void validationArgLectureTraceDfceParUuid(TraceType type,
         UUID uuid, DFCEConnection dfceConnection) {

      if (type == null) {
         throw new IllegalArgumentException("l'argument type n'est pas valide");
      }

      if (uuid == null) {
         throw new IllegalArgumentException("l'argument uuid n'est pas valide");
      } else if (StringUtils.isBlank(uuid.toString())) {
         throw new IllegalArgumentException("l'argument uuid n'est pas valide");
      }

      if (dfceConnection == null) {
         throw new IllegalArgumentException(
               "l'argument dfceConnection n'est pas valide");
      } else {
         if (dfceConnection.getLogin() == null) {
            throw new IllegalArgumentException(
            "l'argument dfceConnection n'est pas valide (Login non renseigné)");
         }
         if (dfceConnection.getPassword() == null) {
            throw new IllegalArgumentException(
            "l'argument dfceConnection n'est pas valide (Password non renseigné)");
         }
         if (dfceConnection.getServerUrl() == null) {
            throw new IllegalArgumentException(
            "l'argument dfceConnection n'est pas valide (URL serveur non renseignée)");
         }
      }
   }
}
