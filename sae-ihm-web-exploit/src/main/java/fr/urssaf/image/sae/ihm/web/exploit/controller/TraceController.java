package fr.urssaf.image.sae.ihm.web.exploit.controller;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import javax.validation.Valid;

import me.prettyprint.hector.api.Keyspace;

import org.apache.commons.lang.time.DateUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import org.apache.curator.framework.CuratorFramework;

import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucuneTraceException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.ErreurTechniqueException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.TraceException;
import fr.urssaf.image.sae.ihm.web.exploit.formulaire.ConsulterTracesForm;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationsEnvironnement;
import fr.urssaf.image.sae.ihm.web.exploit.modele.DfceTrace;
import fr.urssaf.image.sae.ihm.web.exploit.modele.SaeTrace;
import fr.urssaf.image.sae.ihm.web.exploit.service.ContratServiceService;
import fr.urssaf.image.sae.ihm.web.exploit.service.TraceService;
import fr.urssaf.image.sae.ihm.web.exploit.service.impl.ContratServiceServiceImpl;
import fr.urssaf.image.sae.trace.model.TraceType;

/**
 * Classe permettant de gérer les traces
 * 
 * 
 */
@Controller
public class TraceController {

   /**
    * Interface permettant de réaliser les opérations sur les traces
    */
   @Autowired
   private TraceService traceService;

   @Autowired
   private ConfigurationsEnvironnement config;

   private static final String NOM_FORMULAIRE = "traceForm";
   private static final int MINUIT = 24;
   private static final int HEURE_MAX = 23;
   private static final int MINUTE_MAX = 59;

   private static final String DOC_UUID = "docUuid";
   private static final String DATE_EVT = "dateEvt";
   private static final String TYPE_EVT = "typeEvt";
   private static final String LOGIN = "login";
   private static final String ATTRIBUTS = "attributs";
   private static final String ACTION = "action";
   private static final String CODE_EVT = "codeEvt";
   private static final String CONTRAT = "contrat";
   private static final String TIMESTAMP = "timestamp";
   private static final String PAGMS = "pagms";
   private static final String CONTEXTE = "contexte";
   private static final String STACKTRACE = "stacktrace";
   private static final String INFOS = "infos";

   private static final String REG_TECHNIQUE = "REG_TECHNIQUE";
   private static final String JOURN_EVT = "JOURN_EVT";

   private static final int MAX_CODE_CLIENT = 200;

   // Nombre de ligne à afficher dans le tableau de résultats
   private static final int NB_LIGNE_TABLEAU = 100;

   /**
    * Initialisation de l'écran de recherche des traces
    * 
    * @param model
    *           le modèle
    * @param session
    *           la session
    * @param request
    *           la requête
    * @return la page à afficher
    * @throws InterruptedException
    *            Exception
    */
   @RequestMapping(value = "consulterTraces", method = RequestMethod.GET)
   public final String initialisation(Model model, HttpSession session,
         HttpServletRequest request) throws InterruptedException {

      ConsulterTracesForm form = new ConsulterTracesForm();
      // Recherche par dates par défaut
      form.setModeRecherche("parDates");
      // Ordre inversé par défaut
      form.setOrdreInverse(true);

      Date dateDebut = new Date();
      Date dateFin = new Date();
      form.setDateDebut(dateDebut);
      form.setDateFin(dateFin);

      form.setHeureDebut("00");
      form.setMinuteDebut("00");
      form.setHeureFin("24");
      form.setMinuteFin("00");

      // Nombre de ligne max du tableau de résultat
      if (form.getNbLignesTableau() == 0) {
         form.setNbLignesTableau(NB_LIGNE_TABLEAU);
         request.setAttribute("nbLignesTableau", NB_LIGNE_TABLEAU);
      } else {
         request.setAttribute("nbLignesTableau", form.getNbLignesTableau());
      }

      // Récupération de la configuration choisie
      String nomConf = (String) session.getAttribute("nomConfiguration");
      Keyspace keyspace = (Keyspace) session.getServletContext().getAttribute(
            nomConf);

      CuratorFramework curator = (CuratorFramework) session.getServletContext()
            .getAttribute(nomConf + "-zookeeper");
      ContratServiceService csService = new ContratServiceServiceImpl(keyspace,
            config.getConfiguration(nomConf), curator);

      List<String> codeEvtRegTechnique = traceService
            .getListeCodeEvenementByTypeTrace(REG_TECHNIQUE, keyspace);
      Collections.sort(codeEvtRegTechnique);
      session.setAttribute("codeEvtRegTechnique", codeEvtRegTechnique);

      List<String> codeEvtJournalEvt = traceService
            .getListeCodeEvenementByTypeTrace(JOURN_EVT, keyspace);
      Collections.sort(codeEvtJournalEvt);
      session.setAttribute("codeEvtJournalEvt", codeEvtJournalEvt);

      List<String> contratService = csService
            .findAllCodeClientCs(MAX_CODE_CLIENT);
      session.setAttribute("contratService", contratService);

      model.addAttribute(NOM_FORMULAIRE, form);

      return "consulterTraces";

   }

   /**
    * Lancement de la recherche des traces
    * 
    * @param traceForm
    *           Le formulaire
    * @param result
    *           Gestion des erreurs
    * @param session
    *           La session
    * @param request
    *           La requête
    * @return La page à afficher
    */
   @RequestMapping(value = "lancerConsultTrace")
   public final String rechercherTraces(
         @ModelAttribute(NOM_FORMULAIRE) @Valid ConsulterTracesForm traceForm,
         BindingResult result, HttpSession session, HttpServletRequest request) {

      if (!result.hasFieldErrors()) {

         try {
            // Récupération de l'uuid du document
            UUID uuid = traceForm.getIdDoc();
            // Récupération de la date de début
            Date dateDebutTmp = traceForm.getDateDebut();
            // Récupération de la date de fin
            Date dateFinTmp = traceForm.getDateFin();
            // Récupération heure de début
            String heureDebut = traceForm.getHeureDebut();
            String minuteDebut = traceForm.getMinuteDebut();
            // Récupération heure de fin
            String heureFin = traceForm.getHeureFin();
            String minuteFin = traceForm.getMinuteFin();

            // Récupération du nombre de résultats à retourner
            int taille = traceForm.getTaille();
            // Récupération de l'ordre des traces
            boolean ordreInverse = traceForm.isOrdreInverse();
            // Récupération du type de trace
            TraceType traceType = traceForm.getListeTypeTrace();
            // Récupération du code évenement
            List<String> codeEvenement = traceForm.getCodeEvenement();
          
            // Récupération du contrat de service
            String contratService = traceForm.getContratService();

            // Récupération du mode de recherche
            String modeRecherche = traceForm.getModeRecherche();
            // Ajout des heures dans les dates de début et de fin
            Date dateDebut = calculeDate(dateDebutTmp, heureDebut, minuteDebut);
            Date dateFin = calculeDate(dateFinTmp, heureFin, minuteFin);

            // Nombre de ligne max du tableau de résultat
            if (traceForm.getNbLignesTableau() == 0) {
               traceForm.setNbLignesTableau(NB_LIGNE_TABLEAU);
               request.setAttribute("nbLignesTableau", NB_LIGNE_TABLEAU);
            } else {
               request.setAttribute("nbLignesTableau", traceForm
                     .getNbLignesTableau());
            }

            // Récupération de la configuration choisie
            String nomConf = (String) session.getAttribute("nomConfiguration");
            DFCEConnection dfceConnection = (DFCEConnection) session
                  .getServletContext().getAttribute(nomConf + "-dfce");
            Keyspace keyspace = (Keyspace) session.getServletContext()
                  .getAttribute(nomConf);

            // Colonnes à afficher suivant les types de traces
            List<String> colonnesAffichees = new ArrayList<String>();
            colonnesAffichees = getColonnesAAfficherTraces(traceType);
            traceForm.setColonnesAffichees(colonnesAffichees);

            List<DfceTrace> listeTracesDfce = new ArrayList<DfceTrace>();
            List<SaeTrace> listeTracesSae = new ArrayList<SaeTrace>();

            // Recherche par identifiant
            if ("parIdentifiant".equals(modeRecherche)) {
               // Trace du cycle de vie
               if (traceType.equals(TraceType.CYCLE_VIE)) {
                  listeTracesDfce = traceService.lectureTracesDfceParDocUuid(
                        traceType, uuid, dfceConnection);

                  request.setAttribute("modeAffichage", "DFCE");
                  request.setAttribute("listeTraces", listeTracesDfce);

               } else {
                  ObjectError erreur = new ObjectError(NOM_FORMULAIRE,
                        "Le type de trace est incorrect");
                  result.addError(erreur);
               }
               // Recherche par dates
            } else if ("parDates".equals(modeRecherche)) {
               if (traceType.equals(TraceType.HIST_EVT)
                     || traceType.equals(TraceType.CYCLE_VIE)) {
                  listeTracesDfce = traceService.lectureTracesDfceParDates(
                        traceType, dateDebut, dateFin, taille, ordreInverse,
                        dfceConnection);
                  request.setAttribute("modeAffichage", "DFCE");
                  request.setAttribute("listeTraces", listeTracesDfce);
               } else if (traceType.equals(TraceType.EXPLOITATION)
                     || traceType.equals(TraceType.SECURITE)
                     || traceType.equals(TraceType.TECHNIQUE)
                     || traceType.equals(TraceType.JOURNAL_EVT)) {
                  listeTracesSae = traceService.lectureTracesSaeParDates(
                        traceType, dateDebut, dateFin, taille, ordreInverse,
                        keyspace);
                  request.setAttribute("modeAffichage", "SAE");

                  // Besoin de filtrer ?
                  if ((codeEvenement != null && !codeEvenement.contains("TOUS"))
                        || (contratService != null && !"TOUS"
                              .equals(contratService))) {
                     List<SaeTrace> listeTracesSaeFiltree = new ArrayList<SaeTrace>();
                     for (SaeTrace saeTrace : listeTracesSae) {
                        boolean traceAGarder = true;
                        if (codeEvenement != null
                              && !codeEvenement.contains("TOUS")) {
                           if (!codeEvenement.contains(saeTrace.getCodeEvt())) {
                              traceAGarder = false;
                           }
                        }
                        if (contratService != null
                              && !"TOUS".equals(contratService)) {
                           if (saeTrace.getContrat()!= null) {
                              if (!saeTrace.getContrat().equals(contratService)) {
                                 traceAGarder = false;
                              }
                           } else {
                              traceAGarder = false;
                           }
                        }
                        if (traceAGarder) {
                           listeTracesSaeFiltree.add(saeTrace);
                        }
                     }
                     request.setAttribute("listeTraces", listeTracesSaeFiltree);
                  } else {
                     request.setAttribute("listeTraces", listeTracesSae);
                  }

               }
            }
         } catch (AucuneTraceException e) {
            ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
            result.addError(erreur);
            // StringWriter sw = new StringWriter();
            // PrintWriter pw = new PrintWriter(sw);
            // e.printStackTrace(pw);
            // String stacktrace = sw.toString();
            // request.setAttribute("stacktrace", stacktrace);
         } catch (TraceException e) {
            ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
            result.addError(erreur);
            // StringWriter sw = new StringWriter();
            // PrintWriter pw = new PrintWriter(sw);
            // e.printStackTrace(pw);
            // String stacktrace = sw.toString();
            // request.setAttribute("stacktrace", stacktrace);
         } catch (ErreurTechniqueException e) {
            ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
            result.addError(erreur);
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);
         } catch (IllegalArgumentException e) {
            ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
            result.addError(erreur);
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);
         }

      }

      return "consulterTraces";
   }

   /**
    * Récupération du détail de la trace
    * 
    * @param traceForm
    *           Le formulaire
    * @param result
    *           Gestion des erreurs
    * @param session
    *           La session
    * @param request
    *           La requête
    * @return La page à afficher
    */
   @RequestMapping(value = "detailTrace")
   public final String afficherDetailTrace(
         @ModelAttribute(NOM_FORMULAIRE) @Valid ConsulterTracesForm traceForm,
         BindingResult result, HttpSession session, HttpServletRequest request) {

      if (!result.hasFieldErrors()) {

         try {

            // Récupération de l'uuid de la trace dont on veut le détail
            UUID idTrace = traceForm.getIdTrace();

            // Récupération du type de trace
            TraceType traceType = traceForm.getListeTypeTrace();

            // Colonnes à afficher suivant les types de traces
            List<String> colonnesAffichees = new ArrayList<String>();
            colonnesAffichees = getColonnesAAfficherDetailTraces(traceType);
            traceForm.setColonnesAffichees(colonnesAffichees);

            // Récupération de la configuration choisie
            String nomConf = (String) session.getAttribute("nomConfiguration");
            Keyspace keyspace = (Keyspace) session.getServletContext()
                  .getAttribute(nomConf);

            SaeTrace saeTrace = traceService.lectureTraceSaeParUuid(traceType,
                  idTrace, keyspace);

            request.setAttribute("detailTrace", saeTrace);

         } catch (AucuneTraceException e) {
            ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
            result.addError(erreur);
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);
         } catch (TraceException e) {
            ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
            result.addError(erreur);
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);
         } catch (ErreurTechniqueException e) {
            ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
            result.addError(erreur);
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);
         } catch (IllegalArgumentException e) {
            ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
            result.addError(erreur);
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);
         }

      }

      return "consulterTraces";

   }

   @SuppressWarnings("PMD.ShortVariable")
   private Date calculeDate(Date dateDebut, String heure, String minute) {

      Date dateOk = dateDebut;

      int hh = Integer.parseInt(heure);
      int mm = Integer.parseInt(minute);

      if (hh == MINUIT) {
         hh = HEURE_MAX;
         mm = MINUTE_MAX;
      }
      dateOk = DateUtils.setHours(dateOk, hh);
      dateOk = DateUtils.setMinutes(dateOk, mm);
      dateOk = DateUtils.setSeconds(dateOk, 0);
      dateOk = DateUtils.setMilliseconds(dateOk, 0);

      return dateOk;

   }

   /**
    * Récupération des colonnes à afficher suivant le type de la trace
    * 
    * @param traceType
    * @return Les colonnes à afficher
    */
   private List<String> getColonnesAAfficherTraces(TraceType traceType) {

      List<String> colonnesAffichees = new ArrayList<String>();

      if (traceType.equals(TraceType.CYCLE_VIE)) {
         colonnesAffichees.add(DOC_UUID);
         colonnesAffichees.add(DATE_EVT);
         colonnesAffichees.add(TYPE_EVT);
         colonnesAffichees.add(LOGIN);
         // if (modeRecherche.equals("parDates")) {
         colonnesAffichees.add(ATTRIBUTS);
         // }
      } else if (traceType.equals(TraceType.HIST_EVT)) {
         colonnesAffichees.add(DATE_EVT);
         colonnesAffichees.add(TYPE_EVT);
         colonnesAffichees.add(LOGIN);
         colonnesAffichees.add(ATTRIBUTS);
      } else if (traceType.equals(TraceType.EXPLOITATION)) {
         colonnesAffichees.add(ACTION);
         colonnesAffichees.add(CODE_EVT);
         colonnesAffichees.add(CONTRAT);
         colonnesAffichees.add(LOGIN);
         colonnesAffichees.add(TIMESTAMP);
         colonnesAffichees.add(PAGMS);
      } else if (traceType.equals(TraceType.TECHNIQUE)) {
         colonnesAffichees.add(CODE_EVT);
         colonnesAffichees.add(CONTRAT);
         colonnesAffichees.add(LOGIN);
         colonnesAffichees.add(TIMESTAMP);
         colonnesAffichees.add(PAGMS);
      } else if (traceType.equals(TraceType.SECURITE)) {
         colonnesAffichees.add(CODE_EVT);
         colonnesAffichees.add(CONTEXTE);
         colonnesAffichees.add(CONTRAT);
         colonnesAffichees.add(LOGIN);
         colonnesAffichees.add(TIMESTAMP);
         colonnesAffichees.add(PAGMS);
      } else if (traceType.equals(TraceType.JOURNAL_EVT)) {
         colonnesAffichees.add(CODE_EVT);
         colonnesAffichees.add(CONTEXTE);
         colonnesAffichees.add(CONTRAT);
         colonnesAffichees.add(LOGIN);
         colonnesAffichees.add(TIMESTAMP);
         colonnesAffichees.add(PAGMS);
      }
      return colonnesAffichees;

   }

   /**
    * Récupération de la liste des colonnes à afficher dans le détail des traces
    * suivant le type de trace
    * 
    * @param traceType
    *           Le type de la trace
    * @return La liste des colonnes
    */
   private List<String> getColonnesAAfficherDetailTraces(TraceType traceType) {

      List<String> colonnesAffichees = new ArrayList<String>();
      colonnesAffichees.add(CODE_EVT);
      colonnesAffichees.add(CONTRAT);
      colonnesAffichees.add(LOGIN);
      colonnesAffichees.add(TIMESTAMP);
      colonnesAffichees.add(PAGMS);
      if (traceType.equals(TraceType.EXPLOITATION)) {
         colonnesAffichees.add(ACTION);
      } else if (traceType.equals(TraceType.SECURITE)
            || traceType.equals(TraceType.JOURNAL_EVT)) {
         colonnesAffichees.add(CONTEXTE);
      } else if (traceType.equals(TraceType.TECHNIQUE)) {
         colonnesAffichees.add(CONTEXTE);
         colonnesAffichees.add(STACKTRACE);

      }
      colonnesAffichees.add(INFOS);
      return colonnesAffichees;
   }

}
