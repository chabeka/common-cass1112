package fr.urssaf.image.sae.ihm.web.exploit.service.impl;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import me.prettyprint.hector.api.Keyspace;

import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.StringUtils;
import org.springframework.stereotype.Component;

import fr.urssaf.image.commons.cassandra.support.clock.JobClockConfiguration;
import fr.urssaf.image.commons.cassandra.support.clock.JobClockSupport;
import fr.urssaf.image.commons.cassandra.support.clock.impl.JobClockSupportImpl;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucunJobException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.ErreurTechniqueException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.MiseAJourJobException;
import fr.urssaf.image.sae.ihm.web.exploit.modele.Job;
import fr.urssaf.image.sae.ihm.web.exploit.service.GererPileService;
import fr.urssaf.image.sae.pile.travaux.dao.JobHistoryDao;
import fr.urssaf.image.sae.pile.travaux.dao.JobRequestDao;
import fr.urssaf.image.sae.pile.travaux.dao.JobsQueueDao;
import fr.urssaf.image.sae.pile.travaux.exception.JobNonReinitialisableException;
import fr.urssaf.image.sae.pile.travaux.model.JobHistory;
import fr.urssaf.image.sae.pile.travaux.model.JobRequest;
import fr.urssaf.image.sae.pile.travaux.model.JobState;
import fr.urssaf.image.sae.pile.travaux.service.JobLectureService;
import fr.urssaf.image.sae.pile.travaux.service.JobQueueService;
import fr.urssaf.image.sae.pile.travaux.service.impl.JobLectureServiceImpl;
import fr.urssaf.image.sae.pile.travaux.service.impl.JobQueueServiceImpl;

/**
 * Classe implémentant le service GererPileService
 * 
 * 
 */
@Component
public class GererPileServiceImpl implements GererPileService {

   public static final int MAX_TIME_SYNCHRO_ERROR = 1000000;
   public static final int MAX_TIME_SYNCHRO_WARN = 1500000;

   /**
    * Renvoie la liste de tous les travaux actuellement dans la pile
    * 
    * @param keyspace
    *           le keyspace de la configuration choisie
    * @param maxKeysToRead
    *           nombre de clés maximum à récuperer lors de la lecture de la pile
    *           des travaux
    * @return Liste de tous les travaux actuellement dans la pile
    * @throws ErreurTechniqueException
    *            Exception levée lors de la recherche des jobs
    */
   @Override
   public final List<Job> rechercherTousTravaux(Keyspace keyspace,
         int maxKeysToRead) throws ErreurTechniqueException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
      JobLectureService jobsLecture = new JobLectureServiceImpl(jobRequestDao,
            jobsQueueDao, jobHistoryDao);

      List<JobRequest> listeJobRequest = null;

      try {
         listeJobRequest = jobsLecture.getAllJobs(keyspace, maxKeysToRead);
      } catch (Exception e) {
         throw new ErreurTechniqueException(e);
      }

      List<Job> listeJobs = new ArrayList<Job>();

      for (JobRequest jobRequest : listeJobRequest) {
         Job job = new Job();
         job.setClientHost(jobRequest.getClientHost());
         job.setCreationDate(jobRequest.getCreationDate());
         job.setDocCount(jobRequest.getDocCount());
         job.setEndingDate(jobRequest.getEndingDate());
         job.setIdJob(jobRequest.getIdJob());
         job.setMessage(jobRequest.getMessage());
         if (MapUtils.isEmpty(jobRequest.getJobParameters())) {
            job.setParameters(jobRequest.getParameters());
         } else {
            job.setJobParameters(jobRequest.getJobParameters());
         }
         job.setPid(jobRequest.getPid());
         job.setReservationDate(jobRequest.getReservationDate());
         job.setReservedBy(jobRequest.getReservedBy());
         job.setSaeHost(jobRequest.getSaeHost());
         job.setStartingDate(jobRequest.getStartingDate());
         job.setState(jobRequest.getState());
         job.setToCheckFlag(jobRequest.getToCheckFlag());
         job.setToCheckFlagRaison(jobRequest.getToCheckFlagRaison());
         job.setType(jobRequest.getType());
         job.setVi(jobRequest.getVi());
         job.setRemovable(jobsLecture.isJobRemovable(jobRequest));
         job.setResettable(jobsLecture.isJobResettable(jobRequest));
         listeJobs.add(job);
      }

      return listeJobs;

   }

   /**
    * Renvoit le job correspondant à l'indentifiant
    * 
    * @param keyspace
    *           Le keyspace
    * @param idJob
    *           l'indentifiant du job à récupérer
    * @return Job récupéré
    * @throws AucunJobException 
    */
   @Override
   public final Job getJob(Keyspace keyspace, UUID idJob) throws AucunJobException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
      JobLectureService jobsLecture = new JobLectureServiceImpl(jobRequestDao,
            jobsQueueDao, jobHistoryDao);

      JobRequest jobRequest = jobsLecture.getJobRequest(idJob);
      Job job = new Job();

      if (jobRequest != null) {

         job.setClientHost(jobRequest.getClientHost());
         job.setCreationDate(jobRequest.getCreationDate());
         job.setDocCount(jobRequest.getDocCount());
         job.setEndingDate(jobRequest.getEndingDate());
         job.setIdJob(jobRequest.getIdJob());
         job.setMessage(jobRequest.getMessage());
         if (MapUtils.isEmpty(jobRequest.getJobParameters())) {
            job.setParameters(jobRequest.getParameters());
         } else {
            job.setJobParameters(jobRequest.getJobParameters());
         }
         job.setPid(jobRequest.getPid());
         job.setReservationDate(jobRequest.getReservationDate());
         job.setReservedBy(jobRequest.getReservedBy());
         job.setSaeHost(jobRequest.getSaeHost());
         job.setStartingDate(jobRequest.getStartingDate());
         job.setState(jobRequest.getState());
         job.setToCheckFlag(jobRequest.getToCheckFlag());
         job.setToCheckFlagRaison(jobRequest.getToCheckFlagRaison());
         job.setType(jobRequest.getType());
         job.setVi(jobRequest.getVi());
         job.setRemovable(jobsLecture.isJobRemovable(jobRequest));
         job.setResettable(jobsLecture.isJobResettable(jobRequest));
      } else {
         throw new AucunJobException(String.format(
               "Le job d'identifiant %s n'a pas été trouvé", idJob));
      }
      return job;
   }

   /**
    * Mise à jour du travail afin que celui-ci soit en état d'être relancé par
    * l'ordonnanceur
    * 
    * @param uuid
    *           Identifiant unique du travail à mettre à jour
    * @param keyspace
    *           le keyspace de la configuration choisie
    * @throws AucunJobException
    *            Exception levée lorsque le travail à supprimer n'existe pas
    * @throws MiseAJourJobException
    *            Exception levée lorsque le travail ne satisfait pas aux
    *            conditions de suppression
    * @throws JobNonReinitialisableException
    *            Exception levée si le job ne peut pas être relancé
    */
   @Override
   public final void remettreTravailEtatLancement(UUID uuid, Keyspace keyspace)
         throws AucunJobException, MiseAJourJobException,
         JobNonReinitialisableException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobClockConfiguration clockConfiguration = new JobClockConfiguration();
      clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
      clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);

      JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
            clockConfiguration);

      JobLectureService jobLectureService = new JobLectureServiceImpl(
            jobRequestDao, jobsQueueDao, jobHistoryDao);

      // Récupération du job
      JobRequest job = jobLectureService.getJobRequest(uuid);
      // Le job n'existe pas
      if (job == null) {
         throw new AucunJobException();
      }
      JobState state = job.getState();
      String nomEtat = state.toString();

      // Mise à jour du job s'il est dans l'état RESERVED ou STARTING
      if ("RESERVED".equals(nomEtat) || "STARTING".equals(nomEtat)) {

         JobQueueService jobQueueService = new JobQueueServiceImpl(
               jobRequestDao, jobsQueueDao, jobClockSupport, jobHistoryDao,
               jobLectureService, null);

         jobQueueService.resetJob(uuid);
      } else {
         throw new MiseAJourJobException(
               "L'état du job ne permet pas sa remise en état de lancement.");
      }

   }

   /**
    * Supprime le travail dont l'identifiant est passé en paramètre
    * 
    * @param uuid
    *           Identifiant unique du travail à supprimer
    * @param keyspace
    *           le keyspace de la configuration choisie
    * @throws AucunJobException
    *            Exception levée lorsque le travail à supprimer n'existe pas
    * @throws MiseAJourJobException
    *            Exception levée lorsque le travail ne satisfait pas aux
    *            conditions de suppression
    */
   @Override
   public final void supprimerTravail(UUID uuid, Keyspace keyspace)
         throws AucunJobException, MiseAJourJobException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobClockConfiguration clockConfiguration = new JobClockConfiguration();

      clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
      clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);
      JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
            clockConfiguration);

      JobLectureService jobLectureService = new JobLectureServiceImpl(
            jobRequestDao, jobsQueueDao, jobHistoryDao);

      // Récupération du job
      JobRequest job = jobLectureService.getJobRequest(uuid);
      // Le job n'existe pas
      if (job == null) {
         throw new AucunJobException();
      }
      JobState state = job.getState();
      String nomEtat = state.toString();

      // Suppression du job si il est dans l'état RESERVED, STARTING, CREATED
      if ("RESERVED".equals(nomEtat) || "STARTING".equals(nomEtat)
            || "CREATED".equals(nomEtat)) {

         JobQueueService jobQueueService = new JobQueueServiceImpl(
               jobRequestDao, jobsQueueDao, jobClockSupport, jobHistoryDao,
               jobLectureService, null);

         jobQueueService.deleteJob(uuid);
      } else {
         throw new MiseAJourJobException(
               "L'état du job ne permet pas sa suppression.");
      }

   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final List<JobHistory> getHistorique(UUID uuid, Keyspace keyspace)
         throws ErreurTechniqueException {
      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobLectureService jobLectureService = new JobLectureServiceImpl(
            jobRequestDao, jobsQueueDao, jobHistoryDao);

      List<JobHistory> listeJobHistory = null;
      try {
         listeJobHistory = jobLectureService.getJobHistory(uuid);
      } catch (Exception e) {
         throw new ErreurTechniqueException(e);
      }
      return listeJobHistory;

   }


   @Override
   public final List<JobRequest> recupererTravauxEnCoursParServeur(Keyspace keyspace) {
      List<JobRequest> jobsEnCours = new ArrayList<JobRequest>();

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobClockConfiguration clockConfiguration = new JobClockConfiguration();

      clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
      clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);
      JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
            clockConfiguration);

      JobLectureService jobLectureService = new JobLectureServiceImpl(
            jobRequestDao, jobsQueueDao, jobHistoryDao);

      JobQueueService jobQueueService = new JobQueueServiceImpl(jobRequestDao,
            jobsQueueDao, jobClockSupport, jobHistoryDao, jobLectureService,
            null);

      // recupere la liste des hosts
      List<String> hosts = jobQueueService.getHosts();

      // boucle sur les serveurs
      for (String hostname : hosts) {
         if (StringUtils.isNotBlank(hostname)) {
            List<JobRequest> jobs = jobLectureService.getNonTerminatedJobs(hostname);

            if (!jobs.isEmpty()) {
               // met le jobs
               JobRequest jobfind = jobs.get(0);
               if (jobfind != null) {
                  jobfind.setReservedBy(hostname);
                  jobsEnCours.add(jobfind);
               } else {
                  addNewJobToList(jobsEnCours, hostname);
               }
            } else {
               addNewJobToList(jobsEnCours, hostname);
            }
         }
      }

      return jobsEnCours;
   }

   /**
    * Methode permettant d'ajouter un nouveau job à une liste de job.
    * 
    * @param jobs
    *           liste job
    * @param hostname
    *           key jobsQueues
    */
   private void addNewJobToList(List<JobRequest> jobs, String hostname) {
      JobRequest jobVide = new JobRequest();
      jobVide.setReservedBy(hostname);
      jobs.add(jobVide);
   }

}
