package fr.urssaf.image.sae.ihm.web.exploit.service.impl;

import java.util.List;
import java.util.UUID;

import me.prettyprint.hector.api.Keyspace;

import org.springframework.stereotype.Component;

import fr.urssaf.image.commons.cassandra.support.clock.JobClockConfiguration;
import fr.urssaf.image.commons.cassandra.support.clock.JobClockSupport;
import fr.urssaf.image.commons.cassandra.support.clock.impl.JobClockSupportImpl;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucunJobException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.MiseAJourJobException;
import fr.urssaf.image.sae.ihm.web.exploit.service.GererPileService;
import fr.urssaf.image.sae.pile.travaux.dao.JobHistoryDao;
import fr.urssaf.image.sae.pile.travaux.dao.JobRequestDao;
import fr.urssaf.image.sae.pile.travaux.dao.JobsQueueDao;
import fr.urssaf.image.sae.pile.travaux.model.JobRequest;
import fr.urssaf.image.sae.pile.travaux.model.JobState;
import fr.urssaf.image.sae.pile.travaux.service.JobLectureService;
import fr.urssaf.image.sae.pile.travaux.service.JobQueueService;
import fr.urssaf.image.sae.pile.travaux.service.impl.JobLectureImpl;
import fr.urssaf.image.sae.pile.travaux.service.impl.JobQueueServiceImpl;

/**
 * Classe implémentant le service GererPileService
 * 
 * 
 */
@Component
public class GererPileServiceImpl implements GererPileService {

   public static final int MAX_TIME_SYNCHRO_ERROR = 1000000;
   public static final int MAX_TIME_SYNCHRO_WARN = 1500000;

   
   /**
    * Renvoire la liste de tous les travaux actuellement dans la pile
    * 
    * @param keyspace
    *           le keyspace de la configuration choisie
    * @return Liste de tous les travaux actuellement dans la pile
    */
   @Override
   public final List<JobRequest> rechercherTousTravaux(Keyspace keyspace) {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
      JobLectureService jobsLecture = new JobLectureImpl(jobRequestDao,
            jobsQueueDao, jobHistoryDao);

      return jobsLecture.getAllJobs(keyspace);

   }

   /**
    * Mise à jour du travail afin que celui-ci soit en état d'être relancé par
    * l'ordonnanceur
    * 
    * @param uuid
    *           Identifiant unique du travail à mettre à jour
    * @param keyspace
    *           le keyspace de la configuration choisie
    * @throws AucunJobException
    *            Exception levée lorsque le travail à supprimer n'existe pas
    * @throws MiseAJourJobException
    *            Exception levée lorsque le travail ne satisfait pas aux
    *            conditions de suppression
    */
   @Override
   public final void remettreTravailEtatLancement(UUID uuid, Keyspace keyspace)
         throws AucunJobException, MiseAJourJobException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobClockConfiguration clockConfiguration = new JobClockConfiguration();
      clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
      clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);

      JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
            clockConfiguration);

      JobLectureService jobLectureService = new JobLectureImpl(jobRequestDao,
            jobsQueueDao, jobHistoryDao);

      // Récupération du job
      JobRequest job = jobLectureService.getJobRequest(uuid);
      // Le job n'existe pas
      if (job == null) {
         throw new AucunJobException();
      }
      JobState state = job.getState();
      String nomEtat = state.toString();

      // Mise à jour du job s'il est dans l'état RESERVED ou STARTING
      if ("RESERVED".equals(nomEtat) || "STARTING".equals(nomEtat)) {

         JobQueueService jobQueueService = new JobQueueServiceImpl(
               jobRequestDao, jobsQueueDao, jobClockSupport, jobHistoryDao,
               jobLectureService, null);

         jobQueueService.resetJob(uuid);
      } else {
         throw new MiseAJourJobException(
               "L'état du job ne permet pas sa remise en état de lancement.");
      }

   }

   /**
    * Supprime le travail dont l'identifiant est passé en paramètre
    * 
    * @param uuid
    *           Identifiant unique du travail à supprimer
    * @param keyspace
    *           le keyspace de la configuration choisie 
    * @throws AucunJobException
    *            Exception levée lorsque le travail à supprimer n'existe pas
    * @throws MiseAJourJobException
    *            Exception levée lorsque le travail ne satisfait pas aux
    *            conditions de suppression
    */
   @Override
   public final void supprimerTravail(UUID uuid, Keyspace keyspace)
         throws AucunJobException, MiseAJourJobException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobClockConfiguration clockConfiguration = new JobClockConfiguration();

      clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
      clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);
      JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
            clockConfiguration);

      JobLectureService jobLectureService = new JobLectureImpl(jobRequestDao,
            jobsQueueDao, jobHistoryDao);

      JobRequest job = jobLectureService.getJobRequest(uuid);
      JobState state = job.getState();
      String nomEtat = state.toString();

      // Suppression du job si il est dans l'état RESERVED, STARTING, CREATED
      if ("RESERVED".equals(nomEtat) || "STARTING".equals(nomEtat)
            || "CREATED".equals(nomEtat)) {

         JobQueueService jobQueueService = new JobQueueServiceImpl(
               jobRequestDao, jobsQueueDao, jobClockSupport, jobHistoryDao,
               jobLectureService, null);

         jobQueueService.deleteJob(uuid);
      } else {
         throw new MiseAJourJobException(
               "L'état du job ne permet pas sa suppression.");
      }

   }

}
