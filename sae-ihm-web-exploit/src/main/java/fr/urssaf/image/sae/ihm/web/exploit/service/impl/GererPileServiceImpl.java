package fr.urssaf.image.sae.ihm.web.exploit.service.impl;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import me.prettyprint.hector.api.Keyspace;

import org.apache.commons.collections.MapUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import fr.urssaf.image.commons.cassandra.support.clock.JobClockConfiguration;
import fr.urssaf.image.commons.cassandra.support.clock.JobClockSupport;
import fr.urssaf.image.commons.cassandra.support.clock.impl.JobClockSupportImpl;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucunJobException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.ErreurTechniqueException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.MiseAJourJobException;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationBean;
import fr.urssaf.image.sae.ihm.web.exploit.modele.Job;
import fr.urssaf.image.sae.ihm.web.exploit.service.GererPileService;
import fr.urssaf.image.sae.pile.travaux.dao.JobHistoryDao;
import fr.urssaf.image.sae.pile.travaux.dao.JobRequestDao;
import fr.urssaf.image.sae.pile.travaux.dao.JobsQueueDao;
import fr.urssaf.image.sae.pile.travaux.exception.JobNonReinitialisableException;
import fr.urssaf.image.sae.pile.travaux.model.JobHistory;
import fr.urssaf.image.sae.pile.travaux.model.JobRequest;
import fr.urssaf.image.sae.pile.travaux.model.JobState;
import fr.urssaf.image.sae.pile.travaux.service.JobLectureService;
import fr.urssaf.image.sae.pile.travaux.service.JobQueueService;
import fr.urssaf.image.sae.pile.travaux.service.impl.JobLectureImpl;
import fr.urssaf.image.sae.pile.travaux.service.impl.JobQueueServiceImpl;

/**
 * Classe implémentant le service GererPileService
 * 
 * 
 */
@Component
public class GererPileServiceImpl implements GererPileService {

   public static final int MAX_TIME_SYNCHRO_ERROR = 1000000;
   public static final int MAX_TIME_SYNCHRO_WARN = 1500000;

   /**
    * Bean contenant des informations de l'application
    */
   @Autowired
   private ConfigurationBean configuration;

   /**
    * Renvoire la liste de tous les travaux actuellement dans la pile
    * 
    * @param keyspace
    *           le keyspace de la configuration choisie
    * @param maxKeysToRead
    *           nombre de clés maximum à récuperer lors de la lecture de la pile
    *           des travaux
    * @return Liste de tous les travaux actuellement dans la pile
    * @throws ErreurTechniqueException
    *            Exception levée lors de la recherche des jobs
    */
   @Override
   public final List<Job> rechercherTousTravaux(Keyspace keyspace,
         int maxKeysToRead) throws ErreurTechniqueException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
      JobLectureService jobsLecture = new JobLectureImpl(jobRequestDao,
            jobsQueueDao, jobHistoryDao);

      List<JobRequest> listeJobRequest = null;

      try {
         if (maxKeysToRead <= 0) {
            maxKeysToRead = configuration.getMaxKeysToRead();
         }
         listeJobRequest = jobsLecture.getAllJobs(keyspace, maxKeysToRead);
      } catch (Exception e) {
         throw new ErreurTechniqueException(e);
      }

      List<Job> listeJobs = new ArrayList<Job>();

      for (JobRequest jobRequest : listeJobRequest) {
         Job job = new Job();
         job.setClientHost(jobRequest.getClientHost());
         job.setCreationDate(jobRequest.getCreationDate());
         job.setDocCount(jobRequest.getDocCount());
         job.setEndingDate(jobRequest.getEndingDate());
         job.setIdJob(jobRequest.getIdJob());
         job.setMessage(jobRequest.getMessage());
         if (MapUtils.isEmpty(jobRequest.getJobParameters())) {
            job.setParameters(jobRequest.getParameters());
         } else {
            job.setJobParameters(jobRequest.getJobParameters());
         }
         job.setPid(jobRequest.getPid());
         job.setReservationDate(jobRequest.getReservationDate());
         job.setReservedBy(jobRequest.getReservedBy());
         job.setSaeHost(jobRequest.getSaeHost());
         job.setStartingDate(jobRequest.getStartingDate());
         job.setState(jobRequest.getState());
         job.setToCheckFlag(jobRequest.getToCheckFlag());
         job.setToCheckFlagRaison(jobRequest.getToCheckFlagRaison());
         job.setType(jobRequest.getType());
         job.setVi(jobRequest.getVi());
         job.setRemovable(jobsLecture.isJobRemovable(jobRequest));
         job.setResettable(jobsLecture.isJobResettable(jobRequest));
         listeJobs.add(job);
      }

      return listeJobs;

   }

   /**
    * Mise à jour du travail afin que celui-ci soit en état d'être relancé par
    * l'ordonnanceur
    * 
    * @param uuid
    *           Identifiant unique du travail à mettre à jour
    * @param keyspace
    *           le keyspace de la configuration choisie
    * @throws AucunJobException
    *            Exception levée lorsque le travail à supprimer n'existe pas
    * @throws MiseAJourJobException
    *            Exception levée lorsque le travail ne satisfait pas aux
    *            conditions de suppression
    * @throws JobNonReinitialisableException
    *            Exception levée si le job ne peut pas être relancé
    */
   @Override
   public final void remettreTravailEtatLancement(UUID uuid, Keyspace keyspace)
         throws AucunJobException, MiseAJourJobException,
         JobNonReinitialisableException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobClockConfiguration clockConfiguration = new JobClockConfiguration();
      clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
      clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);

      JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
            clockConfiguration);

      JobLectureService jobLectureService = new JobLectureImpl(jobRequestDao,
            jobsQueueDao, jobHistoryDao);

      // Récupération du job
      JobRequest job = jobLectureService.getJobRequest(uuid);
      // Le job n'existe pas
      if (job == null) {
         throw new AucunJobException();
      }
      JobState state = job.getState();
      String nomEtat = state.toString();

      // Mise à jour du job s'il est dans l'état RESERVED ou STARTING
      if ("RESERVED".equals(nomEtat) || "STARTING".equals(nomEtat)) {

         JobQueueService jobQueueService = new JobQueueServiceImpl(
               jobRequestDao, jobsQueueDao, jobClockSupport, jobHistoryDao,
               jobLectureService, null);

         jobQueueService.resetJob(uuid);
      } else {
         throw new MiseAJourJobException(
               "L'état du job ne permet pas sa remise en état de lancement.");
      }

   }

   /**
    * Supprime le travail dont l'identifiant est passé en paramètre
    * 
    * @param uuid
    *           Identifiant unique du travail à supprimer
    * @param keyspace
    *           le keyspace de la configuration choisie
    * @throws AucunJobException
    *            Exception levée lorsque le travail à supprimer n'existe pas
    * @throws MiseAJourJobException
    *            Exception levée lorsque le travail ne satisfait pas aux
    *            conditions de suppression
    */
   @Override
   public final void supprimerTravail(UUID uuid, Keyspace keyspace)
         throws AucunJobException, MiseAJourJobException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobClockConfiguration clockConfiguration = new JobClockConfiguration();

      clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
      clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);
      JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
            clockConfiguration);

      JobLectureService jobLectureService = new JobLectureImpl(jobRequestDao,
            jobsQueueDao, jobHistoryDao);

      // Récupération du job
      JobRequest job = jobLectureService.getJobRequest(uuid);
      // Le job n'existe pas
      if (job == null) {
         throw new AucunJobException();
      }
      JobState state = job.getState();
      String nomEtat = state.toString();

      // Suppression du job si il est dans l'état RESERVED, STARTING, CREATED
      if ("RESERVED".equals(nomEtat) || "STARTING".equals(nomEtat)
            || "CREATED".equals(nomEtat)) {

         JobQueueService jobQueueService = new JobQueueServiceImpl(
               jobRequestDao, jobsQueueDao, jobClockSupport, jobHistoryDao,
               jobLectureService, null);

         jobQueueService.deleteJob(uuid);
      } else {
         throw new MiseAJourJobException(
               "L'état du job ne permet pas sa suppression.");
      }

   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final List<JobHistory> getHistorique(UUID uuid, Keyspace keyspace)
         throws ErreurTechniqueException {
      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobLectureService jobLectureService = new JobLectureImpl(jobRequestDao,
            jobsQueueDao, jobHistoryDao);

      List<JobHistory> listeJobHistory = null;
      try {
         listeJobHistory = jobLectureService.getJobHistory(uuid);
      } catch (Exception e) {
         throw new ErreurTechniqueException(e);
      }
      return listeJobHistory;

   }

   private String jobParametersToString(Map<String, String> jobParameters) {
      StringBuilder result = new StringBuilder();
      for (Map.Entry<String, String> entry : jobParameters.entrySet()) {
         result.append(entry.getKey());
         result.append('=');
         result.append(entry.getValue());
         result.append("\r\n");
      }
      return result.toString();
   }

}
