package fr.urssaf.image.sae.ihm.web.exploit.service.impl;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;

import fr.urssaf.image.commons.cassandra.support.clock.JobClockConfiguration;
import fr.urssaf.image.commons.cassandra.support.clock.JobClockSupport;
import fr.urssaf.image.commons.cassandra.support.clock.impl.JobClockSupportImpl;
import fr.urssaf.image.sae.commons.utils.Constantes;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucunJobException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.ErreurTechniqueException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.MiseAJourJobException;
import fr.urssaf.image.sae.ihm.web.exploit.modele.Job;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.SaeStubUtils;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.Deblocage;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.DeblocageRequestType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.DeblocageResponse;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.UuidType;
import fr.urssaf.image.sae.ihm.web.exploit.service.GererPileService;
import fr.urssaf.image.sae.pile.travaux.dao.JobHistoryDao;
import fr.urssaf.image.sae.pile.travaux.dao.JobRequestDao;
import fr.urssaf.image.sae.pile.travaux.dao.JobsQueueDao;
import fr.urssaf.image.sae.pile.travaux.exception.JobNonReinitialisableException;
import fr.urssaf.image.sae.pile.travaux.model.JobHistory;
import fr.urssaf.image.sae.pile.travaux.model.JobRequest;
import fr.urssaf.image.sae.pile.travaux.model.JobState;
import fr.urssaf.image.sae.pile.travaux.service.JobLectureService;
import fr.urssaf.image.sae.pile.travaux.service.JobQueueService;
import fr.urssaf.image.sae.pile.travaux.service.cql.JobLectureCqlService;
import fr.urssaf.image.sae.pile.travaux.service.cql.JobQueueCqlService;
import fr.urssaf.image.sae.pile.travaux.service.impl.JobLectureServiceImpl;
import fr.urssaf.image.sae.pile.travaux.service.impl.JobQueueServiceImpl;
import fr.urssaf.image.sae.pile.travaux.service.thrift.JobLectureThriftService;
import fr.urssaf.image.sae.pile.travaux.service.thrift.JobQueueThriftService;
import fr.urssaf.image.sae.pile.travaux.service.thrift.impl.JobLectureServiceThriftImpl;
import fr.urssaf.image.sae.pile.travaux.service.thrift.impl.JobQueueServiceThriftImpl;
import fr.urssaf.image.sae.pile.travaux.support.JobHistorySupport;
import fr.urssaf.image.sae.pile.travaux.support.JobRequestSupport;
import fr.urssaf.image.sae.pile.travaux.support.JobsQueueSupport;
import me.prettyprint.hector.api.Keyspace;

/**
 * Classe implémentant le service GererPileService
 * 
 * 
 */
@Component
public class GererPileServiceImpl implements GererPileService {

  @Autowired
  private SaeStubUtils saeStubUtils;

  @Autowired
  private JobLectureCqlService jobLectureCqlService;

  @Autowired
  private JobQueueCqlService jobQueueCqlService;

  public static final int MAX_TIME_SYNCHRO_ERROR = 1000000;
  public static final int MAX_TIME_SYNCHRO_WARN = 1500000;

  private LoadingCache<Keyspace, List<Job>> listeJobCache;

  /**
   * Renvoie la liste de tous les travaux actuellement dans la pile
   * 
   * @param keyspace
   *            le keyspace de la configuration choisie
   * @param maxKeysToRead
   *            nombre de clés maximum à récuperer lors de la lecture de la
   *            pile des travaux
   * @return Liste de tous les travaux actuellement dans la pile
   * @throws ErreurTechniqueException
   *             Exception levée lors de la recherche des jobs
   */
  @Override
  public final List<Job> rechercherTousTravaux(final Keyspace keyspace, final int maxKeysToRead)
      throws ErreurTechniqueException {
    return listeJobCache.getUnchecked(keyspace);
  }

  /**
   * Renvoit le job correspondant à l'indentifiant
   * 
   * @param keyspace
   *            Le keyspace
   * @param idJob
   *            l'indentifiant du job à récupérer
   * @return Job récupéré
   * @throws AucunJobException
   */
  @Override
  public final Job getJob(final Keyspace keyspace, final UUID idJob) throws AucunJobException {

    final JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
    final JobRequestSupport jobRequestSupport = new JobRequestSupport(jobRequestDao);

    final JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
    final JobsQueueSupport jobsQueueSupport = new JobsQueueSupport(jobsQueueDao);

    final JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
    final JobHistorySupport jobHistorySupport = new JobHistorySupport(jobHistoryDao);

    final JobLectureThriftService jobLectureThriftService = new JobLectureServiceThriftImpl(jobRequestSupport,
                                                                                            jobsQueueSupport, jobHistorySupport);

    final JobLectureService jobsLecture = new JobLectureServiceImpl(jobLectureCqlService, jobLectureThriftService);

    final JobRequest jobRequest = jobsLecture.getJobRequest(idJob);
    final Job job = new Job();

    if (jobRequest != null) {

      job.setClientHost(jobRequest.getClientHost());
      job.setCreationDate(jobRequest.getCreationDate());
      job.setDocCount(jobRequest.getDocCount());
      job.setDocCountTraite(jobRequest.getDocCountTraite());
      job.setEndingDate(jobRequest.getEndingDate());
      job.setIdJob(jobRequest.getIdJob());
      job.setMessage(jobRequest.getMessage());
      if (MapUtils.isEmpty(jobRequest.getJobParameters())) {
        job.setParameters(jobRequest.getParameters());
      } else {
        job.setJobParameters(jobRequest.getJobParameters());
      }
      job.setPid(jobRequest.getPid());
      job.setReservationDate(jobRequest.getReservationDate());
      job.setReservedBy(jobRequest.getReservedBy());
      job.setSaeHost(jobRequest.getSaeHost());
      job.setStartingDate(jobRequest.getStartingDate());
      job.setState(jobRequest.getState());
      job.setToCheckFlag(jobRequest.getToCheckFlag());
      job.setToCheckFlagRaison(jobRequest.getToCheckFlagRaison());
      job.setType(jobRequest.getType());
      job.setVi(jobRequest.getVi());
      job.setRemovable(isJobRemovable(jobRequest, jobsLecture,
                                      jobRequestDao, jobsQueueDao, jobHistoryDao));
      job.setActiveSemaphore(isSemaphoreExistantJob(jobRequest, 
                                                    jobRequestDao, jobsQueueDao, jobHistoryDao));
      job.setResettable(jobsLecture.isJobResettable(jobRequest));
    } else {
      throw new AucunJobException(String.format(
                                                "Le job d'identifiant %s n'a pas été trouvé", idJob));
    }
    return job;
  }

  /**
   * Methode permettant de
   * 
   * @param jobRequest
   *            Job {@link JobRequest}
   * @param jobsLecture
   *            {@link JobLectureService}
   * @param jobHistoryDao
   *            {@link JobHistoryDao}
   * @param jobsQueueDao
   *            {@link JobsQueueDao}
   * @param jobRequestDao
   *            {@link JobRequestDao}
   * @return True si le job est supprimable, false sinon.
   */
  private boolean isJobRemovable(final JobRequest jobRequest,
                                 final JobLectureService jobsLecture, final JobRequestDao jobRequestDao,
                                 final JobsQueueDao jobsQueueDao, final JobHistoryDao jobHistoryDao) {
    return jobsLecture.isJobRemovable(jobRequest)
        && !isSemaphoreExistantJob(jobRequest, jobRequestDao, jobsQueueDao,
                                   jobHistoryDao);
  }

  /**
   * Mise à jour du travail afin que celui-ci soit en état d'être relancé par
   * l'ordonnanceur
   * 
   * @param uuid
   *            Identifiant unique du travail à mettre à jour
   * @param keyspace
   *            le keyspace de la configuration choisie
   * @throws AucunJobException
   *             Exception levée lorsque le travail à supprimer n'existe pas
   * @throws MiseAJourJobException
   *             Exception levée lorsque le travail ne satisfait pas aux
   *             conditions de suppression
   * @throws JobNonReinitialisableException
   *             Exception levée si le job ne peut pas être relancé
   */
  @Override
  public final void remettreTravailEtatLancement(final UUID uuid, final Keyspace keyspace)
      throws AucunJobException, MiseAJourJobException,
      JobNonReinitialisableException {

    final JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
    final JobRequestSupport jobRequestSupport = new JobRequestSupport(jobRequestDao);

    final JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
    final JobsQueueSupport jobsQueueSupport = new JobsQueueSupport(jobsQueueDao);

    final JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
    final JobHistorySupport jobHistorySupport = new JobHistorySupport(jobHistoryDao);

    final JobLectureThriftService jobLectureThriftService = new JobLectureServiceThriftImpl(jobRequestSupport,
                                                                                            jobsQueueSupport, jobHistorySupport);

    final JobLectureService jobLectureService = new JobLectureServiceImpl(jobLectureCqlService, jobLectureThriftService);

    final JobClockConfiguration clockConfiguration = new JobClockConfiguration();
    clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
    clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);

    final JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace, clockConfiguration);

    // Récupération du job
    final JobRequest job = jobLectureService.getJobRequest(uuid);
    // Le job n'existe pas
    if (job == null) {
      throw new AucunJobException();
    }
    final JobState state = job.getState();
    final String nomEtat = state.toString();

    // Mise à jour du job s'il est dans l'état RESERVED ou STARTING
    if ("RESERVED".equals(nomEtat) || "STARTING".equals(nomEtat)) {

      final JobQueueThriftService jobQueueThriftService = new JobQueueServiceThriftImpl(jobRequestSupport,
                                                                                        jobsQueueSupport, jobClockSupport, jobHistorySupport, jobLectureService, null);
      final JobQueueService jobQueueService = new JobQueueServiceImpl(jobQueueCqlService, jobQueueThriftService);

      jobQueueService.resetJob(uuid);
    } else {
      throw new MiseAJourJobException(
          "L'état du job ne permet pas sa remise en état de lancement.");
    }

  }

  /**
   * Supprime le travail dont l'identifiant est passé en paramètre
   * 
   * @param uuid
   *            Identifiant unique du travail à supprimer
   * @param keyspace
   *            le keyspace de la configuration choisie
   * @throws AucunJobException
   *             Exception levée lorsque le travail à supprimer n'existe pas
   * @throws MiseAJourJobException
   *             Exception levée lorsque le travail ne satisfait pas aux
   *             conditions de suppression
   */
  @Override
  public final void supprimerTravail(final UUID uuid, final Keyspace keyspace) throws AucunJobException, MiseAJourJobException {

    final JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
    final JobRequestSupport jobRequestSupport = new JobRequestSupport(jobRequestDao);

    final JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
    final JobsQueueSupport jobsQueueSupport = new JobsQueueSupport(jobsQueueDao);

    final JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
    final JobHistorySupport jobHistorySupport = new JobHistorySupport(jobHistoryDao);

    final JobLectureThriftService jobLectureThriftService = new JobLectureServiceThriftImpl(jobRequestSupport,
                                                                                            jobsQueueSupport, jobHistorySupport);

    final JobLectureService jobLectureService = new JobLectureServiceImpl(jobLectureCqlService, jobLectureThriftService);

    final JobClockConfiguration clockConfiguration = new JobClockConfiguration();

    clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
    clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);
    final JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace, clockConfiguration);

    // Récupération du job
    final JobRequest job = jobLectureService.getJobRequest(uuid);
    // Le job n'existe pas
    if (job == null) {
      throw new AucunJobException();
    }

    final boolean isSemaphoreExiste = isSemaphoreExistantJob(job, jobRequestDao,
                                                             jobsQueueDao, jobHistoryDao);

    final JobState state = job.getState();
    final String nomEtat = state.toString();

    // Suppression du job si il est dans l'état RESERVED, STARTING, CREATED
    if (!isSemaphoreExiste
        && ("RESERVED".equals(nomEtat) || "STARTING".equals(nomEtat) || "CREATED"
            .equals(nomEtat))) {

      final JobQueueThriftService jobQueueThriftService = new JobQueueServiceThriftImpl(jobRequestSupport,
                                                                                        jobsQueueSupport, jobClockSupport, jobHistorySupport, jobLectureService, null);
      final JobQueueService jobQueueService = new JobQueueServiceImpl(jobQueueCqlService, jobQueueThriftService);

      jobQueueService.deleteJob(uuid);
    } else {
      throw new MiseAJourJobException(
          "Le job a un sémaphore ou son état ne permet pas sa suppression.");
    }

  }

  /**
   * Methode permettant de savoir si un job a positionné un sémaphore.
   * 
   * @param job
   *            Job {@link JobRequest}
   * @param jobHistoryDao
   *            {@link JobHistoryDao}
   * @param jobsQueueDao
   *            {@link JobsQueueDao}
   * @param jobRequestDao
   *            {@link JobRequestDao}
   * @return True si le job a posé un sémaphore, false sinon.
   */
  private boolean isSemaphoreExistantJob(final JobRequest job, final JobRequestDao jobRequestDao, final JobsQueueDao jobsQueueDao,
                                         final JobHistoryDao jobHistoryDao) {

    final JobRequestSupport jobRequestSupport = new JobRequestSupport(jobRequestDao);

    final JobsQueueSupport jobsQueueSupport = new JobsQueueSupport(jobsQueueDao);

    final JobHistorySupport jobHistorySupport = new JobHistorySupport(jobHistoryDao);

    final JobLectureThriftService jobLectureThriftService = new JobLectureServiceThriftImpl(jobRequestSupport,
                                                                                            jobsQueueSupport, jobHistorySupport);

    if (job.getJobParameters() != null && !job.getJobParameters().isEmpty()) {
      final String codeTraitement = job.getJobParameters().get(Constantes.CODE_TRAITEMENT);
      if (codeTraitement != null && !codeTraitement.isEmpty()) {
        final JobLectureService jobLectureService = new JobLectureServiceImpl(jobLectureCqlService, jobLectureThriftService);
        final List<JobRequest> jobRequests = jobLectureService
            .getNonTerminatedJobs(Constantes.PREFIXE_SEMAPHORE_JOB + codeTraitement);
        if (jobRequests != null && !jobRequests.isEmpty()) {
          for (final JobRequest jobRequest : jobRequests) {
            if (job.getIdJob() != null && jobRequest != null
                && job.getIdJob().equals(jobRequest.getIdJob())) {
              return true;
            }
          }
        }
      }
    }

    return false;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public final List<JobHistory> getHistorique(final UUID uuid, final Keyspace keyspace) throws ErreurTechniqueException {
    final JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
    final JobRequestSupport jobRequestSupport = new JobRequestSupport(jobRequestDao);

    final JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
    final JobsQueueSupport jobsQueueSupport = new JobsQueueSupport(jobsQueueDao);

    final JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
    final JobHistorySupport jobHistorySupport = new JobHistorySupport(jobHistoryDao);

    final JobLectureThriftService jobLectureThriftService = new JobLectureServiceThriftImpl(jobRequestSupport,
                                                                                            jobsQueueSupport, jobHistorySupport);

    final JobLectureService jobLectureService = new JobLectureServiceImpl(jobLectureCqlService, jobLectureThriftService);

    List<JobHistory> listeJobHistory = null;
    try {
      listeJobHistory = jobLectureService.getJobHistory(uuid);
    } catch (final Exception e) {
      throw new ErreurTechniqueException(e);
    }
    return listeJobHistory;

  }

  @Override
  public final List<JobRequest> recupererTravauxEnCoursParServeur(final Keyspace keyspace) {
    final List<JobRequest> jobsEnCours = new ArrayList<>();

    final JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
    final JobRequestSupport jobRequestSupport = new JobRequestSupport(jobRequestDao);

    final JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
    final JobsQueueSupport jobsQueueSupport = new JobsQueueSupport(jobsQueueDao);

    final JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
    final JobHistorySupport jobHistorySupport = new JobHistorySupport(jobHistoryDao);

    final JobLectureThriftService jobLectureThriftService = new JobLectureServiceThriftImpl(jobRequestSupport,
                                                                                            jobsQueueSupport, jobHistorySupport);

    final JobClockConfiguration clockConfiguration = new JobClockConfiguration();

    clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
    clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);
    final JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace, clockConfiguration);

    final JobLectureService jobLectureService = new JobLectureServiceImpl(jobLectureCqlService, jobLectureThriftService);

    final JobQueueThriftService jobQueueThriftService = new JobQueueServiceThriftImpl(jobRequestSupport,
                                                                                      jobsQueueSupport, jobClockSupport, jobHistorySupport, jobLectureService, null);
    final JobQueueService jobQueueService = new JobQueueServiceImpl(jobQueueCqlService, jobQueueThriftService);

    // recupere la liste des hosts
    final List<String> hosts = jobQueueService.getHosts();

    // boucle sur les serveurs
    for (final String hostname : hosts) {
      if (StringUtils.isNotBlank(hostname)) {
        final List<JobRequest> jobs = jobLectureService.getNonTerminatedJobs(hostname);

        if (!jobs.isEmpty()) {
          // met le jobs
          final JobRequest jobfind = jobs.get(0);
          if (jobfind != null) {
            jobfind.setReservedBy(hostname);
            jobsEnCours.add(jobfind);
          } else {
            addNewJobToList(jobsEnCours, hostname);
          }
        } else {
          addNewJobToList(jobsEnCours, hostname);
        }
      }
    }

    return jobsEnCours;
  }

  @Override
  public final void debloquerJob(final String uuidJob, final String urlServiceWeb, final String login) throws ErreurTechniqueException {

    // Récupération du stub
    final SaeServiceStub stub = saeStubUtils.getStub(urlServiceWeb, login);

    final Deblocage request = new Deblocage();
    request.setDeblocage(new DeblocageRequestType());
    final UuidType uuidType = new UuidType();
    uuidType.setUuidType(uuidJob);
    request.getDeblocage().setUuid(uuidType);

    try {
      @SuppressWarnings("unused")
      final DeblocageResponse debResponse = stub.deblocage(request);
    } catch (final Exception e) {
      throw new ErreurTechniqueException(e);
    }

  }

  /**
   * Methode permettant d'ajouter un nouveau job à une liste de job.
   * 
   * @param jobs
   *            liste job
   * @param hostname
   *            key jobsQueues
   */
  private void addNewJobToList(final List<JobRequest> jobs, final String hostname) {
    final JobRequest jobVide = new JobRequest();
    jobVide.setReservedBy(hostname);
    jobs.add(jobVide);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public List<Job> refreshTousTravaux(final Keyspace keyspace, final int maxKeysToRead) {

    listeJobCache.refresh(keyspace);

    return listeJobCache.getUnchecked(keyspace);

  }

  /**
   * {@inheritDoc}
   * 
   */
  @Override
  public void intialisationCache(final Keyspace keyspace, final int maxKeysToRead, final int cacheDuration)
      throws ErreurTechniqueException {
    try {
      listeJobCache = CacheBuilder.newBuilder().refreshAfterWrite(cacheDuration, TimeUnit.MINUTES)
          .build(new CacheLoader<Keyspace, List<Job>>() {

            @Override
            public List<Job> load(final Keyspace keyspace) throws Exception {
              final List<Job> listeJobs = new ArrayList<>();

              final JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
              final JobRequestSupport jobRequestSupport = new JobRequestSupport(jobRequestDao);

              final JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
              final JobsQueueSupport jobsQueueSupport = new JobsQueueSupport(jobsQueueDao);

              final JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
              final JobHistorySupport jobHistorySupport = new JobHistorySupport(jobHistoryDao);

              final JobLectureThriftService jobLectureThriftService = new JobLectureServiceThriftImpl(jobRequestSupport,
                                                                                                      jobsQueueSupport, jobHistorySupport);

              final JobLectureService jobLectureService = new JobLectureServiceImpl(jobLectureCqlService, jobLectureThriftService);							

              final List<JobRequest> listeJobRequest = jobLectureService.getAllJobs(keyspace, maxKeysToRead);

              for (final JobRequest jobRequest : listeJobRequest) {
                final Job job = new Job();
                job.setClientHost(jobRequest.getClientHost());
                job.setCreationDate(jobRequest.getCreationDate());
                job.setDocCount(jobRequest.getDocCount());
                job.setDocCountTraite(jobRequest.getDocCountTraite());
                job.setEndingDate(jobRequest.getEndingDate());
                job.setIdJob(jobRequest.getIdJob());
                job.setMessage(jobRequest.getMessage());
                if (MapUtils.isEmpty(jobRequest.getJobParameters())) {
                  job.setParameters(jobRequest.getParameters());
                } else {
                  job.setJobParameters(jobRequest
                                       .getJobParameters());
                }
                job.setPid(jobRequest.getPid());
                job.setReservationDate(jobRequest
                                       .getReservationDate());
                job.setReservedBy(jobRequest.getReservedBy());
                job.setSaeHost(jobRequest.getSaeHost());
                job.setStartingDate(jobRequest.getStartingDate());
                job.setState(jobRequest.getState());
                job.setToCheckFlag(jobRequest.getToCheckFlag());
                job.setToCheckFlagRaison(jobRequest
                                         .getToCheckFlagRaison());
                job.setType(jobRequest.getType());
                job.setVi(jobRequest.getVi());
                job.setRemovable(isJobRemovable(jobRequest,
                                                jobLectureService, jobRequestDao, jobsQueueDao,
                                                jobHistoryDao));
                job.setResettable(jobLectureService
                                  .isJobResettable(jobRequest));
                job.setActiveSemaphore(isSemaphoreExistantJob(jobRequest,
                                                              jobRequestDao, jobsQueueDao, jobHistoryDao));
                listeJobs.add(job);
              }

              return listeJobs;
            }

          });

    } catch (final Exception e) {
      throw new ErreurTechniqueException(e);
    }
  }

}
