package fr.urssaf.image.sae.ihm.web.exploit.service.impl;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

import me.prettyprint.hector.api.Keyspace;

import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;

import fr.urssaf.image.commons.cassandra.support.clock.JobClockConfiguration;
import fr.urssaf.image.commons.cassandra.support.clock.JobClockSupport;
import fr.urssaf.image.commons.cassandra.support.clock.impl.JobClockSupportImpl;
import fr.urssaf.image.sae.commons.utils.Constantes;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucunJobException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.ErreurTechniqueException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.MiseAJourJobException;
import fr.urssaf.image.sae.ihm.web.exploit.modele.Job;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.SaeStubUtils;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.Deblocage;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.DeblocageRequestType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.DeblocageResponse;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.DeblocageResponseType;
import fr.urssaf.image.sae.ihm.web.exploit.saeservice.modele.SaeServiceStub.UuidType;
import fr.urssaf.image.sae.ihm.web.exploit.service.GererPileService;
import fr.urssaf.image.sae.pile.travaux.dao.JobHistoryDao;
import fr.urssaf.image.sae.pile.travaux.dao.JobRequestDao;
import fr.urssaf.image.sae.pile.travaux.dao.JobsQueueDao;
import fr.urssaf.image.sae.pile.travaux.exception.JobNonReinitialisableException;
import fr.urssaf.image.sae.pile.travaux.model.JobHistory;
import fr.urssaf.image.sae.pile.travaux.model.JobRequest;
import fr.urssaf.image.sae.pile.travaux.model.JobState;
import fr.urssaf.image.sae.pile.travaux.service.JobLectureService;
import fr.urssaf.image.sae.pile.travaux.service.JobQueueService;
import fr.urssaf.image.sae.pile.travaux.service.impl.JobLectureServiceImpl;
import fr.urssaf.image.sae.pile.travaux.service.impl.JobQueueServiceImpl;

/**
 * Classe implémentant le service GererPileService
 * 
 * 
 */
@Component
public class GererPileServiceImpl implements GererPileService {

   @Autowired
   private SaeStubUtils saeStubUtils;

   public static final int MAX_TIME_SYNCHRO_ERROR = 1000000;
   public static final int MAX_TIME_SYNCHRO_WARN = 1500000;

   private enum JobType {
      ALL_JOB
   };

   private LoadingCache<JobType, List<Job>> listeJobCache;

   /**
    * Renvoie la liste de tous les travaux actuellement dans la pile
    * 
    * @param keyspace
    *           le keyspace de la configuration choisie
    * @param maxKeysToRead
    *           nombre de clés maximum à récuperer lors de la lecture de la pile
    *           des travaux
    * @return Liste de tous les travaux actuellement dans la pile
    * @throws ErreurTechniqueException
    *            Exception levée lors de la recherche des jobs
    */
   @Override
   public final List<Job> rechercherTousTravaux(final Keyspace keyspace,
         final int maxKeysToRead)
               throws ErreurTechniqueException {
      return listeJobCache.getUnchecked(JobType.ALL_JOB);
   }

   /**
    * Renvoit le job correspondant à l'indentifiant
    * 
    * @param keyspace
    *           Le keyspace
    * @param idJob
    *           l'indentifiant du job à récupérer
    * @return Job récupéré
    * @throws AucunJobException 
    */
   @Override
   public final Job getJob(Keyspace keyspace, UUID idJob) throws AucunJobException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
      JobLectureService jobsLecture = new JobLectureServiceImpl(jobRequestDao,
            jobsQueueDao, jobHistoryDao);

      JobRequest jobRequest = jobsLecture.getJobRequest(idJob);
      Job job = new Job();

      if (jobRequest != null) {

         job.setClientHost(jobRequest.getClientHost());
         job.setCreationDate(jobRequest.getCreationDate());
         job.setDocCount(jobRequest.getDocCount());
         job.setDocCountTraite(jobRequest.getDocCountTraite());
         job.setEndingDate(jobRequest.getEndingDate());
         job.setIdJob(jobRequest.getIdJob());
         job.setMessage(jobRequest.getMessage());
         if (MapUtils.isEmpty(jobRequest.getJobParameters())) {
            job.setParameters(jobRequest.getParameters());
         } else {
            job.setJobParameters(jobRequest.getJobParameters());
         }
         job.setPid(jobRequest.getPid());
         job.setReservationDate(jobRequest.getReservationDate());
         job.setReservedBy(jobRequest.getReservedBy());
         job.setSaeHost(jobRequest.getSaeHost());
         job.setStartingDate(jobRequest.getStartingDate());
         job.setState(jobRequest.getState());
         job.setToCheckFlag(jobRequest.getToCheckFlag());
         job.setToCheckFlagRaison(jobRequest.getToCheckFlagRaison());
         job.setType(jobRequest.getType());
         job.setVi(jobRequest.getVi());
         job.setRemovable(isJobRemovable(jobRequest, jobsLecture,
               jobRequestDao, jobsQueueDao, jobHistoryDao));
         job.setResettable(jobsLecture.isJobResettable(jobRequest));
      } else {
         throw new AucunJobException(String.format(
               "Le job d'identifiant %s n'a pas été trouvé", idJob));
      }
      return job;
   }

   /**
    * Methode permettant de
    * 
    * @param jobRequest
    *           Job {@link JobRequest}
    * @param jobsLecture
    *           {@link JobLectureService}
    * @param jobHistoryDao
    *           {@link JobHistoryDao}
    * @param jobsQueueDao
    *           {@link JobsQueueDao}
    * @param jobRequestDao
    *           {@link JobRequestDao}
    * @return True si le job est supprimable, false sinon.
    */
   private boolean isJobRemovable(JobRequest jobRequest,
         JobLectureService jobsLecture, JobRequestDao jobRequestDao,
         JobsQueueDao jobsQueueDao, JobHistoryDao jobHistoryDao) {
      return jobsLecture.isJobRemovable(jobRequest)
            && !isSemaphoreExistantJob(jobRequest, jobRequestDao, jobsQueueDao,
                  jobHistoryDao);
   }

   /**
    * Mise à jour du travail afin que celui-ci soit en état d'être relancé par
    * l'ordonnanceur
    * 
    * @param uuid
    *           Identifiant unique du travail à mettre à jour
    * @param keyspace
    *           le keyspace de la configuration choisie
    * @throws AucunJobException
    *            Exception levée lorsque le travail à supprimer n'existe pas
    * @throws MiseAJourJobException
    *            Exception levée lorsque le travail ne satisfait pas aux
    *            conditions de suppression
    * @throws JobNonReinitialisableException
    *            Exception levée si le job ne peut pas être relancé
    */
   @Override
   public final void remettreTravailEtatLancement(UUID uuid, Keyspace keyspace)
         throws AucunJobException, MiseAJourJobException,
         JobNonReinitialisableException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobClockConfiguration clockConfiguration = new JobClockConfiguration();
      clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
      clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);

      JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
            clockConfiguration);

      JobLectureService jobLectureService = new JobLectureServiceImpl(
            jobRequestDao, jobsQueueDao, jobHistoryDao);

      // Récupération du job
      JobRequest job = jobLectureService.getJobRequest(uuid);
      // Le job n'existe pas
      if (job == null) {
         throw new AucunJobException();
      }
      JobState state = job.getState();
      String nomEtat = state.toString();

      // Mise à jour du job s'il est dans l'état RESERVED ou STARTING
      if ("RESERVED".equals(nomEtat) || "STARTING".equals(nomEtat)) {

         JobQueueService jobQueueService = new JobQueueServiceImpl(
               jobRequestDao, jobsQueueDao, jobClockSupport, jobHistoryDao,
               jobLectureService, null);

         jobQueueService.resetJob(uuid);
      } else {
         throw new MiseAJourJobException(
               "L'état du job ne permet pas sa remise en état de lancement.");
      }

   }

   /**
    * Supprime le travail dont l'identifiant est passé en paramètre
    * 
    * @param uuid
    *           Identifiant unique du travail à supprimer
    * @param keyspace
    *           le keyspace de la configuration choisie
    * @throws AucunJobException
    *            Exception levée lorsque le travail à supprimer n'existe pas
    * @throws MiseAJourJobException
    *            Exception levée lorsque le travail ne satisfait pas aux
    *            conditions de suppression
    */
   @Override
   public final void supprimerTravail(UUID uuid, Keyspace keyspace)
         throws AucunJobException, MiseAJourJobException {

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobClockConfiguration clockConfiguration = new JobClockConfiguration();

      clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
      clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);
      JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
            clockConfiguration);

      JobLectureService jobLectureService = new JobLectureServiceImpl(
            jobRequestDao, jobsQueueDao, jobHistoryDao);

      // Récupération du job
      JobRequest job = jobLectureService.getJobRequest(uuid);
      // Le job n'existe pas
      if (job == null) {
         throw new AucunJobException();
      }

      boolean isSemaphoreExiste = isSemaphoreExistantJob(job, jobRequestDao,
            jobsQueueDao, jobHistoryDao);

      JobState state = job.getState();
      String nomEtat = state.toString();

      // Suppression du job si il est dans l'état RESERVED, STARTING, CREATED
      if (!isSemaphoreExiste
            && ("RESERVED".equals(nomEtat) || "STARTING".equals(nomEtat) || "CREATED"
                  .equals(nomEtat))) {

         JobQueueService jobQueueService = new JobQueueServiceImpl(
               jobRequestDao, jobsQueueDao, jobClockSupport, jobHistoryDao,
               jobLectureService, null);

         jobQueueService.deleteJob(uuid);
      } else {
         throw new MiseAJourJobException(
               "Le job a un sémaphore ou son état ne permet pas sa suppression.");
      }

   }

   /**
    * Methode permettant de savoir si un job a positionné un sémaphore.
    * 
    * @param job
    *           Job {@link JobRequest}
    * @param jobHistoryDao
    *           {@link JobHistoryDao}
    * @param jobsQueueDao
    *           {@link JobsQueueDao}
    * @param jobRequestDao
    *           {@link JobRequestDao}
    * @return True si le job a posé un sémaphore, false sinon.
    */
   private boolean isSemaphoreExistantJob(JobRequest job,
         JobRequestDao jobRequestDao, JobsQueueDao jobsQueueDao,
         JobHistoryDao jobHistoryDao) {
      if (job.getJobParameters() != null && !job.getJobParameters().isEmpty()) {
         String codeTraitement = job.getJobParameters().get(
               Constantes.CODE_TRAITEMENT);
         if (codeTraitement != null && !codeTraitement.isEmpty()) {
            JobLectureService jobLectureService = new JobLectureServiceImpl(
                  jobRequestDao, jobsQueueDao, jobHistoryDao);
            List<JobRequest> jobRequests = jobLectureService
                  .getNonTerminatedJobs(Constantes.PREFIXE_SEMAPHORE_JOB
                        + codeTraitement);
            if (jobRequests != null && !jobRequests.isEmpty()) {
               for (JobRequest jobRequest : jobRequests) {
                  if (job.getIdJob() != null && jobRequest != null
                        && job.getIdJob().equals(jobRequest.getIdJob())) {
                     return true;
                  }
               }
            }
         }
      }

      return false;
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public final List<JobHistory> getHistorique(UUID uuid, Keyspace keyspace)
         throws ErreurTechniqueException {
      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobLectureService jobLectureService = new JobLectureServiceImpl(
            jobRequestDao, jobsQueueDao, jobHistoryDao);

      List<JobHistory> listeJobHistory = null;
      try {
         listeJobHistory = jobLectureService.getJobHistory(uuid);
      } catch (Exception e) {
         throw new ErreurTechniqueException(e);
      }
      return listeJobHistory;

   }


   @Override
   public final List<JobRequest> recupererTravauxEnCoursParServeur(Keyspace keyspace) {
      List<JobRequest> jobsEnCours = new ArrayList<JobRequest>();

      JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);

      JobClockConfiguration clockConfiguration = new JobClockConfiguration();

      clockConfiguration.setMaxTimeSynchroError(MAX_TIME_SYNCHRO_ERROR);
      clockConfiguration.setMaxTimeSynchroWarn(MAX_TIME_SYNCHRO_WARN);
      JobClockSupport jobClockSupport = new JobClockSupportImpl(keyspace,
            clockConfiguration);

      JobLectureService jobLectureService = new JobLectureServiceImpl(
            jobRequestDao, jobsQueueDao, jobHistoryDao);

      JobQueueService jobQueueService = new JobQueueServiceImpl(jobRequestDao,
            jobsQueueDao, jobClockSupport, jobHistoryDao, jobLectureService,
            null);

      // recupere la liste des hosts
      List<String> hosts = jobQueueService.getHosts();

      // boucle sur les serveurs
      for (String hostname : hosts) {
         if (StringUtils.isNotBlank(hostname)) {
            List<JobRequest> jobs = jobLectureService.getNonTerminatedJobs(hostname);

            if (!jobs.isEmpty()) {
               // met le jobs
               JobRequest jobfind = jobs.get(0);
               if (jobfind != null) {
                  jobfind.setReservedBy(hostname);
                  jobsEnCours.add(jobfind);
               } else {
                  addNewJobToList(jobsEnCours, hostname);
               }
            } else {
               addNewJobToList(jobsEnCours, hostname);
            }
         }
      }

      return jobsEnCours;
   }

   @Override
   public final void debloquerJob(String uuidJob, String urlServiceWeb, String login)
         throws ErreurTechniqueException {

      // Récupération du stub
      SaeServiceStub stub = saeStubUtils.getStub(urlServiceWeb, login);

      Deblocage request = new Deblocage();
      request.setDeblocage(new DeblocageRequestType());
      UuidType uuidType = new UuidType();
      uuidType.setUuidType(uuidJob);
      request.getDeblocage().setUuid(uuidType);

      DeblocageResponseType response= null;

      try {
         DeblocageResponse debResponse = stub.deblocage(request);
         if (debResponse != null) {
            response = debResponse.getDeblocageResponse();
            if (response == null) {
               throw new ErreurTechniqueException(
                     "Le WS de déblocage n'a pas répondu.");
            }
         } else {
            throw new ErreurTechniqueException(
                  "Le WS de déblocage n'a pas répondu.");
         }

      } catch (RemoteException e) {
         throw new ErreurTechniqueException(e);
      }      

   }

   /**
    * Methode permettant d'ajouter un nouveau job à une liste de job.
    * 
    * @param jobs
    *           liste job
    * @param hostname
    *           key jobsQueues
    */
   private void addNewJobToList(List<JobRequest> jobs, String hostname) {
      JobRequest jobVide = new JobRequest();
      jobVide.setReservedBy(hostname);
      jobs.add(jobVide);
   }

   /**
    * {@inheritDoc}
    */
   @Override
   public List<Job> refreshTousTravaux(Keyspace keyspace, int maxKeysToRead) {

      listeJobCache.refresh(JobType.ALL_JOB);

      return listeJobCache.getUnchecked(JobType.ALL_JOB);

   }

   /**
    * {@inheritDoc}
    * 
    */
   @Override
   public void intialisationCache(final Keyspace keyspace,
         final int maxKeysToRead, int cacheDuration)
               throws ErreurTechniqueException {
      final JobRequestDao jobRequestDao = new JobRequestDao(keyspace);
      final JobsQueueDao jobsQueueDao = new JobsQueueDao(keyspace);
      final JobHistoryDao jobHistoryDao = new JobHistoryDao(keyspace);
      final JobLectureService jobsLecture = new JobLectureServiceImpl(
            jobRequestDao, jobsQueueDao, jobHistoryDao);

      try {
         listeJobCache = CacheBuilder.newBuilder()
               .refreshAfterWrite(cacheDuration, TimeUnit.MINUTES)
               .build(new CacheLoader<JobType, List<Job>>() {

                  @Override
                  public List<Job> load(JobType key) throws Exception {
                     List<Job> listeJobs = new ArrayList<Job>();
                     if (key.equals(JobType.ALL_JOB)) {
                        List<JobRequest> listeJobRequest = jobsLecture
                              .getAllJobs(keyspace, maxKeysToRead);

                        for (JobRequest jobRequest : listeJobRequest) {
                           Job job = new Job();
                           job.setClientHost(jobRequest.getClientHost());
                           job.setCreationDate(jobRequest.getCreationDate());
                           job.setDocCount(jobRequest.getDocCount());
                           job.setDocCountTraite(jobRequest.getDocCountTraite());
                           job.setEndingDate(jobRequest.getEndingDate());
                           job.setIdJob(jobRequest.getIdJob());
                           job.setMessage(jobRequest.getMessage());
                           if (MapUtils.isEmpty(jobRequest.getJobParameters())) {
                              job.setParameters(jobRequest.getParameters());
                           } else {
                              job.setJobParameters(jobRequest
                                    .getJobParameters());
                           }
                           job.setPid(jobRequest.getPid());
                           job.setReservationDate(jobRequest
                                 .getReservationDate());
                           job.setReservedBy(jobRequest.getReservedBy());
                           job.setSaeHost(jobRequest.getSaeHost());
                           job.setStartingDate(jobRequest.getStartingDate());
                           job.setState(jobRequest.getState());
                           job.setToCheckFlag(jobRequest.getToCheckFlag());
                           job.setToCheckFlagRaison(jobRequest
                                 .getToCheckFlagRaison());
                           job.setType(jobRequest.getType());
                           job.setVi(jobRequest.getVi());
                           job.setRemovable(isJobRemovable(jobRequest,
                                 jobsLecture, jobRequestDao, jobsQueueDao,
                                 jobHistoryDao));
                           job.setResettable(jobsLecture
                                 .isJobResettable(jobRequest));
                           listeJobs.add(job);
                        }

                     }

                     return listeJobs;
                  }

               });

      } catch (Exception e) {
         throw new ErreurTechniqueException(e);
      }
   }

}
