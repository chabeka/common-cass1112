package fr.urssaf.image.sae.ihm.web.exploit.controller;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import javax.validation.Valid;

import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ResourceBundleMessageSource;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;

import com.docubase.dfce.exception.SearchQueryParseException;

import fr.urssaf.image.commons.cassandra.helper.CassandraCQLClientFactory;
import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucunDocumentException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.ErreurTechniqueException;
import fr.urssaf.image.sae.ihm.web.exploit.formulaire.RechercherDocumentsForm;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationEnvironnement;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationEnvironnementFrontal;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationsEnvironnement;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationsEnvironnementFrontal;
import fr.urssaf.image.sae.ihm.web.exploit.modele.Metadonnee;
import fr.urssaf.image.sae.ihm.web.exploit.modele.SaeDonneesRecherche;
import fr.urssaf.image.sae.ihm.web.exploit.modele.SaeResultatRecherche;
import fr.urssaf.image.sae.ihm.web.exploit.modele.SearchQueryParserResult;
import fr.urssaf.image.sae.ihm.web.exploit.service.MetadonneesService;
import fr.urssaf.image.sae.ihm.web.exploit.service.RechercherService;
import fr.urssaf.image.sae.ihm.web.exploit.service.impl.MetadonneesServiceImpl;
import fr.urssaf.image.sae.ihm.web.exploit.utils.Constants;
import fr.urssaf.image.sae.ihm.web.exploit.utils.SearchQueryParserUtils;
import fr.urssaf.image.sae.ihm.web.exploit.utils.UtilsController;
import fr.urssaf.image.sae.metadata.exceptions.ReferentialException;
import fr.urssaf.image.sae.metadata.referential.model.MetadataReference;
import fr.urssaf.image.sae.storage.dfce.context.StorageApplicationContext;
import fr.urssaf.image.sae.storage.dfce.model.StorageTechnicalMetadatas;
import fr.urssaf.image.sae.storage.exception.StorageException;
import me.prettyprint.hector.api.Keyspace;

/**
 * Classe centralisant les opérations utilisateurs pour la recherche de
 * documents
 * 
 * 
 */
@Controller
public class RechercherDocumentController {

   /**
    * Service offrant les opérations de recherche sur un ou plusieurs documents
    */
   @Autowired
   private RechercherService rechercherService;

   @Autowired
   private ConfigurationsEnvironnement configs;

   @Autowired
   private ConfigurationsEnvironnementFrontal frontaux;

   private static final int NB_LIGNES_TABLEAU = 10;

  /**
   * Classe utilisée juste pour le chargement des ressource statique
   * commune à tous les utilisateurs
   * Ne pas l'utiliser pour des ressource dynamique sinon risque
   * de collision si plusieurs utilisation connecté sur la plateforme
   */
  @Autowired
  ApplicationContext ctx;

  /**
   * Classe utilisée juste pour le chargement des ressource statique
   * commune à tous les utilisateurs
   */
  @Autowired
  private ConfigurableBeanFactory beanFactory;
   /**
    * Initialisation du formulaire de recherche de documents
    * 
    * @param model
    *           le modèle
    * @param session
    *           la session
    * @param request
    *           la requête
    * @return la page à afficher
    * @throws InterruptedException
    *            l'exception levée
    */
   @RequestMapping(value = "rechercherDocuments")
   public final String initialisation(final Model model, final HttpSession session,
         final HttpServletRequest request) {

      // Récupération du Frontal de la session
      //String frontal = (String) session.getAttribute("nomFrontal");
      final String nomConfiguration = (String) session.getAttribute("nomConfiguration");
      final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext()
            .getAttribute(Constants.CQL);
      // on récupère le nom du frontal correspondant à la config GED
      final String frontal = UtilsController.getListFrontalByEnvName(configs, frontaux,nomConfiguration); 

      final List<String> listNomFrontaux = frontaux.getListeNoms();
      request.setAttribute("listNomFrontaux", listNomFrontaux);

      // Permet d'identifier le frontal choisi
      ConfigurationEnvironnementFrontal frontalChoisie;

      // S'il n'y a pas de frontal associé, on charge le premier de la liste
      if (StringUtils.isBlank(frontal)) {
         frontalChoisie = frontaux.getConfigurationsFrontaux()[0];
      } else {
         frontalChoisie = frontaux.getConfigurationFrontal(frontal);
      }


      // On charge le frontal en session
      session.setAttribute("nomFrontal", frontalChoisie.getNom());
      // On charge le nom de l'environnement en session
      session.setAttribute("nomConfiguration", nomConfiguration);

      request.setAttribute("frontal", frontalChoisie);

      // Instancie le service des métadonnées dans la configuration courante
      final MetadonneesService metaService = new MetadonneesServiceImpl(session,
            configs,
            ccf);

      // Préparation de la liste des métadonnées disponibles en recherche
      final List<Metadonnee> listeMetaRecherchable = metaReferenceToMetadonnee(metaService
            .findMetadatasRecherchables());
      request.setAttribute("listeMetaRecherche", listeMetaRecherchable);

      // Préparation de la liste des métadonnées disponibles pour la
      // consultation
      final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
            .findMetadatasConsultables());
      request.setAttribute("listeMetaAffichage", listeMetaConsultable);

      final RechercherDocumentsForm form = new RechercherDocumentsForm();
      form.setNbLignesTableau(NB_LIGNES_TABLEAU);
      model.addAttribute("rechercheForm", form);
      form.setFrontal(frontalChoisie.getNom());

      return "rechercherDocuments";

   }

   /**
    * Lance la recherche de documents
    * 
    * @param rechercheForm
    *           le formulaire
    * @param result
    *           gestion des erreurs
    * @param session
    *           la session
    * @param request
    *           la requête
    * @return la page à afficher
    */
   @RequestMapping(value = "afficherDocuments")
   public final String rechercherDocuments(
         @ModelAttribute("rechercheForm") @Valid final RechercherDocumentsForm rechercheForm,
         final BindingResult result, final HttpSession session, final HttpServletRequest request) {

      boolean changementFrontal;

      final String nomConfiguration = (String) session.getAttribute("nomConfiguration");
      final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext()
            .getAttribute(Constants.CQL);
      // Permet d'identifier le frontal choisi
      ConfigurationEnvironnementFrontal frontal;
      String nomFrontal = rechercheForm.getFrontal();

      if(nomFrontal !=null &&
            !nomFrontal.equalsIgnoreCase((String) session.getAttribute("nomFrontal"))){
         changementFrontal = true;
      }else {
         changementFrontal = false;
      }

      if(StringUtils.isBlank(nomFrontal) && 
            StringUtils.isNotBlank((String) session.getAttribute("nomFrontal"))) {
         nomFrontal = (String) session.getAttribute("nomFrontal");
      }

      // Récupérer la configuration frontal
      // S'il n'y a pas de frontal en session, on charge le premier de la liste
      if (StringUtils.isBlank(nomFrontal) ) {
         frontal = frontaux.getConfigurationsFrontaux()[0];
      } else {
         frontal = frontaux.getConfigurationFrontal(nomFrontal);
      }

      // Le nom de l'environnement GED source
      // final String nomConfiguration = (String) session.getAttribute("nomConfiguration");
      final ConfigurationEnvironnement envConfig = configs.getConfiguration(nomConfiguration);
      final String urlServiceWebGed = envConfig.getUrlWs().toString();
      // Chargement de la liste des frontaux
      //List<String> listNomFrontaux = UtilsController.getListFrontalByEnvName(config, frontaux,nomConfiguration);
      final List<String> listNomFrontaux = frontaux.getListeNoms();
      request.setAttribute("listNomFrontaux", listNomFrontaux);

      // si changement du frontal
      session.setAttribute("nomFrontal", nomFrontal);
      request.setAttribute("frontal",
            frontaux.getConfigurationFrontal(nomFrontal));

      // Nombre de ligne max du tableau de résultat
      if (rechercheForm.getNbLignesTableau() == 0) {
         rechercheForm.setNbLignesTableau(NB_LIGNES_TABLEAU);
         request.setAttribute("nbLignesTableau", NB_LIGNES_TABLEAU);
      } else {
         request.setAttribute("nbLignesTableau",
               rechercheForm.getNbLignesTableau());
      }

      if (!result.hasFieldErrors() || !changementFrontal) {
         try {

            SaeResultatRecherche srr;
            // Récupération de la requête Lucène
            final String requeteLucene = rechercheForm.getRequeteLucene();
            // Récupération des métadonnées à afficher en retour
            final List<String> codesMeta = rechercheForm.getCodeMeta();

            final String urlServiceWebFrontal = frontal.getUrlWsFrontal().toString();

            // Récupération du login de l'utilisateur (pour la traçabilité)
            final String login = (String) session.getAttribute("login");

            // On ne lance pas la recherche suite au changement du
            // frontal ou en cas d'erreur de validation
            if(!changementFrontal && !result.hasFieldErrors()) {
               // Lancement de la recherche    
               // Si passage directement par url GED
               if(rechercheForm.isModeRechercheURLGED()) {
                  srr = rechercherService.rechercherDocuments(requeteLucene,
                        codesMeta, urlServiceWebGed, login);
               }else {
                  srr = rechercherService.rechercherDocuments(requeteLucene,
                        codesMeta, urlServiceWebFrontal, login);
               }

               request.setAttribute("resRecherche", srr);
               request.setAttribute("resByUrlGed", rechercheForm.isModeRechercheURLGED());

               // Noms des colonnes à afficher
               final List<SaeDonneesRecherche> sdr = srr.getDonnees();
               final List<String> entete = new ArrayList<>();
               final List<Metadonnee> listeMeta = sdr.get(0).getMetadonnees();
               for (final Metadonnee meta : listeMeta) {
                  entete.add(meta.getCode());
               }
               request.setAttribute("entete", entete);
            }

         } catch (final ErreurTechniqueException e) {
            final ObjectError erreur = new ObjectError("rechercheForm",
                  e.getMessage());
            result.addError(erreur);
            final StringWriter sw = new StringWriter();
            final PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            final String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);
         } catch (final AucunDocumentException e) {
            final ObjectError erreur = new ObjectError("rechercheForm",
                  "Cette requête n'a retourné aucun résultat");
            result.addError(erreur);
         }
      }

      if(changementFrontal){
         request.setAttribute("validationForm", null);
      } else {
         request.setAttribute("validationForm", true);
      }
      // Instancie le service des métadonnées dans la configuration courante
      final MetadonneesService metaService = new MetadonneesServiceImpl(session,
            configs,
            ccf);

      // Préparation de la liste des métadonnées disponibles en recherche
      final List<Metadonnee> listeMetaRecherchable = metaReferenceToMetadonnee(metaService
            .findMetadatasRecherchables());
      request.setAttribute("listeMetaRecherche", listeMetaRecherchable);

      // Préparation de la liste des métadonnées disponibles pour la
      // consultation
      final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
            .findMetadatasConsultables());
      request.setAttribute("listeMetaAffichage", listeMetaConsultable);

      return "rechercherDocuments";
   }

   @RequestMapping(value = "rechercherDocumentsEnCorbeille")
   public final String initRechercheCorbeille(final Model model, final HttpSession session,
         final HttpServletRequest request) throws InterruptedException {

      final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext()
            .getAttribute(Constants.CQL);// Instancie le service des métadonnées dans la configuration courante
      final MetadonneesService metaService = new MetadonneesServiceImpl(session,
            configs,
            ccf);

      // Préparation de la liste des métadonnées disponibles en recherche
      final List<Metadonnee> listeMetaRecherchable = metaReferenceToMetadonnee(metaService
            .findMetadatasRecherchables());

      // On enlève le GEL de la liste des métadonnées consultables dans la
      // corbeille
      int indexGel = -1;
      for (final Metadonnee metadonnee : listeMetaRecherchable) {
         if (metadonnee.getShortCode().equals(
               StorageTechnicalMetadatas.GEL.getShortCode())) {
            indexGel = listeMetaRecherchable.indexOf(metadonnee);
         }
      }
      if (indexGel > 0) {
         listeMetaRecherchable.remove(indexGel);
      }

      request.setAttribute("listeMetaRecherche", listeMetaRecherchable);

      // Préparation de la liste des métadonnées disponibles pour la
      // consultation
      final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
            .findMetadatasConsultables());

      // On enlève le GEL de la liste des métadonnées consultables dans la
      // corbeille
      indexGel = -1;
      for (final Metadonnee metadonnee : listeMetaConsultable) {
         if (metadonnee.getShortCode().equals(
               StorageTechnicalMetadatas.GEL.getShortCode())) {
            indexGel = listeMetaConsultable.indexOf(metadonnee);
         }
      }
      if (indexGel > 0) {
         listeMetaConsultable.remove(indexGel);
      }

      request.setAttribute("listeMetaAffichage", listeMetaConsultable);

      final RechercherDocumentsForm form = new RechercherDocumentsForm();
      form.setNbLignesTableau(NB_LIGNES_TABLEAU);
      model.addAttribute("rechercheForm", form);

      return "rechercherDocumentsEnCorbeille";

   }

   @RequestMapping(value = "afficherDocumentsEnCorbeille")
   public final String rechercherDocumentsEnCorbeille(
         @ModelAttribute("rechercheForm") @Valid final RechercherDocumentsForm rechercheForm,
         final BindingResult result, final HttpSession session, final HttpServletRequest request) {

    // permet de charger les ressouces statique utile dans sae-storage-dfce
    if (!ctx.containsBean("messageSource_sae_storage_dfce")) {
      StorageApplicationContext.setContext(ctx);
      final ResourceBundleMessageSource source = new ResourceBundleMessageSource();
      source.setBasenames("i18n/storage_dfce_messages_fr_FR");
      source.setUseCodeAsDefaultMessage(true);
      beanFactory.registerSingleton("messageSource_sae_storage_dfce", source);
    }

    final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext()
            .getAttribute(Constants.CQL);
      // Affectation du ccf au composant rechercherService
      // Instancie le service des métadonnées dans la configuration courante
      final MetadonneesService metaService = new MetadonneesServiceImpl(session,
            configs,
            ccf);

      final SearchQueryParserUtils queryParser = new SearchQueryParserUtils(metaService);

      // Préparation de la liste des métadonnées disponibles en recherche
      final List<Metadonnee> listeMetaRecherchable = metaReferenceToMetadonnee(metaService
            .findMetadatasRecherchables());

      // On enlève le GEL de la liste des métadonnées consultables dans la
      // corbeille
      int indexGel = -1;
      for (final Metadonnee metadonnee : listeMetaRecherchable) {
         if (metadonnee.getShortCode().equals(
               StorageTechnicalMetadatas.GEL.getShortCode())) {
            indexGel = listeMetaRecherchable.indexOf(metadonnee);
         }
      }
      if (indexGel > 0) {
         listeMetaRecherchable.remove(indexGel);
      }

      request.setAttribute("listeMetaRecherche", listeMetaRecherchable);
      request.setAttribute("resByUrlGed", rechercheForm.isModeRechercheURLGED());

      if (!result.hasFieldErrors()) {
         try {
            // Nombre de ligne max du tableau de résultat
            int nbrLignes = 0;
            if (rechercheForm.getNbLignesTableau() == 0) {
               rechercheForm.setNbLignesTableau(NB_LIGNES_TABLEAU);
               request.setAttribute("nbLignesTableau", NB_LIGNES_TABLEAU);
               nbrLignes = NB_LIGNES_TABLEAU;
            } else {
               request.setAttribute("nbLignesTableau",
                     rechercheForm.getNbLignesTableau());
               nbrLignes = rechercheForm.getNbLignesTableau();
            }

            SaeResultatRecherche srr;
            // Récupération de la requête Lucène
            final String requete = rechercheForm.getRequeteLucene();

            // Reconversion du code de la requête
            final SearchQueryParserResult queryParserResult = queryParser.convertFromLongToShortCode(requete);
            
            // Récupération des métadonnées à afficher en retour
            final List<String> shortCodesMeta = rechercheForm.getShortCodeMeta();

            // Récupération de la configuration choisie
            final String nomConf = (String) session.getAttribute("nomConfiguration");
            final Keyspace keyspace = (Keyspace) session.getServletContext()
                  .getAttribute(nomConf);
            final DFCEConnection dfceConnection = (DFCEConnection) session
                  .getServletContext().getAttribute(nomConf + "-dfce");

            srr = rechercherService.getDocsFromRecycleBin(dfceConnection,
                  queryParserResult.getRequeteCodeCourts(),
                  shortCodesMeta,
                  nbrLignes,
                  keyspace,
                  ccf);

            if (srr == null || srr != null && srr.getNbResultat() == 0) {
               final ObjectError erreur = new ObjectError("rechercheForm",
                     "Cette requête n'a retourné aucun résultat");
               result.addError(erreur);
            } else {
               // Noms des colonnes à afficher
               List<SaeDonneesRecherche> sdr = srr.getDonnees();
               // 1- Calculer l'entete du resultat de recherche
               final List<String> entete = calculerEnteteRecherche(
                     listeMetaRecherchable, sdr);
               request.setAttribute("entete", entete);

               // 2- Conversion et réorganisation des résultats
               sdr = recalculeFormatResultatRecherche(sdr,
                     listeMetaRecherchable, entete);
               srr.setDonnees(sdr);
               request.setAttribute("resRecherche", srr);
            }
         } catch (final AucunDocumentException e) {
            final ObjectError erreur = new ObjectError("rechercheForm",
                  "Cette requête n'a retourné aucun résultat");
            result.addError(erreur);
         } catch (final ReferentialException e) {
            final ObjectError erreur = new ObjectError("rechercheForm",
                  e.getMessage());
            result.addError(erreur);
            final StringWriter sw = new StringWriter();
            final PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            final String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);
         } catch (final StorageException e) {
            final ObjectError erreur = new ObjectError("rechercheForm",
                  e.getMessage());
            result.addError(erreur);
            final StringWriter sw = new StringWriter();
            final PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            final String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);
         } catch (final IOException e) {
            final ObjectError erreur = new ObjectError("rechercheForm",
                  e.getMessage());
            result.addError(erreur);
            final StringWriter sw = new StringWriter();
            final PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            final String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);
         }
          catch (final SearchQueryParseException e) {
           final ObjectError erreur = new ObjectError("rechercheForm", e.getMessage());
           result.addError(erreur);
           final StringWriter sw = new StringWriter();
           final PrintWriter pw = new PrintWriter(sw);
           e.printStackTrace(pw);
           final String stacktrace = sw.toString();
           request.setAttribute("stacktrace", stacktrace);
          } catch (final Exception e) {
            throw e;
          }
      }

      // Préparation de la liste des métadonnées disponibles pour la
      // consultation
      final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
            .findMetadatasConsultables());

      indexGel = -1;
      for (final Metadonnee metadonnee : listeMetaConsultable) {
         if (metadonnee.getShortCode().equals(
               StorageTechnicalMetadatas.GEL.getShortCode())) {
            indexGel = listeMetaConsultable.indexOf(metadonnee);
         }
      }
      if (indexGel > 0) {
         listeMetaConsultable.remove(indexGel);
      }

      request.setAttribute("listeMetaAffichage", listeMetaConsultable);

      return "rechercherDocumentsEnCorbeille";
   }

   /**
    * Permet de formatter et organiser les métadonnées dans le resultat de
    * recherche
    * 
    * @param sdr
    * @param listeMetaRecherchable
    * @param entete
    * @return
    */
   private List<SaeDonneesRecherche> recalculeFormatResultatRecherche(
         final List<SaeDonneesRecherche> sdr, final List<Metadonnee> listeMetaRecherchable,
         final List<String> entete) {

      final List<SaeDonneesRecherche> saeResRecherche = new ArrayList<>();
      final List<String> ordreShortCodeMetadonne = getOrdreResultatMetadonnee(sdr
            .get(0).getMetadonnees());

      SaeDonneesRecherche sResRecherche = null;

      for (final SaeDonneesRecherche saeDonneesRecherche : sdr) {
         sResRecherche = new SaeDonneesRecherche(
               recalculeMetadonneResultatRecherche(saeDonneesRecherche,
                     ordreShortCodeMetadonne, entete),
               saeDonneesRecherche.getUuid());
         saeResRecherche.add(sResRecherche);
      }

      return saeResRecherche;
   }

   /**
    * Reorganisation des métadonnées passées en paramètre dans l'ordre de
    * l'entete
    * 
    * @param saeDonneesRecherche
    * @param ordreShortCodeMetadonne
    * @param entete
    * @return
    */
   private List<Metadonnee> recalculeMetadonneResultatRecherche(
         final SaeDonneesRecherche saeDonneesRecherche,
         final List<String> ordreShortCodeMetadonne, final List<String> entete) {
      final List<Metadonnee> listMetadonneeOrdonnee = new ArrayList<>();

      for (final String shortCode : ordreShortCodeMetadonne) {
         for (final Metadonnee metadonnee : saeDonneesRecherche.getMetadonnees()) {
            if (shortCode.equals(metadonnee.getCode())) {
               metadonnee.setCode(entete.get(ordreShortCodeMetadonne
                     .indexOf(shortCode)));
               listMetadonneeOrdonnee.add(metadonnee);
            }
         }
      }
      return listMetadonneeOrdonnee;
   }

   /**
    * Retourne l'ordre des métadonnées du résultat de recherche
    * 
    * @param metadonnees
    * @return
    */
   private List<String> getOrdreResultatMetadonnee(final List<Metadonnee> metadonnees) {

      final List<String> ordreShortCodeMetadonneeEntete = new ArrayList<>();
      for (final Metadonnee metadonnee : metadonnees) {
         ordreShortCodeMetadonneeEntete.add(metadonnee.getCode());
      }
      return ordreShortCodeMetadonneeEntete;
   }

   /**
    * Calcule l'entête du résultat de recherche
    * 
    * @param listeMetaRecherchable
    * @param sdr
    * @return
    */
   private List<String> calculerEnteteRecherche(
         final List<Metadonnee> listeMetaRecherchable, final List<SaeDonneesRecherche> sdr) {

      final List<String> entete = new ArrayList<>();
      final List<Metadonnee> listeMeta = sdr.get(0).getMetadonnees();
      for (final Metadonnee meta : listeMeta) {
         entete.add(getCodeMetadonneeByShortCode(listeMetaRecherchable,
               meta.getCode()));

      }
      return entete;
   }

   /**
    * Retourne le code de la métadonnée à partir de son shortCode passé en
    * paramètre
    * 
    * @param listeMetaRecherchable
    * @param shortCode
    * @return le code de la métadonnée sil existe, sinon son shortCode est
    *         retourné
    */
   private String getCodeMetadonneeByShortCode(
         final List<Metadonnee> listeMetaRecherchable, final String shortCode) {
      String codeMeta = null;
      for (final Metadonnee metadonnee : listeMetaRecherchable) {
         if (shortCode.equals(metadonnee.getShortCode())) {
            if (metadonnee.getCode() != null) {
               codeMeta = metadonnee.getCode();
            } else {
               codeMeta = shortCode;
            }
         }
      }
      if (codeMeta == null) {
         codeMeta = shortCode;
      }
      return codeMeta;
   }

   /**
    * Convertie une liste de MetadataReference en une liste de Metadonnee
    * 
    * @param findMetadatasRecherchables
    * @return une liste de Metadonnee
    */
   private List<Metadonnee> metaReferenceToMetadonnee(
         final List<MetadataReference> findMetadatasRecherchables) {
      final List<Metadonnee> listeMetadonnee = new ArrayList<>();
      for (final MetadataReference metadataReference : findMetadatasRecherchables) {
         final Metadonnee meta = new Metadonnee();
         meta.setShortCode(metadataReference.getShortCode());
         meta.setCode(metadataReference.getLongCode());
         if (metadataReference.getIsIndexed()) {
            meta.setIndexee("Oui");
         } else {
            meta.setIndexee("Non");
         }
         meta.setLibelle(metadataReference.getLabel());
         listeMetadonnee.add(meta);
      }
      return listeMetadonnee;
   }

}
