package fr.urssaf.image.sae.ihm.web.exploit.controller;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.validation.Valid;

import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import fr.urssaf.image.commons.cassandra.helper.CassandraCQLClientFactory;
import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucunDocumentException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.ErreurTechniqueException;
import fr.urssaf.image.sae.ihm.web.exploit.formulaire.ConsulterDocumentForm;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationEnvironnement;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationEnvironnementFrontal;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationsEnvironnement;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationsEnvironnementFrontal;
import fr.urssaf.image.sae.ihm.web.exploit.modele.Metadonnee;
import fr.urssaf.image.sae.ihm.web.exploit.modele.SaeDocument;
import fr.urssaf.image.sae.ihm.web.exploit.service.MetadonneesService;
import fr.urssaf.image.sae.ihm.web.exploit.service.RechercherService;
import fr.urssaf.image.sae.ihm.web.exploit.service.impl.MetadonneesServiceImpl;
import fr.urssaf.image.sae.ihm.web.exploit.utils.Constants;
import fr.urssaf.image.sae.ihm.web.exploit.utils.UtilsController;
import fr.urssaf.image.sae.metadata.referential.model.MetadataReference;
import fr.urssaf.image.sae.storage.dfce.model.StorageTechnicalMetadatas;
import me.prettyprint.hector.api.Keyspace;

/**
 * Classe centralisant les opérations utilisateurs pour la consultation d'un
 * document
 * 
 */

@Controller
public class ConsulterDocumentController {

  /**
   * Service offrant les opérations de recherche sur un ou plusieurs documents
   */
  @Autowired
  private RechercherService rechercherService;

  /**
   * Liste des environnements disponibles pour effectuer les opérations
   */
  @Autowired
  private ConfigurationsEnvironnement environnements;

  @Autowired
  private ConfigurationsEnvironnementFrontal frontaux;

  @Autowired
  private ConfigurationsEnvironnement config;

  /**
   * Initialisation du formulaire de consultation de document
   * 
   * @param model
   *           le modèle
   * @param session
   *           la session
   * @param request
   *           la requête
   * @return la page à afficher
   * @throws InterruptedException
   *            l'exception levée
   */
  @RequestMapping(value = "consulterDocument", method = RequestMethod.GET)
  public final String initialisation(final Model model, final HttpSession session,
                                     final HttpServletRequest request) throws InterruptedException {

    // Liste des noms des frontaux
    final String nomConfiguration = (String) session.getAttribute("nomConfiguration");

    // Permet d'identifier le frontal choisi
    ConfigurationEnvironnementFrontal frontalChoisie;

    // on recupère le nom du frontal correspondant à la config GED
    final String nomF = UtilsController.getListFrontalByEnvName(config, frontaux, nomConfiguration);

    // S'il n'y a pas de frontal associé, on charge le premier de la liste
    if (StringUtils.isBlank(nomF)) {
      frontalChoisie = frontaux.getConfigurationsFrontaux()[0];
    } else {
      frontalChoisie = frontaux.getConfigurationFrontal(nomF);
    }

    final List<String> listNomFrontaux = frontaux.getListeNoms();
    request.setAttribute("listNomFrontaux", listNomFrontaux);

    // On charge le frontal en session
    session.setAttribute("nomFrontal", frontalChoisie.getNom());

    request.setAttribute("frontal", frontalChoisie);

    final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext()
        .getAttribute(nomConfiguration + Constants.CQL);

    // Instancie le service des métadonnées dans la configuration courante
    final MetadonneesService metaService = new MetadonneesServiceImpl(session,
                                                                      config,
                                                                      ccf);

    // Préparation de la liste des métadonnées disponibles pour la
    // consultation
    final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
                                                                            .findMetadatasConsultables());
    request.setAttribute("listeMetaAffichage", listeMetaConsultable);

    final ConsulterDocumentForm form = new ConsulterDocumentForm();
    form.setFrontal(frontalChoisie.getNom());
    model.addAttribute("consultationForm", form);

    return "consulterDocument";

  }

  /**
   * Lance la consultation de document
   * 
   * @param consulterForm
   *           le formulaire de consultation
   * @param result
   *           gestion des erreurs
   * @param session
   *           la session
   * @param request
   *           la requête
   * @return la page à afficher
   */
  @RequestMapping(value = "lancerConsultDoc")
  public final String consulterDocument(
                                        @ModelAttribute("consultationForm") @Valid final ConsulterDocumentForm consulterForm,
                                        final BindingResult result, final HttpSession session, final HttpServletRequest request) {

    boolean changementFrontal;

    // Permet d'identifier le frontal choisi
    ConfigurationEnvironnementFrontal frontal;
    String nomFrontal = consulterForm.getFrontal();

    if(nomFrontal !=null &&
        !nomFrontal.equalsIgnoreCase((String) session.getAttribute("nomFrontal"))){
      changementFrontal = true;
    }else {
      changementFrontal = false;
    }

    if(StringUtils.isBlank(nomFrontal) && 
        StringUtils.isNotBlank((String) session.getAttribute("nomFrontal"))) {
      nomFrontal = (String) session.getAttribute("nomFrontal");
    }

    // Récupérer la configuration frontal
    // S'il n'y a pas de frontal en session, on charge le premier de la liste
    if (StringUtils.isBlank(nomFrontal) ) {
      frontal = frontaux.getConfigurationsFrontaux()[0];
    } else {
      frontal = frontaux.getConfigurationFrontal(nomFrontal);
    }

    // Chargement de la liste des frontaux
    final String nomConfiguration = (String) session.getAttribute("nomConfiguration");
    //List<String> listNomFrontaux = UtilsController.getListFrontalByEnvName(config, frontaux, nomConfiguration);
    final List<String> listNomFrontaux = frontaux.getListeNoms();
    request.setAttribute("listNomFrontaux", listNomFrontaux);

    // si changement du frontal
    session.setAttribute("nomFrontal", nomFrontal);
    request.setAttribute("frontal",
                         frontaux.getConfigurationFrontal(nomFrontal));


    if (!result.hasFieldErrors() || !changementFrontal) {
      try {
        SaeDocument saeDoc;
        // Récupération de l'uuid
        final UUID uuid = consulterForm.getIdentifiant();
        // Récupération des métadonnées à afficher en retour
        final List<String> codesMeta = consulterForm.getCodeMeta();

        // Récupération de l'url du webservice
        final ConfigurationEnvironnement conf = environnements
            .getConfiguration(nomConfiguration);
        final String urlServiceWebGED = conf.getUrlWs().toString();

        // Récupérer l'url du frontal
        final String urlServiceWebFrontal = frontal.getUrlWsFrontal().toString();

        // Récupération du login de l'utilisateur (pour la traçabilité)
        final String login = (String) session.getAttribute("login");


        // On ne lance pas la recherche suite au changement du
        // frontal ou en cas d'erreur de validation
        if(!changementFrontal && !result.hasFieldErrors()) {
          // Lancement de la consultation (on ne stocke pas le contenu du
          // document)
          if(consulterForm.isModeRechercheURLGED()) {
            saeDoc = rechercherService.consulterDocument(uuid, codesMeta,
                                                         urlServiceWebGED, false, login);
          }else {
            saeDoc = rechercherService.consulterDocument(uuid, codesMeta,
                                                         urlServiceWebFrontal, false, login);
          }

          request.setAttribute("resRecherche", saeDoc);
          request.setAttribute("id", uuid.toString());
        }

      } catch (final ErreurTechniqueException e) {
        if (e.getMessage().contains("Il n'existe aucun document pour l'identifiant d'archivage")) {
          final ObjectError erreur = new ObjectError("consultationForm",
              "Aucun document ne correspond à cet identifiant");
          result.addError(erreur);
        } else {

          final ObjectError erreur = new ObjectError("consultationForm", e
                                                     .getMessage());
          result.addError(erreur);

          final StringWriter sw = new StringWriter();
          final PrintWriter pw = new PrintWriter(sw);
          e.printStackTrace(pw);
          final String stacktrace = sw.toString();
          request.setAttribute("stacktrace", stacktrace);
        }

      } catch (final AucunDocumentException e) {

        final ObjectError erreur = new ObjectError("consultationForm",
            "Aucun document ne correspond à cet identifiant");
        result.addError(erreur);
      }

    }

    if(changementFrontal){
      request.setAttribute("validationForm", null);
    } else {
      request.setAttribute("validationForm", true);
    }

    // Récupération de la configuration choisie
    /*
     * final String nomConf = (String) session.getAttribute("nomConfiguration");
     * final Keyspace keyspace = (Keyspace) session.getServletContext()
     * .getAttribute(
     * nomConf);
     */

    final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext()
        .getAttribute(nomConfiguration + Constants.CQL);

    // Instancie le service des métadonnées dans la configuration courante
    final MetadonneesService metaService = new MetadonneesServiceImpl(session,
                                                                      config,
                                                                      ccf);

    // Préparation de la liste des métadonnées disponibles pour la
    // consultation
    final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
                                                                            .findMetadatasConsultables());
    request.setAttribute("listeMetaAffichage", listeMetaConsultable);

    return "consulterDocument";
  }


  /**
   * Initialisation de la consultation de document dans la corbeille
   * @param model
   * @param session
   * @param request
   * @return
   * @throws InterruptedException
   */
  @RequestMapping(value = "consulterDocumentEnCorbeille", method = RequestMethod.GET)
  public final String initConsultDocInRecycleBin(final Model model, final HttpSession session,
                                                 final HttpServletRequest request) throws InterruptedException {
    // Récupération de la configuration choisie
    final String nomConf = (String) session.getAttribute("nomConfiguration");
    final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext()
        .getAttribute(nomConf + Constants.CQL);
    // Instancie le service des métadonnées dans la configuration courante
    final MetadonneesService metaService = new MetadonneesServiceImpl(session,
                                                                      config,
                                                                      ccf);

    // Préparation de la liste des métadonnées disponibles pour la
    // consultation
    final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
                                                                            .findMetadatasConsultables());

    // Enlever le GEL de la liste des métadonnées consultables dans la corbeille
    int indexGel = -1;
    for (final Metadonnee metadonnee : listeMetaConsultable) {
      if(metadonnee.getShortCode().equals(StorageTechnicalMetadatas.GEL.getShortCode())){
        indexGel = listeMetaConsultable.indexOf(metadonnee);
      }
    }
    if(indexGel > 0 ){
      listeMetaConsultable.remove(indexGel);
    }

    request.setAttribute("listeMetaAffichage", listeMetaConsultable);
    final ConsulterDocumentForm form = new ConsulterDocumentForm();

    model.addAttribute("consultationForm", form);

    return "consulterDocumentEnCorbeille";

  }

  /**
   * Conversion d'une liste de MetadataReference en une liste de Metadonnee
   * @param findMetadatasRecherchables
   * @return une liste de Metadonnee
   */
  private List<Metadonnee> metaReferenceToMetadonnee(
                                                     final List<MetadataReference> findMetadatasRecherchables) {
    final List<Metadonnee> listeMetadonnee = new ArrayList<>();
    for (final MetadataReference metadataReference : findMetadatasRecherchables) {
      final Metadonnee meta = new Metadonnee();
      meta.setShortCode(metadataReference.getShortCode());
      meta.setCode(metadataReference.getLongCode());
      if (metadataReference.getIsIndexed()) {
        meta.setIndexee("Oui");
      } else {
        meta.setIndexee("Non");
      }
      meta.setLibelle(metadataReference.getLabel());
      listeMetadonnee.add(meta);
    }
    return listeMetadonnee;
  }


  /**
   * Permet le téléchargement du document
   * 
   * @param session
   *           la session
   * @param response
   *           la réponse
   * @param idConsult
   *           l'identifiant du document à télécharger
   * @throws AucunDocumentException
   *            Exception levée si aucun document retourné
   * @throws ErreurTechniqueException
   *            Excpetion levée si erreur technique
   * @throws IOException
   *            Exception levée lors de l'affichage du fichier
   */
  @RequestMapping(value = "telecharger")
  public final void telecharger(final HttpSession session,
                                final HttpServletResponse response, final String idConsult)
                                    throws IOException {


    // Récupération du Frontal de la session
    final String frontal = (String) session.getAttribute("nomFrontal");

    // Permet d'identifier le frontal choisi
    ConfigurationEnvironnementFrontal frontalChoisie;

    // S'il n'y a pas de frontal en session, on charge le premier de la liste
    if (StringUtils.isBlank(frontal)) {
      frontalChoisie = frontaux.getConfigurationsFrontaux()[0];
    } else {
      frontalChoisie = frontaux.getConfigurationFrontal(frontal);
    }
    // Récupération de l'url du webservice
    final String urlServiceWeb = frontalChoisie.getUrlWsFrontal().toString();

    SaeDocument saeDoc;

    // Récupération de l'uuid
    final UUID uuid = UUID.fromString(idConsult);
    // Récupération des métadonnées à afficher en retour
    final List<String> codesMeta = null;

    // Récupération du login de l'utilisateur (pour la traçabilité)
    final String login = (String) session.getAttribute("login");

    ServletOutputStream outputStream = null;
    // Lancement de la consultation (on stocke le contenu du document)
    try {
      saeDoc = rechercherService.consulterDocument(uuid, codesMeta,
                                                   urlServiceWeb, true, login);


      // Récupération du nom du fichier
      final List<Metadonnee> listeMeta = saeDoc.getMetadonnees();
      String nomFichier = idConsult.concat(".pdf");
      for (final Metadonnee metadonnee : listeMeta) {
        if ("NomFichier".equals(metadonnee.getCode())) {
          nomFichier = metadonnee.getValeur();
          break;
        }
      }

      // Affichage du fichier
      response.setContentType("application/pdf");
      response.setHeader("Content-Disposition", "attachment; filename=\""
          + nomFichier + "\"");

      outputStream = response.getOutputStream();
      outputStream.write(saeDoc.getContenu());
      outputStream.flush();
      outputStream.close();


    } catch (final ErreurTechniqueException e) {
      e.printStackTrace();
    } catch (final AucunDocumentException e) {
      e.printStackTrace();
    }

  }

  /**
   * Permet le téléchargement du document
   * 
   * @param session
   *           la session
   * @param response
   *           la réponse
   * @param idConsult
   *           l'identifiant du document à télécharger
   * @throws AucunDocumentException
   *            Exception levée si aucun document retourné
   * @throws ErreurTechniqueException
   *            Excpetion levée si erreur technique
   * @throws IOException
   *            Exception levée lors de l'affichage du fichier
   */
  @RequestMapping(value = "telechargerInRecycleBin")
  public final void telechargerInRecycleBin(final HttpSession session,
                                            final HttpServletResponse response, final String idConsult)
                                                throws AucunDocumentException, ErreurTechniqueException, IOException {

    SaeDocument saeDoc;

    // Récupération de l'uuid
    final UUID uuid = UUID.fromString(idConsult);
    // Récupération des métadonnées à afficher en retour
    final List<String> codesMeta = null;

    // Récupération du nom de la configuration selectionnée
    final String nomConf = (String) session.getAttribute("nomConfiguration");
    final Keyspace keyspace = (Keyspace) session.getServletContext().getAttribute(
                                                                                  nomConf);
    // Récupération de la connection à DFCe
    final DFCEConnection dfceConnection = (DFCEConnection) session
        .getServletContext().getAttribute(nomConf + "-dfce");
    // Lancement de la consultation (on stocke le contenu du document)
    final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext().getAttribute(nomConf + Constants.CQL);
    saeDoc = rechercherService.consultDocInRecycleBin(uuid, codesMeta, true,
                                                      dfceConnection,
                                                      keyspace,
                                                      ccf);

    // Récupération du nom du fichier
    final List<Metadonnee> listeMeta = saeDoc.getMetadonnees();
    String nomFichier = idConsult.concat(".pdf");
    for (final Metadonnee metadonnee : listeMeta) {
      if ("NomFichier".equals(metadonnee.getCode())) {
        nomFichier = metadonnee.getValeur();
        break;
      }
    }

    // Affichage du fichier
    response.setContentType("application/pdf");
    response.setHeader("Content-Disposition", "attachment; filename=\""
        + nomFichier + "\"");

    final ServletOutputStream outputStream = response.getOutputStream();
    outputStream.write(saeDoc.getContenu());

    outputStream.flush();
    outputStream.close();

  }

  /**
   * Action de consultation de document dans la corbeille
   * @param consulterForm
   * @param result
   * @param session
   * @param request
   * @return
   */
  @RequestMapping(value = "lancerConsultDocEnCorbeille")
  public final String consultDocInRecycleBin(
                                             @ModelAttribute("consultationForm") @Valid final ConsulterDocumentForm consulterForm,
                                             final BindingResult result, final HttpSession session, final HttpServletRequest request) {

    if (!result.hasFieldErrors()) {
      try {
        SaeDocument saeDoc;
        // Récupération de l'uuid
        final UUID uuid = consulterForm.getIdentifiant();
        // Récupération des métadonnées à afficher en retour
        final List<String> shortCodesMeta = consulterForm.getShortCodeMeta();
        // Récupération de la configuration choisie
        final String nomConf = (String) session.getAttribute("nomConfiguration");
        final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext()
                                                                                 .getAttribute(nomConf + Constants.CQL);

        // Instancie le service des métadonnées dans la configuration courante
        final MetadonneesService metaService = new MetadonneesServiceImpl(session,
                                                                          config,
                                                                          ccf);
        // Préparation de la liste des métadonnées disponibles pour la
        // consultation
        final List<Metadonnee> listeMetaConsultable = metaReferenceToMetadonnee(metaService
                                                                                .findMetadatasConsultables());

        // Enlever le GEL de la liste des métadonnées consultables dans la corbeille
        int indexGel = -1;
        for (final Metadonnee metadonnee : listeMetaConsultable) {
          if(metadonnee.getShortCode().equals(StorageTechnicalMetadatas.GEL.getShortCode())){
            indexGel = listeMetaConsultable.indexOf(metadonnee);
          }
        }
        if(indexGel > 0 ){
          listeMetaConsultable.remove(indexGel);
        }

        request.setAttribute("listeMetaAffichage", listeMetaConsultable);

        final Keyspace keyspace = (Keyspace) session.getServletContext()
            .getAttribute(nomConf);
        // Récupération de la connection à DFCe
        final DFCEConnection dfceConnection = (DFCEConnection) session
            .getServletContext().getAttribute(nomConf + "-dfce");

        saeDoc = rechercherService.consultDocInRecycleBin(uuid,
                                                          shortCodesMeta,
                                                          false,
                                                          dfceConnection,
                                                          keyspace,
                                                          ccf);

        final List<Metadonnee> metadataSaeDoc = getMetadonneeSaeDocByShortCodes(saeDoc.getMetadonnees(), listeMetaConsultable);

        saeDoc.setMetadonnees(metadataSaeDoc);

        request.setAttribute("resRecherche", saeDoc);
        request.setAttribute("id", uuid.toString());

      } catch (final ErreurTechniqueException e) {
        final ObjectError erreur = new ObjectError("consultationForm", e
                                                   .getMessage());
        result.addError(erreur);

        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
        e.printStackTrace(pw);
        final String stacktrace = sw.toString();
        request.setAttribute("stacktrace", stacktrace);

      } catch (final AucunDocumentException e) {
        final ObjectError erreur = new ObjectError("consultationForm",
            "Aucun document dans la corbeille ne correspond à cet identifiant");
        result.addError(erreur);
      }
    }
    return "consulterDocumentEnCorbeille";
  }

  /**
   * Mapping du shortCode par le code dans les métadonnées retournées
   * @param metadonnees
   * @param listeMetaRecherchable
   * @return
   */
  private List<Metadonnee> getMetadonneeSaeDocByShortCodes(
                                                           final List<Metadonnee> metadonnees, final List<Metadonnee> listeMetaRecherchable) {
    for (final Metadonnee metadonnee : metadonnees) {
      for (final Metadonnee metadonneeRecherchable : listeMetaRecherchable) {
        if( metadonnee.getCode().equals(metadonneeRecherchable.getShortCode())){
          metadonnee.setCode(metadonneeRecherchable.getCode());
        }
      }
    }
    return metadonnees;
  }

}
