package fr.urssaf.image.sae.ihm.web.exploit.controller;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import javax.validation.Valid;

import org.apache.commons.lang.time.DateUtils;
import org.apache.curator.framework.CuratorFramework;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import fr.urssaf.image.commons.cassandra.helper.CassandraCQLClientFactory;
import fr.urssaf.image.commons.dfce.model.DFCEConnection;
import fr.urssaf.image.sae.ihm.web.exploit.exception.AucuneTraceException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.ErreurTechniqueException;
import fr.urssaf.image.sae.ihm.web.exploit.exception.TraceException;
import fr.urssaf.image.sae.ihm.web.exploit.formulaire.ConsulterTracesForm;
import fr.urssaf.image.sae.ihm.web.exploit.modele.ConfigurationsEnvironnement;
import fr.urssaf.image.sae.ihm.web.exploit.modele.DfceTrace;
import fr.urssaf.image.sae.ihm.web.exploit.modele.SaeTrace;
import fr.urssaf.image.sae.ihm.web.exploit.service.ContratServiceService;
import fr.urssaf.image.sae.ihm.web.exploit.service.TraceService;
import fr.urssaf.image.sae.ihm.web.exploit.service.impl.ContratServiceServiceImpl;
import fr.urssaf.image.sae.ihm.web.exploit.utils.Constants;
import fr.urssaf.image.sae.trace.model.TraceType;
import me.prettyprint.hector.api.Keyspace;

/**
 * Classe permettant de gérer les traces
 * 
 * 
 */
@Controller
public class TraceController {

   /**
    * Interface permettant de réaliser les opérations sur les traces
    */
   @Autowired
   private TraceService traceService;

   @Autowired
   private ConfigurationsEnvironnement config;

   private static final String NOM_FORMULAIRE = "traceForm";
   private static final int MINUIT = 24;
   private static final int HEURE_MAX = 23;
   private static final int MINUTE_MAX = 59;

   private static final String DOC_UUID = "docUuid";
   private static final String DATE_EVT = "dateEvt";
   private static final String TYPE_EVT = "typeEvt";
   private static final String LOGIN = "login";
   private static final String ATTRIBUTS = "attributs";
   private static final String ACTION = "action";
   private static final String CODE_EVT = "codeEvt";
   private static final String CONTRAT = "contrat";
   private static final String TIMESTAMP = "timestamp";
   private static final String PAGMS = "pagms";
   private static final String CONTEXTE = "contexte";
   private static final String STACKTRACE = "stacktrace";
   private static final String INFOS = "infos";

   private static final String REG_TECHNIQUE = "REG_TECHNIQUE";
   private static final String JOURN_EVT = "JOURN_EVT";

   private static final int MAX_CODE_CLIENT = 200;

   // Nombre de ligne à afficher dans le tableau de résultats
   private static final int NB_LIGNE_TABLEAU = 100;

   /**
    * Initialisation de l'écran de recherche des traces
    * 
    * @param model
    *           le modèle
    * @param session
    *           la session
    * @param request
    *           la requête
    * @return la page à afficher
    * @throws InterruptedException
    *            Exception
    */
   @RequestMapping(value = "consulterTraces", method = RequestMethod.GET)
  public final String initialisation(final Model model, final HttpSession session,
                                     final HttpServletRequest request) throws InterruptedException {

    final ConsulterTracesForm form = new ConsulterTracesForm();
      // Recherche par dates par défaut
      form.setModeRecherche("parDates");
      // Ordre inversé par défaut
      form.setOrdreInverse(true);

    final Date dateDebut = new Date();
    final Date dateFin = new Date();
      form.setDateDebut(dateDebut);
      form.setDateFin(dateFin);

      form.setHeureDebut("00");
      form.setMinuteDebut("00");
      form.setHeureFin("24");
      form.setMinuteFin("00");

      // Nombre de ligne max du tableau de résultat
      if (form.getNbLignesTableau() == 0) {
         form.setNbLignesTableau(NB_LIGNE_TABLEAU);
         request.setAttribute("nbLignesTableau", NB_LIGNE_TABLEAU);
      } else {
         request.setAttribute("nbLignesTableau", form.getNbLignesTableau());
      }

      // Récupération de la configuration choisie
    final String nomConf = (String) session.getAttribute("nomConfiguration");
    final Keyspace keyspace = (Keyspace) session.getServletContext().getAttribute(
            nomConf);
      
    final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext()
                                                                             .getAttribute(nomConf + Constants.CQL);
      
    final CuratorFramework curator = (CuratorFramework) session.getServletContext()
            .getAttribute(nomConf + "-zookeeper");
    final ContratServiceService csService = new ContratServiceServiceImpl(keyspace,
                                                                          config.getConfiguration(nomConf),
                                                                          curator,
                                                                          ccf);

    final List<String> codeEvtRegTechnique = traceService
            .getListeCodeEvenementByTypeTrace(REG_TECHNIQUE, keyspace, ccf);
      Collections.sort(codeEvtRegTechnique);
      session.setAttribute("codeEvtRegTechnique", codeEvtRegTechnique);

    final List<String> codeEvtJournalEvt = traceService
            .getListeCodeEvenementByTypeTrace(JOURN_EVT, keyspace, ccf);
      Collections.sort(codeEvtJournalEvt);
      session.setAttribute("codeEvtJournalEvt", codeEvtJournalEvt);

    final List<String> contratService = csService
            .findAllCodeClientCs(MAX_CODE_CLIENT);
      session.setAttribute("contratService", contratService);

      // ajoute des types d'historique dfce
    final DFCEConnection dfceConnection = (DFCEConnection) session
              .getServletContext().getAttribute(nomConf + "-dfce");
            
      session.setAttribute("listeHisEvtDfce", Constants.listeHisEvtDfce);
      model.addAttribute(NOM_FORMULAIRE, form);

      return "consulterTraces";

   }

   /**
    * Lancement de la recherche des traces
    * 
    * @param traceForm
    *           Le formulaire
    * @param result
    *           Gestion des erreurs
    * @param session
    *           La session
    * @param request
    *           La requête
    * @return La page à afficher
    */
   @RequestMapping(value = "lancerConsultTrace")
   public final String rechercherTraces(
                                       @ModelAttribute(NOM_FORMULAIRE) @Valid final ConsulterTracesForm traceForm,
                                       final BindingResult result, final HttpSession session, final HttpServletRequest request) {

      if (!result.hasFieldErrors()) {

         try {
            // Récupération de l'uuid du document
        final UUID uuid = traceForm.getIdDoc();
            // Récupération de la date de début
        final Date dateDebutTmp = traceForm.getDateDebut();
            // Récupération de la date de fin
        final Date dateFinTmp = traceForm.getDateFin();
            // Récupération heure de début
        final String heureDebut = traceForm.getHeureDebut();
        final String minuteDebut = traceForm.getMinuteDebut();
            // Récupération heure de fin
        final String heureFin = traceForm.getHeureFin();
        final String minuteFin = traceForm.getMinuteFin();

            // Récupération du nombre de résultats à retourner
        final int taille = traceForm.getTaille();
            // Récupération de l'ordre des traces
        final boolean ordreInverse = traceForm.isOrdreInverse();
            // Récupération du type de trace
        final TraceType traceType = traceForm.getListeTypeTrace();
            // Récupération du code évenement
        final List<String> codeEvenement = traceForm.getCodeEvenement();
          
            // Récupération du contrat de service
        final String contratService = traceForm.getContratService();

        final String histEvtDfce = traceForm.getHistEvtDfce();
            
            // Récupération du mode de recherche
        final String modeRecherche = traceForm.getModeRecherche();
            // Ajout des heures dans les dates de début et de fin
        final Date dateDebut = calculeDate(dateDebutTmp, heureDebut, minuteDebut);
        final Date dateFin = calculeDate(dateFinTmp, heureFin, minuteFin);

            // Nombre de ligne max du tableau de résultat
            if (traceForm.getNbLignesTableau() == 0) {
               traceForm.setNbLignesTableau(NB_LIGNE_TABLEAU);
               request.setAttribute("nbLignesTableau", NB_LIGNE_TABLEAU);
            } else {
               request.setAttribute("nbLignesTableau", traceForm
                     .getNbLignesTableau());
            }

            // Récupération de la configuration choisie
        final String nomConf = (String) session.getAttribute("nomConfiguration");
        final DFCEConnection dfceConnection = (DFCEConnection) session
                  .getServletContext().getAttribute(nomConf + "-dfce");
        final Keyspace keyspace = (Keyspace) session.getServletContext()
                  .getAttribute(nomConf);
            
        final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext()
            .getAttribute(nomConf + Constants.CQL);
            
            // Colonnes à afficher suivant les types de traces
        List<String> colonnesAffichees = new ArrayList<>();
            colonnesAffichees = getColonnesAAfficherTraces(traceType);
            traceForm.setColonnesAffichees(colonnesAffichees);

        List<DfceTrace> listeTracesDfce = new ArrayList<>();
        List<SaeTrace> listeTracesSae = new ArrayList<>();

            // Recherche par identifiant
            if ("parIdentifiant".equals(modeRecherche)) {
               // Trace du cycle de vie
               if (traceType.equals(TraceType.CYCLE_VIE)) {
                  listeTracesDfce = traceService.lectureTracesDfceParDocUuid(
                        traceType, uuid, dfceConnection);

                  request.setAttribute("modeAffichage", "DFCE");
                  request.setAttribute("listeTraces", listeTracesDfce);

               } else {
            final ObjectError erreur = new ObjectError(NOM_FORMULAIRE,
                        "Le type de trace est incorrect");
                  result.addError(erreur);
               }
               // Recherche par dates
            } else if ("parDates".equals(modeRecherche)) {
               if (traceType.equals(TraceType.HIST_EVT)){
            	   
            	   listeTracesDfce = traceService.lectureTracesDfceParDates(
                           traceType, dateDebut, dateFin, taille, ordreInverse,
                           dfceConnection);
            	   
            	   // filtrage
            	   request.setAttribute("modeAffichage", "DFCE");
            final List<DfceTrace> listeTracesSaeFiltree = new ArrayList<>();
            	   if (histEvtDfce != null && !"TOUS".equals(histEvtDfce)) {
                     
              for (final DfceTrace saeTrace : listeTracesDfce) {
            			 if(saeTrace.getTypeEvt().equals(histEvtDfce)) {
            				 listeTracesSaeFiltree.add(saeTrace);
            			 }
            		 }
                     request.setAttribute("listeTraces", listeTracesSaeFiltree);
            	   } else {
                     request.setAttribute("listeTraces", listeTracesDfce);
            	   }
                     
               } if(traceType.equals(TraceType.CYCLE_VIE)) {
                  listeTracesDfce = traceService.lectureTracesDfceParDates(
                        traceType, dateDebut, dateFin, taille, ordreInverse,
                        dfceConnection);
                  request.setAttribute("modeAffichage", "DFCE");
                  request.setAttribute("listeTraces", listeTracesDfce);
               } else if (traceType.equals(TraceType.EXPLOITATION)
                     || traceType.equals(TraceType.SECURITE)
                     || traceType.equals(TraceType.TECHNIQUE)
                     || traceType.equals(TraceType.JOURNAL_EVT)) {
                  listeTracesSae = traceService.lectureTracesSaeParDates(
                        traceType, dateDebut, dateFin, taille, ordreInverse,
                        keyspace, ccf);
                  request.setAttribute("modeAffichage", "SAE");

                  // Besoin de filtrer ?
            if (codeEvenement != null && !codeEvenement.contains("TOUS")
                || contratService != null && !"TOUS"
                .equals(contratService)) {
              final List<SaeTrace> listeTracesSaeFiltree = new ArrayList<>();
              for (final SaeTrace saeTrace : listeTracesSae) {
                        boolean traceAGarder = true;
                        if (codeEvenement != null
                              && !codeEvenement.contains("TOUS")) {
                           if (!codeEvenement.contains(saeTrace.getCodeEvt())) {
                              traceAGarder = false;
                           }
                        }
                        if (contratService != null
                              && !"TOUS".equals(contratService)) {
                           if (saeTrace.getContrat()!= null) {
                              if (!saeTrace.getContrat().equals(contratService)) {
                                 traceAGarder = false;
                              }
                           } else {
                              traceAGarder = false;
                           }
                        }
                        if (traceAGarder) {
                           listeTracesSaeFiltree.add(saeTrace);
                        }
                     }
                     request.setAttribute("listeTraces", listeTracesSaeFiltree);
                  } else {
                     request.setAttribute("listeTraces", listeTracesSae);
                  }

               }
            }
         } catch (final AucuneTraceException e) {
        	final ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
        	result.addError(erreur);
            // StringWriter sw = new StringWriter();
            // PrintWriter pw = new PrintWriter(sw);
            // e.printStackTrace(pw);
            // String stacktrace = sw.toString();
            // request.setAttribute("stacktrace", stacktrace);
         } catch (final TraceException e) {
        final ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
        result.addError(erreur);
        // StringWriter sw = new StringWriter();
        // PrintWriter pw = new PrintWriter(sw);
        // e.printStackTrace(pw);
        // String stacktrace = sw.toString();
        // request.setAttribute("stacktrace", stacktrace);
      } catch (final ErreurTechniqueException e) {
        final ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
            result.addError(erreur);
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
        final String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);

      } catch (final IllegalArgumentException e) {
        final ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
        result.addError(erreur);
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
        e.printStackTrace(pw);
        final String stacktrace = sw.toString();
        request.setAttribute("stacktrace", stacktrace);
         }

      }

      return "consulterTraces";
   }

   /**
    * Récupération du détail de la trace
    * 
    * @param traceForm
    *           Le formulaire
    * @param result
    *           Gestion des erreurs
    * @param session
    *           La session
    * @param request
    *           La requête
    * @return La page à afficher
    */
   @RequestMapping(value = "detailTrace")
   public final String afficherDetailTrace(
                                          @ModelAttribute(NOM_FORMULAIRE) @Valid final ConsulterTracesForm traceForm,
                                          final BindingResult result, final HttpSession session, final HttpServletRequest request) {

      if (!result.hasFieldErrors()) {

         try {

            // Récupération de l'uuid de la trace dont on veut le détail
        final UUID idTrace = traceForm.getIdTrace();

            // Récupération du type de trace
        final TraceType traceType = traceForm.getListeTypeTrace();

            // Colonnes à afficher suivant les types de traces
        List<String> colonnesAffichees = new ArrayList<>();
            colonnesAffichees = getColonnesAAfficherDetailTraces(traceType);
            traceForm.setColonnesAffichees(colonnesAffichees);

            // Récupération de la configuration choisie
        final String nomConf = (String) session.getAttribute("nomConfiguration");
        final Keyspace keyspace = (Keyspace) session.getServletContext()
                  .getAttribute(nomConf);
            
        final CassandraCQLClientFactory ccf = (CassandraCQLClientFactory) session.getServletContext()
            .getAttribute(nomConf + Constants.CQL);

        final SaeTrace saeTrace = traceService.lectureTraceSaeParUuid(traceType,
                  idTrace, keyspace, ccf);

            request.setAttribute("detailTrace", saeTrace);

         }catch (final AucuneTraceException e) {
        final ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
        result.addError(erreur);
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
        e.printStackTrace(pw);
        final String stacktrace = sw.toString();
        request.setAttribute("stacktrace", stacktrace);
      } catch (final TraceException e) {
        final ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
        result.addError(erreur);
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
        e.printStackTrace(pw);
        final String stacktrace = sw.toString();
        request.setAttribute("stacktrace", stacktrace);
      } catch (final ErreurTechniqueException e) {
        final ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
        result.addError(erreur);
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
        e.printStackTrace(pw);
        final String stacktrace = sw.toString();
        request.setAttribute("stacktrace", stacktrace);
      } catch (final IllegalArgumentException e) {
        final ObjectError erreur = new ObjectError(NOM_FORMULAIRE, e.getMessage());
            result.addError(erreur);
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
        final String stacktrace = sw.toString();
            request.setAttribute("stacktrace", stacktrace);
         }

      }

      return "consulterTraces";

   }

   @SuppressWarnings("PMD.ShortVariable")
  private Date calculeDate(final Date dateDebut, final String heure, final String minute) {

      Date dateOk = dateDebut;

      int hh = Integer.parseInt(heure);
      int mm = Integer.parseInt(minute);

      if (hh == MINUIT) {
         hh = HEURE_MAX;
         mm = MINUTE_MAX;
      }
      dateOk = DateUtils.setHours(dateOk, hh);
      dateOk = DateUtils.setMinutes(dateOk, mm);
      dateOk = DateUtils.setSeconds(dateOk, 0);
      dateOk = DateUtils.setMilliseconds(dateOk, 0);

      return dateOk;

   }

   /**
    * Récupération des colonnes à afficher suivant le type de la trace
    * 
    * @param traceType
    * @return Les colonnes à afficher
    */
  private List<String> getColonnesAAfficherTraces(final TraceType traceType) {

    final List<String> colonnesAffichees = new ArrayList<>();

      if (traceType.equals(TraceType.CYCLE_VIE)) {
         colonnesAffichees.add(DOC_UUID);
         colonnesAffichees.add(DATE_EVT);
         colonnesAffichees.add(TYPE_EVT);
         colonnesAffichees.add(LOGIN);
         // if (modeRecherche.equals("parDates")) {
         colonnesAffichees.add(ATTRIBUTS);
         // }
      } else if (traceType.equals(TraceType.HIST_EVT)) {
         colonnesAffichees.add(DATE_EVT);
         colonnesAffichees.add(TYPE_EVT);
         colonnesAffichees.add(LOGIN);
         colonnesAffichees.add(ATTRIBUTS);
      } else if (traceType.equals(TraceType.EXPLOITATION)) {
         colonnesAffichees.add(ACTION);
         colonnesAffichees.add(CODE_EVT);
         colonnesAffichees.add(CONTRAT);
         colonnesAffichees.add(LOGIN);
         colonnesAffichees.add(TIMESTAMP);
         colonnesAffichees.add(PAGMS);
      } else if (traceType.equals(TraceType.TECHNIQUE)) {
         colonnesAffichees.add(CODE_EVT);
         colonnesAffichees.add(CONTRAT);
         colonnesAffichees.add(LOGIN);
         colonnesAffichees.add(TIMESTAMP);
         colonnesAffichees.add(PAGMS);
      } else if (traceType.equals(TraceType.SECURITE)) {
         colonnesAffichees.add(CODE_EVT);
         colonnesAffichees.add(CONTEXTE);
         colonnesAffichees.add(CONTRAT);
         colonnesAffichees.add(LOGIN);
         colonnesAffichees.add(TIMESTAMP);
         colonnesAffichees.add(PAGMS);
      } else if (traceType.equals(TraceType.JOURNAL_EVT)) {
         colonnesAffichees.add(CODE_EVT);
         colonnesAffichees.add(CONTEXTE);
         colonnesAffichees.add(CONTRAT);
         colonnesAffichees.add(LOGIN);
         colonnesAffichees.add(TIMESTAMP);
         colonnesAffichees.add(PAGMS);
      }
      return colonnesAffichees;

   }

   /**
    * Récupération de la liste des colonnes à afficher dans le détail des traces
    * suivant le type de trace
    * 
    * @param traceType
    *           Le type de la trace
    * @return La liste des colonnes
    */
  private List<String> getColonnesAAfficherDetailTraces(final TraceType traceType) {

    final List<String> colonnesAffichees = new ArrayList<>();
      colonnesAffichees.add(CODE_EVT);
      colonnesAffichees.add(CONTRAT);
      colonnesAffichees.add(LOGIN);
      colonnesAffichees.add(TIMESTAMP);
      colonnesAffichees.add(PAGMS);
      if (traceType.equals(TraceType.EXPLOITATION)) {
         colonnesAffichees.add(ACTION);
      } else if (traceType.equals(TraceType.SECURITE)
            || traceType.equals(TraceType.JOURNAL_EVT)) {
         colonnesAffichees.add(CONTEXTE);
      } else if (traceType.equals(TraceType.TECHNIQUE)) {
         colonnesAffichees.add(CONTEXTE);
         colonnesAffichees.add(STACKTRACE);

      }
      colonnesAffichees.add(INFOS);
      return colonnesAffichees;
   }

}
