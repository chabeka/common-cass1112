package fr.urssaf.image.sae.admin.dfce.exploit.executable;

import java.io.File;
import java.io.FileNotFoundException;

import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.core.io.FileSystemResource;

import fr.urssaf.image.sae.admin.dfce.exploit.exception.ArchiveLogsRunningEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.BaseAdministrationPermissionEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.BaseAdministrationServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.ConnectionServiceEx;
import fr.urssaf.image.sae.admin.dfce.exploit.exception.EventsPurgeException;
import fr.urssaf.image.sae.admin.dfce.exploit.model.ConnectionParameter;
import fr.urssaf.image.sae.admin.dfce.exploit.services.AdministrationDFCEService;
import fr.urssaf.image.sae.admin.dfce.exploit.services.ArchiveLogDocumentDFCEService;
import fr.urssaf.image.sae.admin.dfce.exploit.services.ArchiveLogSystemDFCEService;
import fr.urssaf.image.sae.admin.dfce.exploit.utils.CommandeSAELineHelper;
import fr.urssaf.image.sae.admin.dfce.exploit.utils.ValidateUtils;

/**
 * Classe qui fournit l'appele aux services:
 * <ul>
 * <li>Service de mise à jour des indexes.</li>
 * <li>Service de création de la base de données SAE.</li>
 * <li>Service de création du journal d'événement de type <b>Documents</b></li>
 * <li>Service de purge des journaux de type <b>Documents</b></li>
 * <li>Service de consultation du fichier d'archivage de type<b>Documents</b></li>
 * <li>Service de création du journal d'événement de type <b>System</b></li>
 * <li>Service de purge des journaux de type <b>System</b></li>
 * <li>Service de consultation du fichier d'archivage de type <b>System</b></li>
 * </ul>
 * 
 * @author rhofir.
 */
@SuppressWarnings( { "PMD.CyclomaticComplexity" })
public final class AdministrationSAEMain {

   private static final Logger LOGGER = LoggerFactory
         .getLogger(AdministrationSAEMain.class);

   public static final String REINDEX = "reindex";
   public static final String CREATE_DOC_EVENT = "createDocEvent";
   public static final String CLEAR_DOC_EVENT = "clearDocEvent";
   public static final String CONSULT_DOC_EVENT = "consultDocEvent";
   public static final String CREATE_SYS_EVENT = "creatSystemEvent";
   public static final String CLEAR_SYS_EVENT = "clearSystemEvent";
   public static final String CONSULT_SYS_EVENT = "consultSystemEvent";
   public static final String CREATE_DATA_BASE = "createDataBase";
   public static final String HELP = "help";
   public static final String UPDATE_LIFECYCLE = "updateLifecycleRules";

   private static final String[] AVAIBLE_SERVICES = new String[] { REINDEX,
         CREATE_DOC_EVENT, CLEAR_DOC_EVENT, CONSULT_DOC_EVENT,
         CREATE_SYS_EVENT, CLEAR_SYS_EVENT, CONSULT_SYS_EVENT,
         CREATE_DATA_BASE, UPDATE_LIFECYCLE };

   /**
    * Service de mise à jour des indexes.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void updateIndexes(final ConnectionParameter cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx {
      // Vérification des paramètres d'entrée

      // appel du service de mise à jour des indexes
      final AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);
      try {
         adminDFCE.updateIndexes(cnxParameter);
      } catch (ConnectionServiceEx except) {
         LOGGER.error(except.getMessage());
         throw new ConnectionServiceEx(except.getMessage());
      }
   }

   /**
    * Service de création du journal d'événements de type <b>Documents</b>.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws ArchiveLogsRunningEx
    *            s'il y a un problème survient lors de l'archivage.
    */
   private void createDocumentsEventLogs(
         final ConnectionParameter cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         ArchiveLogsRunningEx {
      // Vérification des paramètres d'entrée

      // appel du service de mise à jour des indexes
      final ArchiveLogDocumentDFCEService adminDFCE = context
            .getBean(ArchiveLogDocumentDFCEService.class);
      try {
         adminDFCE.createDocumentsEventLogs(cnxParameter);
      } catch (ConnectionServiceEx except) {
         LOGGER.error(except.getMessage());
         throw new ConnectionServiceEx(except.getMessage());
      } catch (ArchiveLogsRunningEx except) {
         LOGGER.error(except.getMessage());
         throw new ArchiveLogsRunningEx(except.getMessage());
      }
   }

   /**
    * Service de création du journal d'événements de type <b>Système</b>.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws ArchiveLogsRunningEx
    *            s'il y a un problème survient lors de l'archivage.
    */
   private void createSystemEventLogs(final ConnectionParameter cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         ArchiveLogsRunningEx {
      // Vérification des paramètres d'entrée

      // appel du service de mise à jour des indexes
      final ArchiveLogSystemDFCEService adminDFCE = context
            .getBean(ArchiveLogSystemDFCEService.class);
      try {
         adminDFCE.createSystemEventLogs(cnxParameter);
      } catch (ConnectionServiceEx except) {
         LOGGER.error(except.getMessage());
         throw new ConnectionServiceEx(except.getMessage());
      } catch (ArchiveLogsRunningEx except) {
         LOGGER.error(except.getMessage());
         throw new ArchiveLogsRunningEx(except.getMessage());
      }
   }

   /**
    * Service de création du journal d'événements de type <b>Documents</b>.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws EventsPurgeException
    *            s'il y a un problème survient lors de la purge.
    */
   private void purgeDocumentsEvents(final String[] args,
         final ConnectionParameter cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         EventsPurgeException {
      try {
         // Vérification des paramètres d'entrée
         if (!ValidateUtils.isNotBlank(args, 0)
               || !StringUtils.isNumeric(args[0])) {
            throw new IllegalArgumentException(
                  "La durée de conservation doit être renseigné.");
         }
         // appel du service de mise à jour des indexes
         final ArchiveLogDocumentDFCEService adminDFCE = context
               .getBean(ArchiveLogDocumentDFCEService.class);
         final String durationStr = args[0];

         final int archiveDuration = Integer.parseInt(durationStr);
         adminDFCE.purgeDocumentsEvents(cnxParameter, archiveDuration);
      } catch (ConnectionServiceEx except) {
         LOGGER.error(except.getMessage());
         throw new ConnectionServiceEx(except.getMessage());
      } catch (EventsPurgeException except) {
         LOGGER.error(except.getMessage());
         throw new EventsPurgeException(except.getMessage());
      }
   }

   /**
    * Service de création du journal d'événements de type <b>Documents</b>.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws EventsPurgeException
    *            s'il y a un problème survient lors de la purge.
    */
   private void purgeSystemEvents(final String[] args,
         final ConnectionParameter cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         EventsPurgeException {
      try {
         // Vérification des paramètres d'entrée
         if (!ValidateUtils.isNotBlank(args, 0)
               || !StringUtils.isNumeric(args[0])) {
            throw new IllegalArgumentException(
                  "La durée de conservation doit être renseigné.");
         }
         // appel du service de mise à jour des indexes
         final ArchiveLogSystemDFCEService adminDFCE = context
               .getBean(ArchiveLogSystemDFCEService.class);
         final String durationStr = args[0];

         final int archiveDuration = Integer.parseInt(durationStr);
         adminDFCE.purgeSystemEvents(cnxParameter, archiveDuration);
      } catch (ConnectionServiceEx except) {
         LOGGER.error(except.getMessage());
         throw new ConnectionServiceEx(except.getMessage());
      } catch (EventsPurgeException except) {
         LOGGER.error(except.getMessage());
         throw new EventsPurgeException(except.getMessage());
      }
   }

   /**
    * Service de création du journal d'événements de type <b>Documents</b>.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws ArchiveLogsRunningEx
    *            s'il y a un problème survient lors de l'archivage.
    * @throws BaseAdministrationPermissionEx
    *            s'il y a un problèmed'accès ou de droit.
    */
   private void extractDocumentsArchiveFile(final String[] args,
         final ConnectionParameter cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         ArchiveLogsRunningEx, BaseAdministrationPermissionEx {
      try {
         boolean dirPermission = true;
         // Vérification des paramètres d'entrée
         if (!ValidateUtils.isNotBlank(args, 0)) {
            throw new IllegalArgumentException(
                  "Le chemin de dépot des fichier de log doit être renseigné.");
         }
         // appel du service de mise à jour des indexes
         final ArchiveLogDocumentDFCEService adminDFCE = context
               .getBean(ArchiveLogDocumentDFCEService.class);
         final String filePath = args[0];
         final File parentDir = new File(filePath);
         try {
            final File tmpfile = File.createTempFile("extractDocuments",
                  ".tmp", parentDir);
            if (tmpfile.isFile() && tmpfile.exists()) {
               LOGGER.debug("Suppresion du fichier temporaire ", tmpfile
                     .delete());
            } else {
               dirPermission = false;
            }
         } catch (Exception e) {
            dirPermission = false;
         }
         if (!dirPermission) {
            LOGGER
                  .error(
                        "Le SAE ne dispose pas des droits d'\u00E9criture dans le r\u00E9pertoire ({})",
                        filePath);
            throw new BaseAdministrationPermissionEx(
                  "Le SAE ne dispose pas des droits d'\u00E9criture dans le r\u00E9pertoire "
                        + filePath);
         }
         adminDFCE.extractDocumentsArchiveFile(cnxParameter, filePath);
      } catch (ConnectionServiceEx except) {
         LOGGER.error(except.getMessage());
         throw new ConnectionServiceEx(except.getMessage());
      } catch (ArchiveLogsRunningEx except) {
         LOGGER.error(except.getMessage());
         throw new ArchiveLogsRunningEx(except.getMessage());
      }
   }

   /**
    * Service de création du journal d'événements de type <b>Documents</b>.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws ArchiveLogsRunningEx
    *            s'il y a un problème survient lors de l'archivage.
    * @throws BaseAdministrationPermissionEx
    *            s'il y a un problèmed'accès ou de droit
    */
   private void extractSystemArchiveFile(final String[] args,
         final ConnectionParameter cnxParameter,
         final ApplicationContext context) throws ConnectionServiceEx,
         ArchiveLogsRunningEx, BaseAdministrationPermissionEx {
      try {
         boolean dirPermission = true;
         // Vérification des paramètres d'entrée
         if (!ValidateUtils.isNotBlank(args, 0)) {
            throw new IllegalArgumentException(
                  "Le chemin de dépot des fichier de log doit être renseigné.");
         }
         // appel du service de mise à jour des indexes
         final ArchiveLogSystemDFCEService adminDFCE = context
               .getBean(ArchiveLogSystemDFCEService.class);
         final String filePath = args[0];
         final File parentDir = new File(filePath);
         try {
            final File tmpfile = File.createTempFile("extractDocuments",
                  ".tmp", parentDir);
            if (tmpfile.isFile() && tmpfile.exists()) {
               LOGGER.debug("Suppresion du fichier temporaire ", tmpfile
                     .delete());
            } else {
               dirPermission = false;
            }
         } catch (Exception e) {
            dirPermission = false;
         }
         if (!dirPermission) {
            LOGGER
                  .error(
                        "Le SAE ne dispose pas des droits d'\u00E9criture dans le r\u00E9pertoire ({})",
                        filePath);
            throw new BaseAdministrationPermissionEx(
                  "Le SAE ne dispose pas des droits d'\u00E9criture dans le r\u00E9pertoire "
                        + filePath);
         }
         adminDFCE.extractSystemArchiveFile(cnxParameter, filePath);
      } catch (ConnectionServiceEx except) {
         LOGGER.error(except.getMessage());
         throw new ConnectionServiceEx(except.getMessage());
      } catch (ArchiveLogsRunningEx except) {
         LOGGER.error(except.getMessage());
         throw new ArchiveLogsRunningEx(except.getMessage());
      }
   }

   /**
    * Service de création de la base de données SAE.
    * 
    * @param cnxParameter
    *           : Paramétrées de connexion.
    * @param context
    *           : Contexte Spring.
    * @throws BaseAdministrationServiceEx
    *            s'il y'a une problème lors de l'appel d'un service
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    */
   private void createSAEBase(final String[] args,
         final ConnectionParameter cnxParameter,
         final ApplicationContext context) throws BaseAdministrationServiceEx,
         ConnectionServiceEx {
      try {
         final AdministrationDFCEService adminDFCE = context
               .getBean(AdministrationDFCEService.class);
         // Vérification des paramètres d'entrée
         if (!ValidateUtils.isNotBlank(args, 0)) {
            throw new IllegalArgumentException(
                  "Le chemin complet du fichier du modéle de la base de données SAE doit être renseigné.");
         }
         if (!ValidateUtils.isNotBlank(args, 1)) {
            throw new IllegalArgumentException(
                  "Le chemin complet du fichier des types de documents SAE doit être renseigné.");
         }
         final String dataBasePath = args[0];
         final String documentsTypePath = args[1];
         final File xmlDataBaseModel = new File(dataBasePath);
         final File xmlDocumentsType = new File(documentsTypePath);
         if (!xmlDataBaseModel.isFile()) {
            throw new BaseAdministrationServiceEx(
                  "Le modéle de la base de données SAE n'est pas valide.");
         }
         if (!xmlDocumentsType.isFile()) {
            throw new BaseAdministrationServiceEx(
                  "Le fichier des types de documents SAE n'est pas valide.");
         }
         // appel du service de création de la base de données.
         adminDFCE.createSAEBase(cnxParameter, xmlDataBaseModel,
               xmlDocumentsType);
      } catch (FileNotFoundException except) {
         LOGGER.error(except.getMessage());
         throw new BaseAdministrationServiceEx(except.getMessage());
      } catch (BaseAdministrationServiceEx except) {
         LOGGER.error(except.getMessage());
         throw new BaseAdministrationServiceEx(except.getMessage());
      } catch (ConnectionServiceEx except) {
         LOGGER.error(except.getMessage());
         throw new ConnectionServiceEx(except.getMessage());
      }
   }

   /**
    * Service de mise à jour des données de la table LifeCycle
    * 
    * @param args
    * @param cnxParameter
    * @param context
    * @throws BaseAdministrationServiceEx
    */
   private void updateLiveCycleRules(String[] args,
         ConnectionParameter cnxParameter, ApplicationContext context)
         throws BaseAdministrationServiceEx {

      AdministrationDFCEService adminDFCE = context
            .getBean(AdministrationDFCEService.class);

      String lifeCyclePath = args[0];

      File xmlDocumentsType = new File(lifeCyclePath);

      if (!xmlDocumentsType.isFile()) {
         throw new BaseAdministrationServiceEx(
               "Le fichier des durées de conservation n'est pas valide.");
      }

      try {
         adminDFCE.updateLifeCycleRules(cnxParameter,
               xmlDocumentsType);
      } catch (FileNotFoundException except) {
         LOGGER.error(except.getMessage());
         throw new BaseAdministrationServiceEx(except.getMessage());
      } catch (ConnectionServiceEx except) {
         LOGGER.error(except.getMessage());
         throw new BaseAdministrationServiceEx(except.getMessage());
      }
   }

   /**
    * Apple les services :
    * 
    * <ul>
    * <li>Service de mise à jour des indexes.</li>
    * <li>Service de création de la base de données SAE.</li>
    * <li>Service de création du journal d'événement de type <b>Documents</b></li>
    * <li>Service de purge des journaux de type <b>Documents</b></li>
    * <li>Service de consultation du fichier d'archivage de type<b>Documents</b>
    * </li>
    * <li>Service de création du journal d'événement de type <b>System</b></li>
    * <li>Service de purge des journaux de type <b>System</b></li>
    * <li>Service de consultation du fichier d'archivage de type <b>System</b></li>
    * </ul>
    * 
    * @param args
    *           arguments de l'exécutable
    * @throws BaseAdministrationServiceEx
    *            s'il y'a une problème lors de l'appel d'un service
    * @throws ConnectionServiceEx
    *            s'il y a un problème survient lors de la connexion
    * @throws ArchiveLogsRunningEx
    *            s'il y a un problème survient lors de l'archivage.
    * @throws BaseAdministrationPermissionEx
    *            s'il y a un problèmed'accès ou de droit
    * @throws EventsPurgeException
    *            s'il y a un problème survient lors de la purge.
    */
   public static void main(final String[] args)
         throws BaseAdministrationServiceEx, ConnectionServiceEx,
         ArchiveLogsRunningEx, BaseAdministrationPermissionEx,
         EventsPurgeException {
      try {
         final AdministrationSAEMain adminSAE = new AdministrationSAEMain();
         ConnectionParameter cnxParameter = null;
         String[] newArgs = null;
         ApplicationContext context = null;
         if (ArrayUtils.isNotEmpty(args) && args.length >= 2) {
            newArgs = (String[]) ArrayUtils.subarray(args, 2, args.length);
            if (!ArrayUtils.contains(AVAIBLE_SERVICES, args[0])) {
               LOGGER.warn("Le service demande {} n'est pas valide", args[0]);
               LOGGER.info("Services disponible :\r{}\r{}\r{}\r{}\r{}\r{}\r{}",
                     AVAIBLE_SERVICES);
               throw new IllegalArgumentException("Le service demande "
                     + args[0] + " n'est pas valide.");
            }
            // instanciation du contexte de SPRING
            if (!ValidateUtils.isNotBlank(args, 1)) {
               throw new IllegalArgumentException(
                     "Le chemin complet du fichier de configuration générale du SAE doit être renseigné.");
            }
            final String saeConfiguration = args[1];
            context = createSAEApplicationContext(
                  "/applicationContext-sae-dfce-admin-exploit.xml",
                  saeConfiguration);

            cnxParameter = context.getBean(ConnectionParameter.class);
            if (cnxParameter == null || context == null) {
               throw new IllegalArgumentException(
                     "Le contexte de l'application et/ou le paramétre de connexion n'est pas valide.");

            }
         }

         if (ArrayUtils.isEmpty(args)
               || AdministrationSAEMain.HELP.equals(args[0])) {
            // Order des arguments
            LOGGER
                  .info("Help: ligne de commande pour les services d'administration SAE: ");
            LOGGER.info(CommandeSAELineHelper.helpCommandeLine());
         } else if (CREATE_DATA_BASE.equals(args[0])) {
            adminSAE.createSAEBase(newArgs, cnxParameter, context);

         } else if (REINDEX.equals(args[0])) {
            adminSAE.updateIndexes(cnxParameter, context);
         } else if (CREATE_DOC_EVENT.equals(args[0])) {
            adminSAE.createDocumentsEventLogs(cnxParameter, context);
         } else if (CLEAR_DOC_EVENT.equals(args[0])) {
            adminSAE.purgeDocumentsEvents(newArgs, cnxParameter, context);
         } else if (CONSULT_DOC_EVENT.equals(args[0])) {
            adminSAE
                  .extractDocumentsArchiveFile(newArgs, cnxParameter, context);
         } else if (CREATE_SYS_EVENT.equals(args[0])) {
            adminSAE.createSystemEventLogs(cnxParameter, context);
         } else if (CLEAR_SYS_EVENT.equals(args[0])) {
            adminSAE.purgeSystemEvents(newArgs, cnxParameter, context);
         } else if (CONSULT_SYS_EVENT.equals(args[0])) {
            adminSAE.extractSystemArchiveFile(newArgs, cnxParameter, context);
         } else if (UPDATE_LIFECYCLE.equals(args[0])) {
            adminSAE.updateLiveCycleRules(newArgs, cnxParameter, context);
         }
      } catch (BaseAdministrationServiceEx e) {
         throw new BaseAdministrationServiceEx(e.getMessage(), e);
      }
   }

   /**
    * Cette méthode permet d'instancier des objets {@link ApplicationContext} à
    * partir de :
    * <ul>
    * <li>fichier de type ApplicationContext.xml</li>
    * <li>chemin pour un fichier dynamique de configuration</li>
    * </ul>
    * Ici le fichier de configuration du contexte doit contenir des références
    * vers le bean du fichier dynamque de configuration avec la balise : <br>
    * <br>
    * <code>&lt;ref bean="saeConfigResource" /></code> <br>
    * <br>
    * 
    * @param contextConfig
    *           fichier de configuration du contexte
    * 
    * @param saeConfig
    *           chemin complet du fichier de configuration générale du SAE
    * @return contexte d'application
    */
   private static ApplicationContext createSAEApplicationContext(
         final String contextConfig, final String saeConfig) {

      final GenericApplicationContext genericContext = new GenericApplicationContext();
      final BeanDefinitionBuilder saeConfigBean = BeanDefinitionBuilder
            .genericBeanDefinition(FileSystemResource.class);
      saeConfigBean.addConstructorArgValue(saeConfig);

      genericContext.registerBeanDefinition("saeConfigResource", saeConfigBean
            .getBeanDefinition());
      genericContext.refresh();

      final ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
            new String[] { contextConfig }, genericContext);
      return context;

   }

}
